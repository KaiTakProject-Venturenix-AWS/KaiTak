import {
  __commonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/aws-sdk/lib/json/builder.js
var require_builder = __commonJS({
  "node_modules/aws-sdk/lib/json/builder.js"(exports, module) {
    var util = require_util2();
    function JsonBuilder() {
    }
    JsonBuilder.prototype.build = function(value, shape) {
      return JSON.stringify(translate(value, shape));
    };
    function translate(value, shape) {
      if (!shape || value === void 0 || value === null)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (shape.isDocument) {
        return structure;
      }
      var struct = {};
      util.each(structure, function(name, value) {
        var memberShape = shape.members[name];
        if (memberShape) {
          if (memberShape.location !== "body")
            return;
          var locationName = memberShape.isLocationName ? memberShape.name : name;
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[locationName] = result;
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result !== void 0)
          out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result !== void 0)
          out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toWireFormat(value);
    }
    module.exports = JsonBuilder;
  }
});

// node_modules/aws-sdk/lib/json/parser.js
var require_parser = __commonJS({
  "node_modules/aws-sdk/lib/json/parser.js"(exports, module) {
    var util = require_util2();
    function JsonParser() {
    }
    JsonParser.prototype.parse = function(value, shape) {
      return translate(JSON.parse(value), shape);
    };
    function translate(value, shape) {
      if (!shape || value === void 0)
        return void 0;
      switch (shape.type) {
        case "structure":
          return translateStructure(value, shape);
        case "map":
          return translateMap(value, shape);
        case "list":
          return translateList(value, shape);
        default:
          return translateScalar(value, shape);
      }
    }
    function translateStructure(structure, shape) {
      if (structure == null)
        return void 0;
      if (shape.isDocument)
        return structure;
      var struct = {};
      var shapeMembers = shape.members;
      var isAwsQueryCompatible = shape.api && shape.api.awsQueryCompatible;
      util.each(shapeMembers, function(name, memberShape) {
        var locationName = memberShape.isLocationName ? memberShape.name : name;
        if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
          var value = structure[locationName];
          var result = translate(value, memberShape);
          if (result !== void 0)
            struct[name] = result;
        } else if (isAwsQueryCompatible && memberShape.defaultValue) {
          if (memberShape.type === "list") {
            struct[name] = typeof memberShape.defaultValue === "function" ? memberShape.defaultValue() : memberShape.defaultValue;
          }
        }
      });
      return struct;
    }
    function translateList(list, shape) {
      if (list == null)
        return void 0;
      var out = [];
      util.arrayEach(list, function(value) {
        var result = translate(value, shape.member);
        if (result === void 0)
          out.push(null);
        else
          out.push(result);
      });
      return out;
    }
    function translateMap(map, shape) {
      if (map == null)
        return void 0;
      var out = {};
      util.each(map, function(key, value) {
        var result = translate(value, shape.value);
        if (result === void 0)
          out[key] = null;
        else
          out[key] = result;
      });
      return out;
    }
    function translateScalar(value, shape) {
      return shape.toType(value);
    }
    module.exports = JsonParser;
  }
});

// node_modules/aws-sdk/lib/protocol/helpers.js
var require_helpers = __commonJS({
  "node_modules/aws-sdk/lib/protocol/helpers.js"(exports, module) {
    var util = require_util2();
    var AWS2 = require_core();
    function populateHostPrefix(request) {
      var enabled = request.service.config.hostPrefixEnabled;
      if (!enabled)
        return request;
      var operationModel = request.service.api.operations[request.operation];
      if (hasEndpointDiscover(request))
        return request;
      if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
        var hostPrefixNotation = operationModel.endpoint.hostPrefix;
        var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
        prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
        validateHostname(request.httpRequest.endpoint.hostname);
      }
      return request;
    }
    function hasEndpointDiscover(request) {
      var api = request.service.api;
      var operationModel = api.operations[request.operation];
      var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
      return operationModel.endpointDiscoveryRequired !== "NULL" || isEndpointOperation === true;
    }
    function expandHostPrefix(hostPrefixNotation, params, shape) {
      util.each(shape.members, function(name, member) {
        if (member.hostLabel === true) {
          if (typeof params[name] !== "string" || params[name] === "") {
            throw util.error(new Error(), {
              message: "Parameter " + name + " should be a non-empty string.",
              code: "InvalidParameter"
            });
          }
          var regex = new RegExp("\\{" + name + "\\}", "g");
          hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
        }
      });
      return hostPrefixNotation;
    }
    function prependEndpointPrefix(endpoint, prefix) {
      if (endpoint.host) {
        endpoint.host = prefix + endpoint.host;
      }
      if (endpoint.hostname) {
        endpoint.hostname = prefix + endpoint.hostname;
      }
    }
    function validateHostname(hostname) {
      var labels = hostname.split(".");
      var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
      util.arrayEach(labels, function(label) {
        if (!label.length || label.length < 1 || label.length > 63) {
          throw util.error(new Error(), {
            code: "ValidationError",
            message: "Hostname label length should be between 1 to 63 characters, inclusive."
          });
        }
        if (!hostPattern.test(label)) {
          throw AWS2.util.error(
            new Error(),
            { code: "ValidationError", message: label + " is not hostname compatible." }
          );
        }
      });
    }
    module.exports = {
      populateHostPrefix
    };
  }
});

// node_modules/aws-sdk/lib/protocol/json.js
var require_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/json.js"(exports, module) {
    var util = require_util2();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var httpRequest = req.httpRequest;
      var api = req.service.api;
      var target = api.targetPrefix + "." + api.operations[req.operation].name;
      var version = api.jsonVersion || "1.0";
      var input = api.operations[req.operation].input;
      var builder = new JsonBuilder();
      if (version === 1)
        version = "1.0";
      if (api.awsQueryCompatible) {
        if (!httpRequest.params) {
          httpRequest.params = {};
        }
        Object.assign(httpRequest.params, req.params);
      }
      httpRequest.body = builder.build(req.params || {}, input);
      httpRequest.headers["Content-Type"] = "application/x-amz-json-" + version;
      httpRequest.headers["X-Amz-Target"] = target;
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var error = {};
      var httpResponse = resp.httpResponse;
      error.code = httpResponse.headers["x-amzn-errortype"] || "UnknownError";
      if (typeof error.code === "string") {
        error.code = error.code.split(":")[0];
      }
      if (httpResponse.body.length > 0) {
        try {
          var e = JSON.parse(httpResponse.body.toString());
          var code = e.__type || e.code || e.Code;
          if (code) {
            error.code = code.split("#").pop();
          }
          if (error.code === "RequestEntityTooLarge") {
            error.message = "Request body must be less than 1 MB";
          } else {
            error.message = e.message || e.Message || null;
          }
          for (var key in e || {}) {
            if (key === "code" || key === "message") {
              continue;
            }
            error["[" + key + "]"] = "See error." + key + " for details.";
            Object.defineProperty(error, key, {
              value: e[key],
              enumerable: false,
              writable: true
            });
          }
        } catch (e2) {
          error.statusCode = httpResponse.statusCode;
          error.message = httpResponse.statusMessage;
        }
      } else {
        error.statusCode = httpResponse.statusCode;
        error.message = httpResponse.statusCode.toString();
      }
      resp.error = util.error(new Error(), error);
    }
    function extractData(resp) {
      var body = resp.httpResponse.body.toString() || "{}";
      if (resp.request.service.config.convertResponseTypes === false) {
        resp.data = JSON.parse(body);
      } else {
        var operation = resp.request.service.api.operations[resp.request.operation];
        var shape = operation.output || {};
        var parser = new JsonParser();
        resp.data = parser.parse(body, shape);
      }
    }
    module.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/query/query_param_serializer.js
var require_query_param_serializer = __commonJS({
  "node_modules/aws-sdk/lib/query/query_param_serializer.js"(exports, module) {
    var util = require_util2();
    function QueryParamSerializer() {
    }
    QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
      serializeStructure("", params, shape, fn);
    };
    function ucfirst(shape) {
      if (shape.isQueryName || shape.api.protocol !== "ec2") {
        return shape.name;
      } else {
        return shape.name[0].toUpperCase() + shape.name.substr(1);
      }
    }
    function serializeStructure(prefix, struct, rules, fn) {
      util.each(rules.members, function(name, member) {
        var value = struct[name];
        if (value === null || value === void 0)
          return;
        var memberName = ucfirst(member);
        memberName = prefix ? prefix + "." + memberName : memberName;
        serializeMember(memberName, value, member, fn);
      });
    }
    function serializeMap(name, map, rules, fn) {
      var i = 1;
      util.each(map, function(key, value) {
        var prefix = rules.flattened ? "." : ".entry.";
        var position = prefix + i++ + ".";
        var keyName = position + (rules.key.name || "key");
        var valueName = position + (rules.value.name || "value");
        serializeMember(name + keyName, key, rules.key, fn);
        serializeMember(name + valueName, value, rules.value, fn);
      });
    }
    function serializeList(name, list, rules, fn) {
      var memberRules = rules.member || {};
      if (list.length === 0) {
        fn.call(this, name, null);
        return;
      }
      util.arrayEach(list, function(v, n) {
        var suffix = "." + (n + 1);
        if (rules.api.protocol === "ec2") {
          suffix = suffix + "";
        } else if (rules.flattened) {
          if (memberRules.name) {
            var parts = name.split(".");
            parts.pop();
            parts.push(ucfirst(memberRules));
            name = parts.join(".");
          }
        } else {
          suffix = "." + (memberRules.name ? memberRules.name : "member") + suffix;
        }
        serializeMember(name + suffix, v, memberRules, fn);
      });
    }
    function serializeMember(name, value, rules, fn) {
      if (value === null || value === void 0)
        return;
      if (rules.type === "structure") {
        serializeStructure(name, value, rules, fn);
      } else if (rules.type === "list") {
        serializeList(name, value, rules, fn);
      } else if (rules.type === "map") {
        serializeMap(name, value, rules, fn);
      } else {
        fn(name, rules.toWireFormat(value).toString());
      }
    }
    module.exports = QueryParamSerializer;
  }
});

// node_modules/aws-sdk/lib/model/collection.js
var require_collection = __commonJS({
  "node_modules/aws-sdk/lib/model/collection.js"(exports, module) {
    var memoizedProperty = require_util2().memoizedProperty;
    function memoize(name, value, factory, nameTr) {
      memoizedProperty(this, nameTr(name), function() {
        return factory(name, value);
      });
    }
    function Collection(iterable, options, factory, nameTr, callback) {
      nameTr = nameTr || String;
      var self = this;
      for (var id in iterable) {
        if (Object.prototype.hasOwnProperty.call(iterable, id)) {
          memoize.call(self, id, iterable[id], factory, nameTr);
          if (callback)
            callback(id, iterable[id]);
        }
      }
    }
    module.exports = Collection;
  }
});

// node_modules/aws-sdk/lib/model/shape.js
var require_shape = __commonJS({
  "node_modules/aws-sdk/lib/model/shape.js"(exports, module) {
    var Collection = require_collection();
    var util = require_util2();
    function property(obj, name, value) {
      if (value !== null && value !== void 0) {
        util.property.apply(this, arguments);
      }
    }
    function memoizedProperty(obj, name) {
      if (!obj.constructor.prototype[name]) {
        util.memoizedProperty.apply(this, arguments);
      }
    }
    function Shape(shape, options, memberName) {
      options = options || {};
      property(this, "shape", shape.shape);
      property(this, "api", options.api, false);
      property(this, "type", shape.type);
      property(this, "enum", shape.enum);
      property(this, "min", shape.min);
      property(this, "max", shape.max);
      property(this, "pattern", shape.pattern);
      property(this, "location", shape.location || this.location || "body");
      property(this, "name", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
      property(this, "isStreaming", shape.streaming || this.isStreaming || false);
      property(this, "requiresLength", shape.requiresLength, false);
      property(this, "isComposite", shape.isComposite || false);
      property(this, "isShape", true, false);
      property(this, "isQueryName", Boolean(shape.queryName), false);
      property(this, "isLocationName", Boolean(shape.locationName), false);
      property(this, "isIdempotent", shape.idempotencyToken === true);
      property(this, "isJsonValue", shape.jsonvalue === true);
      property(this, "isSensitive", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
      property(this, "isEventStream", Boolean(shape.eventstream), false);
      property(this, "isEvent", Boolean(shape.event), false);
      property(this, "isEventPayload", Boolean(shape.eventpayload), false);
      property(this, "isEventHeader", Boolean(shape.eventheader), false);
      property(this, "isTimestampFormatSet", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
      property(this, "endpointDiscoveryId", Boolean(shape.endpointdiscoveryid), false);
      property(this, "hostLabel", Boolean(shape.hostLabel), false);
      if (options.documentation) {
        property(this, "documentation", shape.documentation);
        property(this, "documentationUrl", shape.documentationUrl);
      }
      if (shape.xmlAttribute) {
        property(this, "isXmlAttribute", shape.xmlAttribute || false);
      }
      property(this, "defaultValue", null);
      this.toWireFormat = function(value) {
        if (value === null || value === void 0)
          return "";
        return value;
      };
      this.toType = function(value) {
        return value;
      };
    }
    Shape.normalizedTypes = {
      character: "string",
      double: "float",
      long: "integer",
      short: "integer",
      biginteger: "integer",
      bigdecimal: "float",
      blob: "binary"
    };
    Shape.types = {
      "structure": StructureShape,
      "list": ListShape,
      "map": MapShape,
      "boolean": BooleanShape,
      "timestamp": TimestampShape,
      "float": FloatShape,
      "integer": IntegerShape,
      "string": StringShape,
      "base64": Base64Shape,
      "binary": BinaryShape
    };
    Shape.resolve = function resolve(shape, options) {
      if (shape.shape) {
        var refShape = options.api.shapes[shape.shape];
        if (!refShape) {
          throw new Error("Cannot find shape reference: " + shape.shape);
        }
        return refShape;
      } else {
        return null;
      }
    };
    Shape.create = function create(shape, options, memberName) {
      if (shape.isShape)
        return shape;
      var refShape = Shape.resolve(shape, options);
      if (refShape) {
        var filteredKeys = Object.keys(shape);
        if (!options.documentation) {
          filteredKeys = filteredKeys.filter(function(name) {
            return !name.match(/documentation/);
          });
        }
        var InlineShape = function() {
          refShape.constructor.call(this, shape, options, memberName);
        };
        InlineShape.prototype = refShape;
        return new InlineShape();
      } else {
        if (!shape.type) {
          if (shape.members)
            shape.type = "structure";
          else if (shape.member)
            shape.type = "list";
          else if (shape.key)
            shape.type = "map";
          else
            shape.type = "string";
        }
        var origType = shape.type;
        if (Shape.normalizedTypes[shape.type]) {
          shape.type = Shape.normalizedTypes[shape.type];
        }
        if (Shape.types[shape.type]) {
          return new Shape.types[shape.type](shape, options, memberName);
        } else {
          throw new Error("Unrecognized shape type: " + origType);
        }
      }
    };
    function CompositeShape(shape) {
      Shape.apply(this, arguments);
      property(this, "isComposite", true);
      if (shape.flattened) {
        property(this, "flattened", shape.flattened || false);
      }
    }
    function StructureShape(shape, options) {
      var self = this;
      var requiredMap = null, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "members", {});
        property(this, "memberNames", []);
        property(this, "required", []);
        property(this, "isRequired", function() {
          return false;
        });
        property(this, "isDocument", Boolean(shape.document));
      }
      if (shape.members) {
        property(this, "members", new Collection(shape.members, options, function(name, member) {
          return Shape.create(member, options, name);
        }));
        memoizedProperty(this, "memberNames", function() {
          return shape.xmlOrder || Object.keys(shape.members);
        });
        if (shape.event) {
          memoizedProperty(this, "eventPayloadMemberName", function() {
            var members = self.members;
            var memberNames = self.memberNames;
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventPayload) {
                return memberNames[i];
              }
            }
          });
          memoizedProperty(this, "eventHeaderMemberNames", function() {
            var members = self.members;
            var memberNames = self.memberNames;
            var eventHeaderMemberNames = [];
            for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
              if (members[memberNames[i]].isEventHeader) {
                eventHeaderMemberNames.push(memberNames[i]);
              }
            }
            return eventHeaderMemberNames;
          });
        }
      }
      if (shape.required) {
        property(this, "required", shape.required);
        property(this, "isRequired", function(name) {
          if (!requiredMap) {
            requiredMap = {};
            for (var i = 0; i < shape.required.length; i++) {
              requiredMap[shape.required[i]] = true;
            }
          }
          return requiredMap[name];
        }, false, true);
      }
      property(this, "resultWrapper", shape.resultWrapper || null);
      if (shape.payload) {
        property(this, "payload", shape.payload);
      }
      if (typeof shape.xmlNamespace === "string") {
        property(this, "xmlNamespaceUri", shape.xmlNamespace);
      } else if (typeof shape.xmlNamespace === "object") {
        property(this, "xmlNamespacePrefix", shape.xmlNamespace.prefix);
        property(this, "xmlNamespaceUri", shape.xmlNamespace.uri);
      }
    }
    function ListShape(shape, options) {
      var self = this, firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return [];
        });
      }
      if (shape.member) {
        memoizedProperty(this, "member", function() {
          return Shape.create(shape.member, options);
        });
      }
      if (this.flattened) {
        var oldName = this.name;
        memoizedProperty(this, "name", function() {
          return self.member.name || oldName;
        });
      }
    }
    function MapShape(shape, options) {
      var firstInit = !this.isShape;
      CompositeShape.apply(this, arguments);
      if (firstInit) {
        property(this, "defaultValue", function() {
          return {};
        });
        property(this, "key", Shape.create({ type: "string" }, options));
        property(this, "value", Shape.create({ type: "string" }, options));
      }
      if (shape.key) {
        memoizedProperty(this, "key", function() {
          return Shape.create(shape.key, options);
        });
      }
      if (shape.value) {
        memoizedProperty(this, "value", function() {
          return Shape.create(shape.value, options);
        });
      }
    }
    function TimestampShape(shape) {
      var self = this;
      Shape.apply(this, arguments);
      if (shape.timestampFormat) {
        property(this, "timestampFormat", shape.timestampFormat);
      } else if (self.isTimestampFormatSet && this.timestampFormat) {
        property(this, "timestampFormat", this.timestampFormat);
      } else if (this.location === "header") {
        property(this, "timestampFormat", "rfc822");
      } else if (this.location === "querystring") {
        property(this, "timestampFormat", "iso8601");
      } else if (this.api) {
        switch (this.api.protocol) {
          case "json":
          case "rest-json":
            property(this, "timestampFormat", "unixTimestamp");
            break;
          case "rest-xml":
          case "query":
          case "ec2":
            property(this, "timestampFormat", "iso8601");
            break;
        }
      }
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        if (typeof value.toUTCString === "function")
          return value;
        return typeof value === "string" || typeof value === "number" ? util.date.parseTimestamp(value) : null;
      };
      this.toWireFormat = function(value) {
        return util.date.format(value, self.timestampFormat);
      };
    }
    function StringShape() {
      Shape.apply(this, arguments);
      var nullLessProtocols = ["rest-xml", "query", "ec2"];
      this.toType = function(value) {
        value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || "" : value;
        if (this.isJsonValue) {
          return JSON.parse(value);
        }
        return value && typeof value.toString === "function" ? value.toString() : value;
      };
      this.toWireFormat = function(value) {
        return this.isJsonValue ? JSON.stringify(value) : value;
      };
    }
    function FloatShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseFloat(value);
      };
      this.toWireFormat = this.toType;
    }
    function IntegerShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (value === null || value === void 0)
          return null;
        return parseInt(value, 10);
      };
      this.toWireFormat = this.toType;
    }
    function BinaryShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        var buf = util.base64.decode(value);
        if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === "function") {
          var secureBuf = util.Buffer.alloc(buf.length, buf);
          buf.fill(0);
          buf = secureBuf;
        }
        return buf;
      };
      this.toWireFormat = util.base64.encode;
    }
    function Base64Shape() {
      BinaryShape.apply(this, arguments);
    }
    function BooleanShape() {
      Shape.apply(this, arguments);
      this.toType = function(value) {
        if (typeof value === "boolean")
          return value;
        if (value === null || value === void 0)
          return null;
        return value === "true";
      };
    }
    Shape.shapes = {
      StructureShape,
      ListShape,
      MapShape,
      StringShape,
      BooleanShape,
      Base64Shape
    };
    module.exports = Shape;
  }
});

// node_modules/aws-sdk/lib/protocol/query.js
var require_query = __commonJS({
  "node_modules/aws-sdk/lib/protocol/query.js"(exports, module) {
    var AWS2 = require_core();
    var util = require_util2();
    var QueryParamSerializer = require_query_param_serializer();
    var Shape = require_shape();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function buildRequest(req) {
      var operation = req.service.api.operations[req.operation];
      var httpRequest = req.httpRequest;
      httpRequest.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
      httpRequest.params = {
        Version: req.service.api.apiVersion,
        Action: operation.name
      };
      var builder = new QueryParamSerializer();
      builder.serialize(req.params, operation.input, function(name, value) {
        httpRequest.params[name] = value;
      });
      httpRequest.body = util.queryParamsToString(httpRequest.params);
      populateHostPrefix(req);
    }
    function extractError(resp) {
      var data, body = resp.httpResponse.body.toString();
      if (body.match("<UnknownOperationException")) {
        data = {
          Code: "UnknownOperation",
          Message: "Unknown operation " + resp.request.operation
        };
      } else {
        try {
          data = new AWS2.XML.Parser().parse(body);
        } catch (e) {
          data = {
            Code: resp.httpResponse.statusCode,
            Message: resp.httpResponse.statusMessage
          };
        }
      }
      if (data.requestId && !resp.requestId)
        resp.requestId = data.requestId;
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    function extractData(resp) {
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var shape = operation.output || {};
      var origRules = shape;
      if (origRules.resultWrapper) {
        var tmp = Shape.create({ type: "structure" });
        tmp.members[origRules.resultWrapper] = shape;
        tmp.memberNames = [origRules.resultWrapper];
        util.property(shape, "name", shape.resultWrapper);
        shape = tmp;
      }
      var parser = new AWS2.XML.Parser();
      if (shape && shape.members && !shape.members._XAMZRequestId) {
        var requestIdShape = Shape.create(
          { type: "string" },
          { api: { protocol: "query" } },
          "requestId"
        );
        shape.members._XAMZRequestId = requestIdShape;
      }
      var data = parser.parse(resp.httpResponse.body.toString(), shape);
      resp.requestId = data._XAMZRequestId || data.requestId;
      if (data._XAMZRequestId)
        delete data._XAMZRequestId;
      if (origRules.resultWrapper) {
        if (data[origRules.resultWrapper]) {
          util.update(data, data[origRules.resultWrapper]);
          delete data[origRules.resultWrapper];
        }
      }
      resp.data = data;
    }
    module.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest.js
var require_rest = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest.js"(exports, module) {
    var util = require_util2();
    var populateHostPrefix = require_helpers().populateHostPrefix;
    function populateMethod(req) {
      req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
    }
    function generateURI(endpointPath, operationPath, input, params) {
      var uri = [endpointPath, operationPath].join("/");
      uri = uri.replace(/\/+/g, "/");
      var queryString = {}, queryStringSet = false;
      util.each(input.members, function(name, member) {
        var paramValue = params[name];
        if (paramValue === null || paramValue === void 0)
          return;
        if (member.location === "uri") {
          var regex = new RegExp("\\{" + member.name + "(\\+)?\\}");
          uri = uri.replace(regex, function(_, plus) {
            var fn = plus ? util.uriEscapePath : util.uriEscape;
            return fn(String(paramValue));
          });
        } else if (member.location === "querystring") {
          queryStringSet = true;
          if (member.type === "list") {
            queryString[member.name] = paramValue.map(function(val) {
              return util.uriEscape(member.member.toWireFormat(val).toString());
            });
          } else if (member.type === "map") {
            util.each(paramValue, function(key, value) {
              if (Array.isArray(value)) {
                queryString[key] = value.map(function(val) {
                  return util.uriEscape(String(val));
                });
              } else {
                queryString[key] = util.uriEscape(String(value));
              }
            });
          } else {
            queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
          }
        }
      });
      if (queryStringSet) {
        uri += uri.indexOf("?") >= 0 ? "&" : "?";
        var parts = [];
        util.arrayEach(Object.keys(queryString).sort(), function(key) {
          if (!Array.isArray(queryString[key])) {
            queryString[key] = [queryString[key]];
          }
          for (var i = 0; i < queryString[key].length; i++) {
            parts.push(util.uriEscape(String(key)) + "=" + queryString[key][i]);
          }
        });
        uri += parts.join("&");
      }
      return uri;
    }
    function populateURI(req) {
      var operation = req.service.api.operations[req.operation];
      var input = operation.input;
      var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
      req.httpRequest.path = uri;
    }
    function populateHeaders(req) {
      var operation = req.service.api.operations[req.operation];
      util.each(operation.input.members, function(name, member) {
        var value = req.params[name];
        if (value === null || value === void 0)
          return;
        if (member.location === "headers" && member.type === "map") {
          util.each(value, function(key, memberValue) {
            req.httpRequest.headers[member.name + key] = memberValue;
          });
        } else if (member.location === "header") {
          value = member.toWireFormat(value).toString();
          if (member.isJsonValue) {
            value = util.base64.encode(value);
          }
          req.httpRequest.headers[member.name] = value;
        }
      });
    }
    function buildRequest(req) {
      populateMethod(req);
      populateURI(req);
      populateHeaders(req);
      populateHostPrefix(req);
    }
    function extractError() {
    }
    function extractData(resp) {
      var req = resp.request;
      var data = {};
      var r = resp.httpResponse;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var headers = {};
      util.each(r.headers, function(k, v) {
        headers[k.toLowerCase()] = v;
      });
      util.each(output.members, function(name, member) {
        var header = (member.name || name).toLowerCase();
        if (member.location === "headers" && member.type === "map") {
          data[name] = {};
          var location = member.isLocationName ? member.name : "";
          var pattern = new RegExp("^" + location + "(.+)", "i");
          util.each(r.headers, function(k, v) {
            var result = k.match(pattern);
            if (result !== null) {
              data[name][result[1]] = v;
            }
          });
        } else if (member.location === "header") {
          if (headers[header] !== void 0) {
            var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
            data[name] = member.toType(value);
          }
        } else if (member.location === "statusCode") {
          data[name] = parseInt(r.statusCode, 10);
        }
      });
      resp.data = data;
    }
    module.exports = {
      buildRequest,
      extractError,
      extractData,
      generateURI
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_json.js
var require_rest_json = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_json.js"(exports, module) {
    var util = require_util2();
    var Rest = require_rest();
    var Json = require_json();
    var JsonBuilder = require_builder();
    var JsonParser = require_parser();
    var METHODS_WITHOUT_BODY = ["GET", "HEAD", "DELETE"];
    function unsetContentLength(req) {
      var payloadMember = util.getRequestPayloadShape(req);
      if (payloadMember === void 0 && METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) >= 0) {
        delete req.httpRequest.headers["Content-Length"];
      }
    }
    function populateBody(req) {
      var builder = new JsonBuilder();
      var input = req.service.api.operations[req.operation].input;
      if (input.payload) {
        var params = {};
        var payloadShape = input.members[input.payload];
        params = req.params[input.payload];
        if (payloadShape.type === "structure") {
          req.httpRequest.body = builder.build(params || {}, payloadShape);
          applyContentTypeHeader(req);
        } else if (params !== void 0) {
          req.httpRequest.body = params;
          if (payloadShape.type === "binary" || payloadShape.isStreaming) {
            applyContentTypeHeader(req, true);
          }
        }
      } else {
        req.httpRequest.body = builder.build(req.params, input);
        applyContentTypeHeader(req);
      }
    }
    function applyContentTypeHeader(req, isBinary) {
      if (!req.httpRequest.headers["Content-Type"]) {
        var type = isBinary ? "binary/octet-stream" : "application/json";
        req.httpRequest.headers["Content-Type"] = type;
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Json.extractError(resp);
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var req = resp.request;
      var operation = req.service.api.operations[req.operation];
      var rules = req.service.api.operations[req.operation].output || {};
      var parser;
      var hasEventOutput = operation.hasEventOutput;
      if (rules.payload) {
        var payloadMember = rules.members[rules.payload];
        var body = resp.httpResponse.body;
        if (payloadMember.isEventStream) {
          parser = new JsonParser();
          resp.data[payload] = util.createEventStream(
            AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === "structure" || payloadMember.type === "list") {
          var parser = new JsonParser();
          resp.data[rules.payload] = parser.parse(body, payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[rules.payload] = body;
        } else {
          resp.data[rules.payload] = payloadMember.toType(body);
        }
      } else {
        var data = resp.data;
        Json.extractData(resp);
        resp.data = util.merge(data, resp.data);
      }
    }
    module.exports = {
      buildRequest,
      extractError,
      extractData,
      unsetContentLength
    };
  }
});

// node_modules/aws-sdk/lib/protocol/rest_xml.js
var require_rest_xml = __commonJS({
  "node_modules/aws-sdk/lib/protocol/rest_xml.js"(exports, module) {
    var AWS2 = require_core();
    var util = require_util2();
    var Rest = require_rest();
    function populateBody(req) {
      var input = req.service.api.operations[req.operation].input;
      var builder = new AWS2.XML.Builder();
      var params = req.params;
      var payload2 = input.payload;
      if (payload2) {
        var payloadMember = input.members[payload2];
        params = params[payload2];
        if (params === void 0)
          return;
        if (payloadMember.type === "structure") {
          var rootElement = payloadMember.name;
          req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
        } else {
          req.httpRequest.body = params;
        }
      } else {
        req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + "Request");
      }
    }
    function buildRequest(req) {
      Rest.buildRequest(req);
      if (["GET", "HEAD"].indexOf(req.httpRequest.method) < 0) {
        populateBody(req);
      }
    }
    function extractError(resp) {
      Rest.extractError(resp);
      var data;
      try {
        data = new AWS2.XML.Parser().parse(resp.httpResponse.body.toString());
      } catch (e) {
        data = {
          Code: resp.httpResponse.statusCode,
          Message: resp.httpResponse.statusMessage
        };
      }
      if (data.Errors)
        data = data.Errors;
      if (data.Error)
        data = data.Error;
      if (data.Code) {
        resp.error = util.error(new Error(), {
          code: data.Code,
          message: data.Message
        });
      } else {
        resp.error = util.error(new Error(), {
          code: resp.httpResponse.statusCode,
          message: null
        });
      }
    }
    function extractData(resp) {
      Rest.extractData(resp);
      var parser;
      var req = resp.request;
      var body = resp.httpResponse.body;
      var operation = req.service.api.operations[req.operation];
      var output = operation.output;
      var hasEventOutput = operation.hasEventOutput;
      var payload2 = output.payload;
      if (payload2) {
        var payloadMember = output.members[payload2];
        if (payloadMember.isEventStream) {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = util.createEventStream(
            AWS2.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
            parser,
            payloadMember
          );
        } else if (payloadMember.type === "structure") {
          parser = new AWS2.XML.Parser();
          resp.data[payload2] = parser.parse(body.toString(), payloadMember);
        } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
          resp.data[payload2] = body;
        } else {
          resp.data[payload2] = payloadMember.toType(body);
        }
      } else if (body.length > 0) {
        parser = new AWS2.XML.Parser();
        var data = parser.parse(body.toString(), output);
        util.update(resp.data, data);
      }
    }
    module.exports = {
      buildRequest,
      extractError,
      extractData
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-attribute.js
var require_escape_attribute = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-attribute.js"(exports, module) {
    function escapeAttribute(value) {
      return value.replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
    module.exports = {
      escapeAttribute
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-node.js
var require_xml_node = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-node.js"(exports, module) {
    var escapeAttribute = require_escape_attribute().escapeAttribute;
    function XmlNode(name, children) {
      if (children === void 0) {
        children = [];
      }
      this.name = name;
      this.children = children;
      this.attributes = {};
    }
    XmlNode.prototype.addAttribute = function(name, value) {
      this.attributes[name] = value;
      return this;
    };
    XmlNode.prototype.addChildNode = function(child) {
      this.children.push(child);
      return this;
    };
    XmlNode.prototype.removeAttribute = function(name) {
      delete this.attributes[name];
      return this;
    };
    XmlNode.prototype.toString = function() {
      var hasChildren = Boolean(this.children.length);
      var xmlText = "<" + this.name;
      var attributes = this.attributes;
      for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
        var attributeName = attributeNames[i];
        var attribute = attributes[attributeName];
        if (typeof attribute !== "undefined" && attribute !== null) {
          xmlText += " " + attributeName + '="' + escapeAttribute("" + attribute) + '"';
        }
      }
      return xmlText += !hasChildren ? "/>" : ">" + this.children.map(function(c) {
        return c.toString();
      }).join("") + "</" + this.name + ">";
    };
    module.exports = {
      XmlNode
    };
  }
});

// node_modules/aws-sdk/lib/xml/escape-element.js
var require_escape_element = __commonJS({
  "node_modules/aws-sdk/lib/xml/escape-element.js"(exports, module) {
    function escapeElement(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
    }
    module.exports = {
      escapeElement
    };
  }
});

// node_modules/aws-sdk/lib/xml/xml-text.js
var require_xml_text = __commonJS({
  "node_modules/aws-sdk/lib/xml/xml-text.js"(exports, module) {
    var escapeElement = require_escape_element().escapeElement;
    function XmlText(value) {
      this.value = value;
    }
    XmlText.prototype.toString = function() {
      return escapeElement("" + this.value);
    };
    module.exports = {
      XmlText
    };
  }
});

// node_modules/aws-sdk/lib/xml/builder.js
var require_builder2 = __commonJS({
  "node_modules/aws-sdk/lib/xml/builder.js"(exports, module) {
    var util = require_util2();
    var XmlNode = require_xml_node().XmlNode;
    var XmlText = require_xml_text().XmlText;
    function XmlBuilder() {
    }
    XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
      var xml = new XmlNode(rootElement);
      applyNamespaces(xml, shape, true);
      serialize(xml, params, shape);
      return xml.children.length > 0 || noEmpty ? xml.toString() : "";
    };
    function serialize(xml, value, shape) {
      switch (shape.type) {
        case "structure":
          return serializeStructure(xml, value, shape);
        case "map":
          return serializeMap(xml, value, shape);
        case "list":
          return serializeList(xml, value, shape);
        default:
          return serializeScalar(xml, value, shape);
      }
    }
    function serializeStructure(xml, params, shape) {
      util.arrayEach(shape.memberNames, function(memberName) {
        var memberShape = shape.members[memberName];
        if (memberShape.location !== "body")
          return;
        var value = params[memberName];
        var name = memberShape.name;
        if (value !== void 0 && value !== null) {
          if (memberShape.isXmlAttribute) {
            xml.addAttribute(name, value);
          } else if (memberShape.flattened) {
            serialize(xml, value, memberShape);
          } else {
            var element = new XmlNode(name);
            xml.addChildNode(element);
            applyNamespaces(element, memberShape);
            serialize(element, value, memberShape);
          }
        }
      });
    }
    function serializeMap(xml, map, shape) {
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      util.each(map, function(key, value) {
        var entry = new XmlNode(shape.flattened ? shape.name : "entry");
        xml.addChildNode(entry);
        var entryKey = new XmlNode(xmlKey);
        var entryValue = new XmlNode(xmlValue);
        entry.addChildNode(entryKey);
        entry.addChildNode(entryValue);
        serialize(entryKey, key, shape.key);
        serialize(entryValue, value, shape.value);
      });
    }
    function serializeList(xml, list, shape) {
      if (shape.flattened) {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || shape.name;
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      } else {
        util.arrayEach(list, function(value) {
          var name = shape.member.name || "member";
          var element = new XmlNode(name);
          xml.addChildNode(element);
          serialize(element, value, shape.member);
        });
      }
    }
    function serializeScalar(xml, value, shape) {
      xml.addChildNode(
        new XmlText(shape.toWireFormat(value))
      );
    }
    function applyNamespaces(xml, shape, isRoot) {
      var uri, prefix = "xmlns";
      if (shape.xmlNamespaceUri) {
        uri = shape.xmlNamespaceUri;
        if (shape.xmlNamespacePrefix)
          prefix += ":" + shape.xmlNamespacePrefix;
      } else if (isRoot && shape.api.xmlNamespaceUri) {
        uri = shape.api.xmlNamespaceUri;
      }
      if (uri)
        xml.addAttribute(prefix, uri);
    }
    module.exports = XmlBuilder;
  }
});

// node_modules/aws-sdk/lib/model/operation.js
var require_operation = __commonJS({
  "node_modules/aws-sdk/lib/model/operation.js"(exports, module) {
    var Shape = require_shape();
    var util = require_util2();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Operation(name, operation, options) {
      var self = this;
      options = options || {};
      property(this, "name", operation.name || name);
      property(this, "api", options.api, false);
      operation.http = operation.http || {};
      property(this, "endpoint", operation.endpoint);
      property(this, "httpMethod", operation.http.method || "POST");
      property(this, "httpPath", operation.http.requestUri || "/");
      property(this, "authtype", operation.authtype || "");
      property(
        this,
        "endpointDiscoveryRequired",
        operation.endpointdiscovery ? operation.endpointdiscovery.required ? "REQUIRED" : "OPTIONAL" : "NULL"
      );
      var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;
      property(this, "httpChecksumRequired", httpChecksumRequired, false);
      memoizedProperty(this, "input", function() {
        if (!operation.input) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.input, options);
      });
      memoizedProperty(this, "output", function() {
        if (!operation.output) {
          return new Shape.create({ type: "structure" }, options);
        }
        return Shape.create(operation.output, options);
      });
      memoizedProperty(this, "errors", function() {
        var list = [];
        if (!operation.errors)
          return null;
        for (var i = 0; i < operation.errors.length; i++) {
          list.push(Shape.create(operation.errors[i], options));
        }
        return list;
      });
      memoizedProperty(this, "paginator", function() {
        return options.api.paginators[name];
      });
      if (options.documentation) {
        property(this, "documentation", operation.documentation);
        property(this, "documentationUrl", operation.documentationUrl);
      }
      memoizedProperty(this, "idempotentMembers", function() {
        var idempotentMembers = [];
        var input = self.input;
        var members = input.members;
        if (!input.members) {
          return idempotentMembers;
        }
        for (var name2 in members) {
          if (!members.hasOwnProperty(name2)) {
            continue;
          }
          if (members[name2].isIdempotent === true) {
            idempotentMembers.push(name2);
          }
        }
        return idempotentMembers;
      });
      memoizedProperty(this, "hasEventOutput", function() {
        var output = self.output;
        return hasEventStream(output);
      });
    }
    function hasEventStream(topLevelShape) {
      var members = topLevelShape.members;
      var payload2 = topLevelShape.payload;
      if (!topLevelShape.members) {
        return false;
      }
      if (payload2) {
        var payloadMember = members[payload2];
        return payloadMember.isEventStream;
      }
      for (var name in members) {
        if (!members.hasOwnProperty(name)) {
          if (members[name].isEventStream === true) {
            return true;
          }
        }
      }
      return false;
    }
    module.exports = Operation;
  }
});

// node_modules/aws-sdk/lib/model/paginator.js
var require_paginator = __commonJS({
  "node_modules/aws-sdk/lib/model/paginator.js"(exports, module) {
    var property = require_util2().property;
    function Paginator(name, paginator) {
      property(this, "inputToken", paginator.input_token);
      property(this, "limitKey", paginator.limit_key);
      property(this, "moreResults", paginator.more_results);
      property(this, "outputToken", paginator.output_token);
      property(this, "resultKey", paginator.result_key);
    }
    module.exports = Paginator;
  }
});

// node_modules/aws-sdk/lib/model/resource_waiter.js
var require_resource_waiter = __commonJS({
  "node_modules/aws-sdk/lib/model/resource_waiter.js"(exports, module) {
    var util = require_util2();
    var property = util.property;
    function ResourceWaiter(name, waiter, options) {
      options = options || {};
      property(this, "name", name);
      property(this, "api", options.api, false);
      if (waiter.operation) {
        property(this, "operation", util.string.lowerFirst(waiter.operation));
      }
      var self = this;
      var keys = [
        "type",
        "description",
        "delay",
        "maxAttempts",
        "acceptors"
      ];
      keys.forEach(function(key) {
        var value = waiter[key];
        if (value) {
          property(self, key, value);
        }
      });
    }
    module.exports = ResourceWaiter;
  }
});

// node_modules/aws-sdk/apis/metadata.json
var require_metadata = __commonJS({
  "node_modules/aws-sdk/apis/metadata.json"(exports, module) {
    module.exports = {
      acm: {
        name: "ACM",
        cors: true
      },
      apigateway: {
        name: "APIGateway",
        cors: true
      },
      applicationautoscaling: {
        prefix: "application-autoscaling",
        name: "ApplicationAutoScaling",
        cors: true
      },
      appstream: {
        name: "AppStream"
      },
      autoscaling: {
        name: "AutoScaling",
        cors: true
      },
      batch: {
        name: "Batch"
      },
      budgets: {
        name: "Budgets"
      },
      clouddirectory: {
        name: "CloudDirectory",
        versions: [
          "2016-05-10*"
        ]
      },
      cloudformation: {
        name: "CloudFormation",
        cors: true
      },
      cloudfront: {
        name: "CloudFront",
        versions: [
          "2013-05-12*",
          "2013-11-11*",
          "2014-05-31*",
          "2014-10-21*",
          "2014-11-06*",
          "2015-04-17*",
          "2015-07-27*",
          "2015-09-17*",
          "2016-01-13*",
          "2016-01-28*",
          "2016-08-01*",
          "2016-08-20*",
          "2016-09-07*",
          "2016-09-29*",
          "2016-11-25*",
          "2017-03-25*",
          "2017-10-30*",
          "2018-06-18*",
          "2018-11-05*",
          "2019-03-26*"
        ],
        cors: true
      },
      cloudhsm: {
        name: "CloudHSM",
        cors: true
      },
      cloudsearch: {
        name: "CloudSearch"
      },
      cloudsearchdomain: {
        name: "CloudSearchDomain"
      },
      cloudtrail: {
        name: "CloudTrail",
        cors: true
      },
      cloudwatch: {
        prefix: "monitoring",
        name: "CloudWatch",
        cors: true
      },
      cloudwatchevents: {
        prefix: "events",
        name: "CloudWatchEvents",
        versions: [
          "2014-02-03*"
        ],
        cors: true
      },
      cloudwatchlogs: {
        prefix: "logs",
        name: "CloudWatchLogs",
        cors: true
      },
      codebuild: {
        name: "CodeBuild",
        cors: true
      },
      codecommit: {
        name: "CodeCommit",
        cors: true
      },
      codedeploy: {
        name: "CodeDeploy",
        cors: true
      },
      codepipeline: {
        name: "CodePipeline",
        cors: true
      },
      cognitoidentity: {
        prefix: "cognito-identity",
        name: "CognitoIdentity",
        cors: true
      },
      cognitoidentityserviceprovider: {
        prefix: "cognito-idp",
        name: "CognitoIdentityServiceProvider",
        cors: true
      },
      cognitosync: {
        prefix: "cognito-sync",
        name: "CognitoSync",
        cors: true
      },
      configservice: {
        prefix: "config",
        name: "ConfigService",
        cors: true
      },
      cur: {
        name: "CUR",
        cors: true
      },
      datapipeline: {
        name: "DataPipeline"
      },
      devicefarm: {
        name: "DeviceFarm",
        cors: true
      },
      directconnect: {
        name: "DirectConnect",
        cors: true
      },
      directoryservice: {
        prefix: "ds",
        name: "DirectoryService"
      },
      discovery: {
        name: "Discovery"
      },
      dms: {
        name: "DMS"
      },
      dynamodb: {
        name: "DynamoDB",
        cors: true
      },
      dynamodbstreams: {
        prefix: "streams.dynamodb",
        name: "DynamoDBStreams",
        cors: true
      },
      ec2: {
        name: "EC2",
        versions: [
          "2013-06-15*",
          "2013-10-15*",
          "2014-02-01*",
          "2014-05-01*",
          "2014-06-15*",
          "2014-09-01*",
          "2014-10-01*",
          "2015-03-01*",
          "2015-04-15*",
          "2015-10-01*",
          "2016-04-01*",
          "2016-09-15*"
        ],
        cors: true
      },
      ecr: {
        name: "ECR",
        cors: true
      },
      ecs: {
        name: "ECS",
        cors: true
      },
      efs: {
        prefix: "elasticfilesystem",
        name: "EFS",
        cors: true
      },
      elasticache: {
        name: "ElastiCache",
        versions: [
          "2012-11-15*",
          "2014-03-24*",
          "2014-07-15*",
          "2014-09-30*"
        ],
        cors: true
      },
      elasticbeanstalk: {
        name: "ElasticBeanstalk",
        cors: true
      },
      elb: {
        prefix: "elasticloadbalancing",
        name: "ELB",
        cors: true
      },
      elbv2: {
        prefix: "elasticloadbalancingv2",
        name: "ELBv2",
        cors: true
      },
      emr: {
        prefix: "elasticmapreduce",
        name: "EMR",
        cors: true
      },
      es: {
        name: "ES"
      },
      elastictranscoder: {
        name: "ElasticTranscoder",
        cors: true
      },
      firehose: {
        name: "Firehose",
        cors: true
      },
      gamelift: {
        name: "GameLift",
        cors: true
      },
      glacier: {
        name: "Glacier"
      },
      health: {
        name: "Health"
      },
      iam: {
        name: "IAM",
        cors: true
      },
      importexport: {
        name: "ImportExport"
      },
      inspector: {
        name: "Inspector",
        versions: [
          "2015-08-18*"
        ],
        cors: true
      },
      iot: {
        name: "Iot",
        cors: true
      },
      iotdata: {
        prefix: "iot-data",
        name: "IotData",
        cors: true
      },
      kinesis: {
        name: "Kinesis",
        cors: true
      },
      kinesisanalytics: {
        name: "KinesisAnalytics"
      },
      kms: {
        name: "KMS",
        cors: true
      },
      lambda: {
        name: "Lambda",
        cors: true
      },
      lexruntime: {
        prefix: "runtime.lex",
        name: "LexRuntime",
        cors: true
      },
      lightsail: {
        name: "Lightsail"
      },
      machinelearning: {
        name: "MachineLearning",
        cors: true
      },
      marketplacecommerceanalytics: {
        name: "MarketplaceCommerceAnalytics",
        cors: true
      },
      marketplacemetering: {
        prefix: "meteringmarketplace",
        name: "MarketplaceMetering"
      },
      mturk: {
        prefix: "mturk-requester",
        name: "MTurk",
        cors: true
      },
      mobileanalytics: {
        name: "MobileAnalytics",
        cors: true
      },
      opsworks: {
        name: "OpsWorks",
        cors: true
      },
      opsworkscm: {
        name: "OpsWorksCM"
      },
      organizations: {
        name: "Organizations"
      },
      pinpoint: {
        name: "Pinpoint"
      },
      polly: {
        name: "Polly",
        cors: true
      },
      rds: {
        name: "RDS",
        versions: [
          "2014-09-01*"
        ],
        cors: true
      },
      redshift: {
        name: "Redshift",
        cors: true
      },
      rekognition: {
        name: "Rekognition",
        cors: true
      },
      resourcegroupstaggingapi: {
        name: "ResourceGroupsTaggingAPI"
      },
      route53: {
        name: "Route53",
        cors: true
      },
      route53domains: {
        name: "Route53Domains",
        cors: true
      },
      s3: {
        name: "S3",
        dualstackAvailable: true,
        cors: true
      },
      s3control: {
        name: "S3Control",
        dualstackAvailable: true,
        xmlNoDefaultLists: true
      },
      servicecatalog: {
        name: "ServiceCatalog",
        cors: true
      },
      ses: {
        prefix: "email",
        name: "SES",
        cors: true
      },
      shield: {
        name: "Shield"
      },
      simpledb: {
        prefix: "sdb",
        name: "SimpleDB"
      },
      sms: {
        name: "SMS"
      },
      snowball: {
        name: "Snowball"
      },
      sns: {
        name: "SNS",
        cors: true
      },
      sqs: {
        name: "SQS",
        cors: true
      },
      ssm: {
        name: "SSM",
        cors: true
      },
      storagegateway: {
        name: "StorageGateway",
        cors: true
      },
      stepfunctions: {
        prefix: "states",
        name: "StepFunctions"
      },
      sts: {
        name: "STS",
        cors: true
      },
      support: {
        name: "Support"
      },
      swf: {
        name: "SWF"
      },
      xray: {
        name: "XRay",
        cors: true
      },
      waf: {
        name: "WAF",
        cors: true
      },
      wafregional: {
        prefix: "waf-regional",
        name: "WAFRegional"
      },
      workdocs: {
        name: "WorkDocs",
        cors: true
      },
      workspaces: {
        name: "WorkSpaces"
      },
      codestar: {
        name: "CodeStar"
      },
      lexmodelbuildingservice: {
        prefix: "lex-models",
        name: "LexModelBuildingService",
        cors: true
      },
      marketplaceentitlementservice: {
        prefix: "entitlement.marketplace",
        name: "MarketplaceEntitlementService"
      },
      athena: {
        name: "Athena",
        cors: true
      },
      greengrass: {
        name: "Greengrass"
      },
      dax: {
        name: "DAX"
      },
      migrationhub: {
        prefix: "AWSMigrationHub",
        name: "MigrationHub"
      },
      cloudhsmv2: {
        name: "CloudHSMV2",
        cors: true
      },
      glue: {
        name: "Glue"
      },
      mobile: {
        name: "Mobile"
      },
      pricing: {
        name: "Pricing",
        cors: true
      },
      costexplorer: {
        prefix: "ce",
        name: "CostExplorer",
        cors: true
      },
      mediaconvert: {
        name: "MediaConvert"
      },
      medialive: {
        name: "MediaLive"
      },
      mediapackage: {
        name: "MediaPackage"
      },
      mediastore: {
        name: "MediaStore"
      },
      mediastoredata: {
        prefix: "mediastore-data",
        name: "MediaStoreData",
        cors: true
      },
      appsync: {
        name: "AppSync"
      },
      guardduty: {
        name: "GuardDuty"
      },
      mq: {
        name: "MQ"
      },
      comprehend: {
        name: "Comprehend",
        cors: true
      },
      iotjobsdataplane: {
        prefix: "iot-jobs-data",
        name: "IoTJobsDataPlane"
      },
      kinesisvideoarchivedmedia: {
        prefix: "kinesis-video-archived-media",
        name: "KinesisVideoArchivedMedia",
        cors: true
      },
      kinesisvideomedia: {
        prefix: "kinesis-video-media",
        name: "KinesisVideoMedia",
        cors: true
      },
      kinesisvideo: {
        name: "KinesisVideo",
        cors: true
      },
      sagemakerruntime: {
        prefix: "runtime.sagemaker",
        name: "SageMakerRuntime"
      },
      sagemaker: {
        name: "SageMaker"
      },
      translate: {
        name: "Translate",
        cors: true
      },
      resourcegroups: {
        prefix: "resource-groups",
        name: "ResourceGroups",
        cors: true
      },
      alexaforbusiness: {
        name: "AlexaForBusiness"
      },
      cloud9: {
        name: "Cloud9"
      },
      serverlessapplicationrepository: {
        prefix: "serverlessrepo",
        name: "ServerlessApplicationRepository"
      },
      servicediscovery: {
        name: "ServiceDiscovery"
      },
      workmail: {
        name: "WorkMail"
      },
      autoscalingplans: {
        prefix: "autoscaling-plans",
        name: "AutoScalingPlans"
      },
      transcribeservice: {
        prefix: "transcribe",
        name: "TranscribeService"
      },
      connect: {
        name: "Connect",
        cors: true
      },
      acmpca: {
        prefix: "acm-pca",
        name: "ACMPCA"
      },
      fms: {
        name: "FMS"
      },
      secretsmanager: {
        name: "SecretsManager",
        cors: true
      },
      iotanalytics: {
        name: "IoTAnalytics",
        cors: true
      },
      iot1clickdevicesservice: {
        prefix: "iot1click-devices",
        name: "IoT1ClickDevicesService"
      },
      iot1clickprojects: {
        prefix: "iot1click-projects",
        name: "IoT1ClickProjects"
      },
      pi: {
        name: "PI"
      },
      neptune: {
        name: "Neptune"
      },
      mediatailor: {
        name: "MediaTailor"
      },
      eks: {
        name: "EKS"
      },
      dlm: {
        name: "DLM"
      },
      signer: {
        name: "Signer"
      },
      chime: {
        name: "Chime"
      },
      pinpointemail: {
        prefix: "pinpoint-email",
        name: "PinpointEmail"
      },
      ram: {
        name: "RAM"
      },
      route53resolver: {
        name: "Route53Resolver"
      },
      pinpointsmsvoice: {
        prefix: "sms-voice",
        name: "PinpointSMSVoice"
      },
      quicksight: {
        name: "QuickSight"
      },
      rdsdataservice: {
        prefix: "rds-data",
        name: "RDSDataService"
      },
      amplify: {
        name: "Amplify"
      },
      datasync: {
        name: "DataSync"
      },
      robomaker: {
        name: "RoboMaker"
      },
      transfer: {
        name: "Transfer"
      },
      globalaccelerator: {
        name: "GlobalAccelerator"
      },
      comprehendmedical: {
        name: "ComprehendMedical",
        cors: true
      },
      kinesisanalyticsv2: {
        name: "KinesisAnalyticsV2"
      },
      mediaconnect: {
        name: "MediaConnect"
      },
      fsx: {
        name: "FSx"
      },
      securityhub: {
        name: "SecurityHub"
      },
      appmesh: {
        name: "AppMesh",
        versions: [
          "2018-10-01*"
        ]
      },
      licensemanager: {
        prefix: "license-manager",
        name: "LicenseManager"
      },
      kafka: {
        name: "Kafka"
      },
      apigatewaymanagementapi: {
        name: "ApiGatewayManagementApi"
      },
      apigatewayv2: {
        name: "ApiGatewayV2"
      },
      docdb: {
        name: "DocDB"
      },
      backup: {
        name: "Backup"
      },
      worklink: {
        name: "WorkLink"
      },
      textract: {
        name: "Textract"
      },
      managedblockchain: {
        name: "ManagedBlockchain"
      },
      mediapackagevod: {
        prefix: "mediapackage-vod",
        name: "MediaPackageVod"
      },
      groundstation: {
        name: "GroundStation"
      },
      iotthingsgraph: {
        name: "IoTThingsGraph"
      },
      iotevents: {
        name: "IoTEvents"
      },
      ioteventsdata: {
        prefix: "iotevents-data",
        name: "IoTEventsData"
      },
      personalize: {
        name: "Personalize",
        cors: true
      },
      personalizeevents: {
        prefix: "personalize-events",
        name: "PersonalizeEvents",
        cors: true
      },
      personalizeruntime: {
        prefix: "personalize-runtime",
        name: "PersonalizeRuntime",
        cors: true
      },
      applicationinsights: {
        prefix: "application-insights",
        name: "ApplicationInsights"
      },
      servicequotas: {
        prefix: "service-quotas",
        name: "ServiceQuotas"
      },
      ec2instanceconnect: {
        prefix: "ec2-instance-connect",
        name: "EC2InstanceConnect"
      },
      eventbridge: {
        name: "EventBridge"
      },
      lakeformation: {
        name: "LakeFormation"
      },
      forecastservice: {
        prefix: "forecast",
        name: "ForecastService",
        cors: true
      },
      forecastqueryservice: {
        prefix: "forecastquery",
        name: "ForecastQueryService",
        cors: true
      },
      qldb: {
        name: "QLDB"
      },
      qldbsession: {
        prefix: "qldb-session",
        name: "QLDBSession"
      },
      workmailmessageflow: {
        name: "WorkMailMessageFlow"
      },
      codestarnotifications: {
        prefix: "codestar-notifications",
        name: "CodeStarNotifications"
      },
      savingsplans: {
        name: "SavingsPlans"
      },
      sso: {
        name: "SSO"
      },
      ssooidc: {
        prefix: "sso-oidc",
        name: "SSOOIDC"
      },
      marketplacecatalog: {
        prefix: "marketplace-catalog",
        name: "MarketplaceCatalog",
        cors: true
      },
      dataexchange: {
        name: "DataExchange"
      },
      sesv2: {
        name: "SESV2"
      },
      migrationhubconfig: {
        prefix: "migrationhub-config",
        name: "MigrationHubConfig"
      },
      connectparticipant: {
        name: "ConnectParticipant"
      },
      appconfig: {
        name: "AppConfig"
      },
      iotsecuretunneling: {
        name: "IoTSecureTunneling"
      },
      wafv2: {
        name: "WAFV2"
      },
      elasticinference: {
        prefix: "elastic-inference",
        name: "ElasticInference"
      },
      imagebuilder: {
        name: "Imagebuilder"
      },
      schemas: {
        name: "Schemas"
      },
      accessanalyzer: {
        name: "AccessAnalyzer"
      },
      codegurureviewer: {
        prefix: "codeguru-reviewer",
        name: "CodeGuruReviewer"
      },
      codeguruprofiler: {
        name: "CodeGuruProfiler"
      },
      computeoptimizer: {
        prefix: "compute-optimizer",
        name: "ComputeOptimizer"
      },
      frauddetector: {
        name: "FraudDetector"
      },
      kendra: {
        name: "Kendra"
      },
      networkmanager: {
        name: "NetworkManager"
      },
      outposts: {
        name: "Outposts"
      },
      augmentedairuntime: {
        prefix: "sagemaker-a2i-runtime",
        name: "AugmentedAIRuntime"
      },
      ebs: {
        name: "EBS"
      },
      kinesisvideosignalingchannels: {
        prefix: "kinesis-video-signaling",
        name: "KinesisVideoSignalingChannels",
        cors: true
      },
      detective: {
        name: "Detective"
      },
      codestarconnections: {
        prefix: "codestar-connections",
        name: "CodeStarconnections"
      },
      synthetics: {
        name: "Synthetics"
      },
      iotsitewise: {
        name: "IoTSiteWise"
      },
      macie2: {
        name: "Macie2"
      },
      codeartifact: {
        name: "CodeArtifact"
      },
      honeycode: {
        name: "Honeycode"
      },
      ivs: {
        name: "IVS"
      },
      braket: {
        name: "Braket"
      },
      identitystore: {
        name: "IdentityStore"
      },
      appflow: {
        name: "Appflow"
      },
      redshiftdata: {
        prefix: "redshift-data",
        name: "RedshiftData"
      },
      ssoadmin: {
        prefix: "sso-admin",
        name: "SSOAdmin"
      },
      timestreamquery: {
        prefix: "timestream-query",
        name: "TimestreamQuery"
      },
      timestreamwrite: {
        prefix: "timestream-write",
        name: "TimestreamWrite"
      },
      s3outposts: {
        name: "S3Outposts"
      },
      databrew: {
        name: "DataBrew"
      },
      servicecatalogappregistry: {
        prefix: "servicecatalog-appregistry",
        name: "ServiceCatalogAppRegistry"
      },
      networkfirewall: {
        prefix: "network-firewall",
        name: "NetworkFirewall"
      },
      mwaa: {
        name: "MWAA"
      },
      amplifybackend: {
        name: "AmplifyBackend"
      },
      appintegrations: {
        name: "AppIntegrations"
      },
      connectcontactlens: {
        prefix: "connect-contact-lens",
        name: "ConnectContactLens"
      },
      devopsguru: {
        prefix: "devops-guru",
        name: "DevOpsGuru"
      },
      ecrpublic: {
        prefix: "ecr-public",
        name: "ECRPUBLIC"
      },
      lookoutvision: {
        name: "LookoutVision"
      },
      sagemakerfeaturestoreruntime: {
        prefix: "sagemaker-featurestore-runtime",
        name: "SageMakerFeatureStoreRuntime"
      },
      customerprofiles: {
        prefix: "customer-profiles",
        name: "CustomerProfiles"
      },
      auditmanager: {
        name: "AuditManager"
      },
      emrcontainers: {
        prefix: "emr-containers",
        name: "EMRcontainers"
      },
      healthlake: {
        name: "HealthLake"
      },
      sagemakeredge: {
        prefix: "sagemaker-edge",
        name: "SagemakerEdge"
      },
      amp: {
        name: "Amp",
        cors: true
      },
      greengrassv2: {
        name: "GreengrassV2"
      },
      iotdeviceadvisor: {
        name: "IotDeviceAdvisor"
      },
      iotfleethub: {
        name: "IoTFleetHub"
      },
      iotwireless: {
        name: "IoTWireless"
      },
      location: {
        name: "Location",
        cors: true
      },
      wellarchitected: {
        name: "WellArchitected"
      },
      lexmodelsv2: {
        prefix: "models.lex.v2",
        name: "LexModelsV2"
      },
      lexruntimev2: {
        prefix: "runtime.lex.v2",
        name: "LexRuntimeV2",
        cors: true
      },
      fis: {
        name: "Fis"
      },
      lookoutmetrics: {
        name: "LookoutMetrics"
      },
      mgn: {
        name: "Mgn"
      },
      lookoutequipment: {
        name: "LookoutEquipment"
      },
      nimble: {
        name: "Nimble"
      },
      finspace: {
        name: "Finspace"
      },
      finspacedata: {
        prefix: "finspace-data",
        name: "Finspacedata"
      },
      ssmcontacts: {
        prefix: "ssm-contacts",
        name: "SSMContacts"
      },
      ssmincidents: {
        prefix: "ssm-incidents",
        name: "SSMIncidents"
      },
      applicationcostprofiler: {
        name: "ApplicationCostProfiler"
      },
      apprunner: {
        name: "AppRunner"
      },
      proton: {
        name: "Proton"
      },
      route53recoverycluster: {
        prefix: "route53-recovery-cluster",
        name: "Route53RecoveryCluster"
      },
      route53recoverycontrolconfig: {
        prefix: "route53-recovery-control-config",
        name: "Route53RecoveryControlConfig"
      },
      route53recoveryreadiness: {
        prefix: "route53-recovery-readiness",
        name: "Route53RecoveryReadiness"
      },
      chimesdkidentity: {
        prefix: "chime-sdk-identity",
        name: "ChimeSDKIdentity"
      },
      chimesdkmessaging: {
        prefix: "chime-sdk-messaging",
        name: "ChimeSDKMessaging"
      },
      snowdevicemanagement: {
        prefix: "snow-device-management",
        name: "SnowDeviceManagement"
      },
      memorydb: {
        name: "MemoryDB"
      },
      opensearch: {
        name: "OpenSearch"
      },
      kafkaconnect: {
        name: "KafkaConnect"
      },
      voiceid: {
        prefix: "voice-id",
        name: "VoiceID"
      },
      wisdom: {
        name: "Wisdom"
      },
      account: {
        name: "Account"
      },
      cloudcontrol: {
        name: "CloudControl"
      },
      grafana: {
        name: "Grafana"
      },
      panorama: {
        name: "Panorama"
      },
      chimesdkmeetings: {
        prefix: "chime-sdk-meetings",
        name: "ChimeSDKMeetings"
      },
      resiliencehub: {
        name: "Resiliencehub"
      },
      migrationhubstrategy: {
        name: "MigrationHubStrategy"
      },
      appconfigdata: {
        name: "AppConfigData"
      },
      drs: {
        name: "Drs"
      },
      migrationhubrefactorspaces: {
        prefix: "migration-hub-refactor-spaces",
        name: "MigrationHubRefactorSpaces"
      },
      evidently: {
        name: "Evidently"
      },
      inspector2: {
        name: "Inspector2"
      },
      rbin: {
        name: "Rbin"
      },
      rum: {
        name: "RUM"
      },
      backupgateway: {
        prefix: "backup-gateway",
        name: "BackupGateway"
      },
      iottwinmaker: {
        name: "IoTTwinMaker"
      },
      workspacesweb: {
        prefix: "workspaces-web",
        name: "WorkSpacesWeb"
      },
      amplifyuibuilder: {
        name: "AmplifyUIBuilder"
      },
      keyspaces: {
        name: "Keyspaces"
      },
      billingconductor: {
        name: "Billingconductor"
      },
      pinpointsmsvoicev2: {
        prefix: "pinpoint-sms-voice-v2",
        name: "PinpointSMSVoiceV2"
      },
      ivschat: {
        name: "Ivschat"
      },
      chimesdkmediapipelines: {
        prefix: "chime-sdk-media-pipelines",
        name: "ChimeSDKMediaPipelines"
      },
      emrserverless: {
        prefix: "emr-serverless",
        name: "EMRServerless"
      },
      m2: {
        name: "M2"
      },
      connectcampaigns: {
        name: "ConnectCampaigns"
      },
      redshiftserverless: {
        prefix: "redshift-serverless",
        name: "RedshiftServerless"
      },
      rolesanywhere: {
        name: "RolesAnywhere"
      },
      licensemanagerusersubscriptions: {
        prefix: "license-manager-user-subscriptions",
        name: "LicenseManagerUserSubscriptions"
      },
      backupstorage: {
        name: "BackupStorage"
      },
      privatenetworks: {
        name: "PrivateNetworks"
      },
      supportapp: {
        prefix: "support-app",
        name: "SupportApp"
      },
      controltower: {
        name: "ControlTower"
      },
      iotfleetwise: {
        name: "IoTFleetWise"
      },
      migrationhuborchestrator: {
        name: "MigrationHubOrchestrator"
      },
      connectcases: {
        name: "ConnectCases"
      },
      resourceexplorer2: {
        prefix: "resource-explorer-2",
        name: "ResourceExplorer2"
      },
      scheduler: {
        name: "Scheduler"
      },
      chimesdkvoice: {
        prefix: "chime-sdk-voice",
        name: "ChimeSDKVoice"
      },
      ssmsap: {
        prefix: "ssm-sap",
        name: "SsmSap"
      },
      oam: {
        name: "OAM"
      },
      arczonalshift: {
        prefix: "arc-zonal-shift",
        name: "ARCZonalShift"
      },
      omics: {
        name: "Omics"
      },
      opensearchserverless: {
        name: "OpenSearchServerless"
      },
      securitylake: {
        name: "SecurityLake"
      },
      simspaceweaver: {
        name: "SimSpaceWeaver"
      },
      docdbelastic: {
        prefix: "docdb-elastic",
        name: "DocDBElastic"
      },
      sagemakergeospatial: {
        prefix: "sagemaker-geospatial",
        name: "SageMakerGeospatial"
      },
      codecatalyst: {
        name: "CodeCatalyst"
      },
      pipes: {
        name: "Pipes"
      },
      sagemakermetrics: {
        prefix: "sagemaker-metrics",
        name: "SageMakerMetrics"
      },
      kinesisvideowebrtcstorage: {
        prefix: "kinesis-video-webrtc-storage",
        name: "KinesisVideoWebRTCStorage"
      },
      licensemanagerlinuxsubscriptions: {
        prefix: "license-manager-linux-subscriptions",
        name: "LicenseManagerLinuxSubscriptions"
      },
      kendraranking: {
        prefix: "kendra-ranking",
        name: "KendraRanking"
      },
      cleanrooms: {
        name: "CleanRooms"
      },
      cloudtraildata: {
        prefix: "cloudtrail-data",
        name: "CloudTrailData"
      },
      tnb: {
        name: "Tnb"
      },
      internetmonitor: {
        name: "InternetMonitor"
      },
      ivsrealtime: {
        prefix: "ivs-realtime",
        name: "IVSRealTime"
      },
      vpclattice: {
        prefix: "vpc-lattice",
        name: "VPCLattice"
      },
      osis: {
        name: "OSIS"
      },
      mediapackagev2: {
        name: "MediaPackageV2"
      },
      paymentcryptography: {
        prefix: "payment-cryptography",
        name: "PaymentCryptography"
      },
      paymentcryptographydata: {
        prefix: "payment-cryptography-data",
        name: "PaymentCryptographyData"
      },
      codegurusecurity: {
        prefix: "codeguru-security",
        name: "CodeGuruSecurity"
      },
      verifiedpermissions: {
        name: "VerifiedPermissions"
      },
      appfabric: {
        name: "AppFabric"
      },
      medicalimaging: {
        prefix: "medical-imaging",
        name: "MedicalImaging"
      },
      entityresolution: {
        name: "EntityResolution"
      },
      managedblockchainquery: {
        prefix: "managedblockchain-query",
        name: "ManagedBlockchainQuery"
      },
      neptunedata: {
        name: "Neptunedata"
      },
      pcaconnectorad: {
        prefix: "pca-connector-ad",
        name: "PcaConnectorAd"
      },
      bedrock: {
        name: "Bedrock"
      },
      bedrockruntime: {
        prefix: "bedrock-runtime",
        name: "BedrockRuntime"
      },
      datazone: {
        name: "DataZone"
      },
      launchwizard: {
        prefix: "launch-wizard",
        name: "LaunchWizard"
      },
      trustedadvisor: {
        name: "TrustedAdvisor"
      },
      inspectorscan: {
        prefix: "inspector-scan",
        name: "InspectorScan"
      },
      bcmdataexports: {
        prefix: "bcm-data-exports",
        name: "BCMDataExports"
      },
      costoptimizationhub: {
        prefix: "cost-optimization-hub",
        name: "CostOptimizationHub"
      },
      eksauth: {
        prefix: "eks-auth",
        name: "EKSAuth"
      },
      freetier: {
        name: "FreeTier"
      },
      repostspace: {
        name: "Repostspace"
      },
      workspacesthinclient: {
        prefix: "workspaces-thin-client",
        name: "WorkSpacesThinClient"
      },
      b2bi: {
        name: "B2bi"
      },
      bedrockagent: {
        prefix: "bedrock-agent",
        name: "BedrockAgent"
      },
      bedrockagentruntime: {
        prefix: "bedrock-agent-runtime",
        name: "BedrockAgentRuntime"
      },
      qbusiness: {
        name: "QBusiness"
      },
      qconnect: {
        name: "QConnect"
      },
      cleanroomsml: {
        name: "CleanRoomsML"
      },
      marketplaceagreement: {
        prefix: "marketplace-agreement",
        name: "MarketplaceAgreement"
      },
      marketplacedeployment: {
        prefix: "marketplace-deployment",
        name: "MarketplaceDeployment"
      },
      networkmonitor: {
        name: "NetworkMonitor"
      },
      supplychain: {
        name: "SupplyChain"
      },
      artifact: {
        name: "Artifact"
      },
      chatbot: {
        name: "Chatbot"
      },
      timestreaminfluxdb: {
        prefix: "timestream-influxdb",
        name: "TimestreamInfluxDB"
      },
      codeconnections: {
        name: "CodeConnections"
      },
      deadline: {
        name: "Deadline"
      },
      controlcatalog: {
        name: "ControlCatalog"
      }
    };
  }
});

// node_modules/aws-sdk/lib/model/api.js
var require_api = __commonJS({
  "node_modules/aws-sdk/lib/model/api.js"(exports, module) {
    var Collection = require_collection();
    var Operation = require_operation();
    var Shape = require_shape();
    var Paginator = require_paginator();
    var ResourceWaiter = require_resource_waiter();
    var metadata = require_metadata();
    var util = require_util2();
    var property = util.property;
    var memoizedProperty = util.memoizedProperty;
    function Api(api, options) {
      var self = this;
      api = api || {};
      options = options || {};
      options.api = this;
      api.metadata = api.metadata || {};
      var serviceIdentifier = options.serviceIdentifier;
      delete options.serviceIdentifier;
      property(this, "isApi", true, false);
      property(this, "apiVersion", api.metadata.apiVersion);
      property(this, "endpointPrefix", api.metadata.endpointPrefix);
      property(this, "signingName", api.metadata.signingName);
      property(this, "globalEndpoint", api.metadata.globalEndpoint);
      property(this, "signatureVersion", api.metadata.signatureVersion);
      property(this, "jsonVersion", api.metadata.jsonVersion);
      property(this, "targetPrefix", api.metadata.targetPrefix);
      property(this, "protocol", api.metadata.protocol);
      property(this, "timestampFormat", api.metadata.timestampFormat);
      property(this, "xmlNamespaceUri", api.metadata.xmlNamespace);
      property(this, "abbreviation", api.metadata.serviceAbbreviation);
      property(this, "fullName", api.metadata.serviceFullName);
      property(this, "serviceId", api.metadata.serviceId);
      if (serviceIdentifier && metadata[serviceIdentifier]) {
        property(this, "xmlNoDefaultLists", metadata[serviceIdentifier].xmlNoDefaultLists, false);
      }
      memoizedProperty(this, "className", function() {
        var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
        if (!name)
          return null;
        name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, "");
        if (name === "ElasticLoadBalancing")
          name = "ELB";
        return name;
      });
      function addEndpointOperation(name, operation) {
        if (operation.endpointoperation === true) {
          property(self, "endpointOperation", util.string.lowerFirst(name));
        }
        if (operation.endpointdiscovery && !self.hasRequiredEndpointDiscovery) {
          property(
            self,
            "hasRequiredEndpointDiscovery",
            operation.endpointdiscovery.required === true
          );
        }
      }
      property(this, "operations", new Collection(api.operations, options, function(name, operation) {
        return new Operation(name, operation, options);
      }, util.string.lowerFirst, addEndpointOperation));
      property(this, "shapes", new Collection(api.shapes, options, function(name, shape) {
        return Shape.create(shape, options);
      }));
      property(this, "paginators", new Collection(api.paginators, options, function(name, paginator) {
        return new Paginator(name, paginator, options);
      }));
      property(this, "waiters", new Collection(api.waiters, options, function(name, waiter) {
        return new ResourceWaiter(name, waiter, options);
      }, util.string.lowerFirst));
      if (options.documentation) {
        property(this, "documentation", api.documentation);
        property(this, "documentationUrl", api.documentationUrl);
      }
      property(this, "awsQueryCompatible", api.metadata.awsQueryCompatible);
    }
    module.exports = Api;
  }
});

// node_modules/aws-sdk/lib/api_loader.js
var require_api_loader = __commonJS({
  "node_modules/aws-sdk/lib/api_loader.js"(exports, module) {
    function apiLoader(svc, version) {
      if (!apiLoader.services.hasOwnProperty(svc)) {
        throw new Error("InvalidService: Failed to load api for " + svc);
      }
      return apiLoader.services[svc][version];
    }
    apiLoader.services = {};
    module.exports = apiLoader;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js
var require_LRU = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/utils/LRU.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LinkedListNode = (
      /** @class */
      /* @__PURE__ */ function() {
        function LinkedListNode2(key, value) {
          this.key = key;
          this.value = value;
        }
        return LinkedListNode2;
      }()
    );
    var LRUCache = (
      /** @class */
      function() {
        function LRUCache2(size) {
          this.nodeMap = {};
          this.size = 0;
          if (typeof size !== "number" || size < 1) {
            throw new Error("Cache size can only be positive number");
          }
          this.sizeLimit = size;
        }
        Object.defineProperty(LRUCache2.prototype, "length", {
          get: function() {
            return this.size;
          },
          enumerable: true,
          configurable: true
        });
        LRUCache2.prototype.prependToList = function(node) {
          if (!this.headerNode) {
            this.tailNode = node;
          } else {
            this.headerNode.prev = node;
            node.next = this.headerNode;
          }
          this.headerNode = node;
          this.size++;
        };
        LRUCache2.prototype.removeFromTail = function() {
          if (!this.tailNode) {
            return void 0;
          }
          var node = this.tailNode;
          var prevNode = node.prev;
          if (prevNode) {
            prevNode.next = void 0;
          }
          node.prev = void 0;
          this.tailNode = prevNode;
          this.size--;
          return node;
        };
        LRUCache2.prototype.detachFromList = function(node) {
          if (this.headerNode === node) {
            this.headerNode = node.next;
          }
          if (this.tailNode === node) {
            this.tailNode = node.prev;
          }
          if (node.prev) {
            node.prev.next = node.next;
          }
          if (node.next) {
            node.next.prev = node.prev;
          }
          node.next = void 0;
          node.prev = void 0;
          this.size--;
        };
        LRUCache2.prototype.get = function(key) {
          if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            this.prependToList(node);
            return node.value;
          }
        };
        LRUCache2.prototype.remove = function(key) {
          if (this.nodeMap[key]) {
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
          }
        };
        LRUCache2.prototype.put = function(key, value) {
          if (this.nodeMap[key]) {
            this.remove(key);
          } else if (this.size === this.sizeLimit) {
            var tailNode = this.removeFromTail();
            var key_1 = tailNode.key;
            delete this.nodeMap[key_1];
          }
          var newNode = new LinkedListNode(key, value);
          this.nodeMap[key] = newNode;
          this.prependToList(newNode);
        };
        LRUCache2.prototype.empty = function() {
          var keys = Object.keys(this.nodeMap);
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var node = this.nodeMap[key];
            this.detachFromList(node);
            delete this.nodeMap[key];
          }
        };
        return LRUCache2;
      }()
    );
    exports.LRUCache = LRUCache;
  }
});

// node_modules/aws-sdk/vendor/endpoint-cache/index.js
var require_endpoint_cache = __commonJS({
  "node_modules/aws-sdk/vendor/endpoint-cache/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var LRU_1 = require_LRU();
    var CACHE_SIZE = 1e3;
    var EndpointCache = (
      /** @class */
      function() {
        function EndpointCache2(maxSize) {
          if (maxSize === void 0) {
            maxSize = CACHE_SIZE;
          }
          this.maxSize = maxSize;
          this.cache = new LRU_1.LRUCache(maxSize);
        }
        ;
        Object.defineProperty(EndpointCache2.prototype, "size", {
          get: function() {
            return this.cache.length;
          },
          enumerable: true,
          configurable: true
        });
        EndpointCache2.prototype.put = function(key, value) {
          var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
          var endpointRecord = this.populateValue(value);
          this.cache.put(keyString, endpointRecord);
        };
        EndpointCache2.prototype.get = function(key) {
          var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
          var now = Date.now();
          var records = this.cache.get(keyString);
          if (records) {
            for (var i = records.length - 1; i >= 0; i--) {
              var record = records[i];
              if (record.Expire < now) {
                records.splice(i, 1);
              }
            }
            if (records.length === 0) {
              this.cache.remove(keyString);
              return void 0;
            }
          }
          return records;
        };
        EndpointCache2.getKeyString = function(key) {
          var identifiers = [];
          var identifierNames = Object.keys(key).sort();
          for (var i = 0; i < identifierNames.length; i++) {
            var identifierName = identifierNames[i];
            if (key[identifierName] === void 0)
              continue;
            identifiers.push(key[identifierName]);
          }
          return identifiers.join(" ");
        };
        EndpointCache2.prototype.populateValue = function(endpoints) {
          var now = Date.now();
          return endpoints.map(function(endpoint) {
            return {
              Address: endpoint.Address || "",
              Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1e3
            };
          });
        };
        EndpointCache2.prototype.empty = function() {
          this.cache.empty();
        };
        EndpointCache2.prototype.remove = function(key) {
          var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
          this.cache.remove(keyString);
        };
        return EndpointCache2;
      }()
    );
    exports.EndpointCache = EndpointCache;
  }
});

// node_modules/aws-sdk/lib/sequential_executor.js
var require_sequential_executor = __commonJS({
  "node_modules/aws-sdk/lib/sequential_executor.js"(exports, module) {
    var AWS2 = require_core();
    AWS2.SequentialExecutor = AWS2.util.inherit({
      constructor: function SequentialExecutor() {
        this._events = {};
      },
      /**
       * @api private
       */
      listeners: function listeners(eventName) {
        return this._events[eventName] ? this._events[eventName].slice(0) : [];
      },
      on: function on(eventName, listener, toHead) {
        if (this._events[eventName]) {
          toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
        } else {
          this._events[eventName] = [listener];
        }
        return this;
      },
      onAsync: function onAsync(eventName, listener, toHead) {
        listener._isAsync = true;
        return this.on(eventName, listener, toHead);
      },
      removeListener: function removeListener(eventName, listener) {
        var listeners = this._events[eventName];
        if (listeners) {
          var length = listeners.length;
          var position = -1;
          for (var i = 0; i < length; ++i) {
            if (listeners[i] === listener) {
              position = i;
            }
          }
          if (position > -1) {
            listeners.splice(position, 1);
          }
        }
        return this;
      },
      removeAllListeners: function removeAllListeners(eventName) {
        if (eventName) {
          delete this._events[eventName];
        } else {
          this._events = {};
        }
        return this;
      },
      /**
       * @api private
       */
      emit: function emit(eventName, eventArgs, doneCallback) {
        if (!doneCallback)
          doneCallback = function() {
          };
        var listeners = this.listeners(eventName);
        var count = listeners.length;
        this.callListeners(listeners, eventArgs, doneCallback);
        return count > 0;
      },
      /**
       * @api private
       */
      callListeners: function callListeners(listeners, args, doneCallback, prevError) {
        var self = this;
        var error = prevError || null;
        function callNextListener(err) {
          if (err) {
            error = AWS2.util.error(error || new Error(), err);
            if (self._haltHandlersOnError) {
              return doneCallback.call(self, error);
            }
          }
          self.callListeners(listeners, args, doneCallback, error);
        }
        while (listeners.length > 0) {
          var listener = listeners.shift();
          if (listener._isAsync) {
            listener.apply(self, args.concat([callNextListener]));
            return;
          } else {
            try {
              listener.apply(self, args);
            } catch (err) {
              error = AWS2.util.error(error || new Error(), err);
            }
            if (error && self._haltHandlersOnError) {
              doneCallback.call(self, error);
              return;
            }
          }
        }
        doneCallback.call(self, error);
      },
      /**
       * Adds or copies a set of listeners from another list of
       * listeners or SequentialExecutor object.
       *
       * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
       *   a list of events and callbacks, or an event emitter object
       *   containing listeners to add to this emitter object.
       * @return [AWS.SequentialExecutor] the emitter object, for chaining.
       * @example Adding listeners from a map of listeners
       *   emitter.addListeners({
       *     event1: [function() { ... }, function() { ... }],
       *     event2: [function() { ... }]
       *   });
       *   emitter.emit('event1'); // emitter has event1
       *   emitter.emit('event2'); // emitter has event2
       * @example Adding listeners from another emitter object
       *   var emitter1 = new AWS.SequentialExecutor();
       *   emitter1.on('event1', function() { ... });
       *   emitter1.on('event2', function() { ... });
       *   var emitter2 = new AWS.SequentialExecutor();
       *   emitter2.addListeners(emitter1);
       *   emitter2.emit('event1'); // emitter2 has event1
       *   emitter2.emit('event2'); // emitter2 has event2
       */
      addListeners: function addListeners(listeners) {
        var self = this;
        if (listeners._events)
          listeners = listeners._events;
        AWS2.util.each(listeners, function(event, callbacks) {
          if (typeof callbacks === "function")
            callbacks = [callbacks];
          AWS2.util.arrayEach(callbacks, function(callback) {
            self.on(event, callback);
          });
        });
        return self;
      },
      /**
       * Registers an event with {on} and saves the callback handle function
       * as a property on the emitter object using a given `name`.
       *
       * @param name [String] the property name to set on this object containing
       *   the callback function handle so that the listener can be removed in
       *   the future.
       * @param (see on)
       * @return (see on)
       * @example Adding a named listener DATA_CALLBACK
       *   var listener = function() { doSomething(); };
       *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
       *
       *   // the following prints: true
       *   console.log(emitter.DATA_CALLBACK == listener);
       */
      addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
        this[name] = callback;
        this.addListener(eventName, callback, toHead);
        return this;
      },
      /**
       * @api private
       */
      addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
        callback._isAsync = true;
        return this.addNamedListener(name, eventName, callback, toHead);
      },
      /**
       * Helper method to add a set of named listeners using
       * {addNamedListener}. The callback contains a parameter
       * with a handle to the `addNamedListener` method.
       *
       * @callback callback function(add)
       *   The callback function is called immediately in order to provide
       *   the `add` function to the block. This simplifies the addition of
       *   a large group of named listeners.
       *   @param add [Function] the {addNamedListener} function to call
       *     when registering listeners.
       * @example Adding a set of named listeners
       *   emitter.addNamedListeners(function(add) {
       *     add('DATA_CALLBACK', 'data', function() { ... });
       *     add('OTHER', 'otherEvent', function() { ... });
       *     add('LAST', 'lastEvent', function() { ... });
       *   });
       *
       *   // these properties are now set:
       *   emitter.DATA_CALLBACK;
       *   emitter.OTHER;
       *   emitter.LAST;
       */
      addNamedListeners: function addNamedListeners(callback) {
        var self = this;
        callback(
          function() {
            self.addNamedListener.apply(self, arguments);
          },
          function() {
            self.addNamedAsyncListener.apply(self, arguments);
          }
        );
        return this;
      }
    });
    AWS2.SequentialExecutor.prototype.addListener = AWS2.SequentialExecutor.prototype.on;
    module.exports = AWS2.SequentialExecutor;
  }
});

// node_modules/aws-sdk/lib/region_config_data.json
var require_region_config_data = __commonJS({
  "node_modules/aws-sdk/lib/region_config_data.json"(exports, module) {
    module.exports = {
      rules: {
        "*/*": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.amazonaws.com.cn"
        },
        "eu-isoe-*/*": "euIsoe",
        "us-iso-*/*": "usIso",
        "us-isob-*/*": "usIsob",
        "*/budgets": "globalSSL",
        "*/cloudfront": "globalSSL",
        "*/sts": "globalSSL",
        "*/importexport": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2",
          globalEndpoint: true
        },
        "*/route53": "globalSSL",
        "cn-*/route53": {
          endpoint: "{service}.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-northwest-1"
        },
        "us-gov-*/route53": "globalGovCloud",
        "us-iso-*/route53": {
          endpoint: "{service}.c2s.ic.gov",
          globalEndpoint: true,
          signingRegion: "us-iso-east-1"
        },
        "us-isob-*/route53": {
          endpoint: "{service}.sc2s.sgov.gov",
          globalEndpoint: true,
          signingRegion: "us-isob-east-1"
        },
        "*/waf": "globalSSL",
        "*/iam": "globalSSL",
        "cn-*/iam": {
          endpoint: "{service}.cn-north-1.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-north-1"
        },
        "us-iso-*/iam": {
          endpoint: "{service}.us-iso-east-1.c2s.ic.gov",
          globalEndpoint: true,
          signingRegion: "us-iso-east-1"
        },
        "us-gov-*/iam": "globalGovCloud",
        "*/ce": {
          endpoint: "{service}.us-east-1.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-east-1"
        },
        "cn-*/ce": {
          endpoint: "{service}.cn-northwest-1.amazonaws.com.cn",
          globalEndpoint: true,
          signingRegion: "cn-northwest-1"
        },
        "us-gov-*/sts": {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        "us-gov-west-1/s3": "s3signature",
        "us-west-1/s3": "s3signature",
        "us-west-2/s3": "s3signature",
        "eu-west-1/s3": "s3signature",
        "ap-southeast-1/s3": "s3signature",
        "ap-southeast-2/s3": "s3signature",
        "ap-northeast-1/s3": "s3signature",
        "sa-east-1/s3": "s3signature",
        "us-east-1/s3": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "s3"
        },
        "us-east-1/sdb": {
          endpoint: "{service}.amazonaws.com",
          signatureVersion: "v2"
        },
        "*/sdb": {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "v2"
        },
        "*/resource-explorer-2": "dualstackByDefault",
        "*/kendra-ranking": "dualstackByDefault",
        "*/internetmonitor": "dualstackByDefault",
        "*/codecatalyst": "globalDualstackByDefault"
      },
      fipsRules: {
        "*/*": "fipsStandard",
        "us-gov-*/*": "fipsStandard",
        "us-iso-*/*": {
          endpoint: "{service}-fips.{region}.c2s.ic.gov"
        },
        "us-iso-*/dms": "usIso",
        "us-isob-*/*": {
          endpoint: "{service}-fips.{region}.sc2s.sgov.gov"
        },
        "us-isob-*/dms": "usIsob",
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.amazonaws.com.cn"
        },
        "*/api.ecr": "fips.api.ecr",
        "*/api.sagemaker": "fips.api.sagemaker",
        "*/batch": "fipsDotPrefix",
        "*/eks": "fipsDotPrefix",
        "*/models.lex": "fips.models.lex",
        "*/runtime.lex": "fips.runtime.lex",
        "*/runtime.sagemaker": {
          endpoint: "runtime-fips.sagemaker.{region}.amazonaws.com"
        },
        "*/iam": "fipsWithoutRegion",
        "*/route53": "fipsWithoutRegion",
        "*/transcribe": "fipsDotPrefix",
        "*/waf": "fipsWithoutRegion",
        "us-gov-*/transcribe": "fipsDotPrefix",
        "us-gov-*/api.ecr": "fips.api.ecr",
        "us-gov-*/models.lex": "fips.models.lex",
        "us-gov-*/runtime.lex": "fips.runtime.lex",
        "us-gov-*/access-analyzer": "fipsWithServiceOnly",
        "us-gov-*/acm": "fipsWithServiceOnly",
        "us-gov-*/acm-pca": "fipsWithServiceOnly",
        "us-gov-*/api.sagemaker": "fipsWithServiceOnly",
        "us-gov-*/appconfig": "fipsWithServiceOnly",
        "us-gov-*/application-autoscaling": "fipsWithServiceOnly",
        "us-gov-*/autoscaling": "fipsWithServiceOnly",
        "us-gov-*/autoscaling-plans": "fipsWithServiceOnly",
        "us-gov-*/batch": "fipsWithServiceOnly",
        "us-gov-*/cassandra": "fipsWithServiceOnly",
        "us-gov-*/clouddirectory": "fipsWithServiceOnly",
        "us-gov-*/cloudformation": "fipsWithServiceOnly",
        "us-gov-*/cloudshell": "fipsWithServiceOnly",
        "us-gov-*/cloudtrail": "fipsWithServiceOnly",
        "us-gov-*/config": "fipsWithServiceOnly",
        "us-gov-*/connect": "fipsWithServiceOnly",
        "us-gov-*/databrew": "fipsWithServiceOnly",
        "us-gov-*/dlm": "fipsWithServiceOnly",
        "us-gov-*/dms": "fipsWithServiceOnly",
        "us-gov-*/dynamodb": "fipsWithServiceOnly",
        "us-gov-*/ec2": "fipsWithServiceOnly",
        "us-gov-*/eks": "fipsWithServiceOnly",
        "us-gov-*/elasticache": "fipsWithServiceOnly",
        "us-gov-*/elasticbeanstalk": "fipsWithServiceOnly",
        "us-gov-*/elasticloadbalancing": "fipsWithServiceOnly",
        "us-gov-*/elasticmapreduce": "fipsWithServiceOnly",
        "us-gov-*/events": "fipsWithServiceOnly",
        "us-gov-*/fis": "fipsWithServiceOnly",
        "us-gov-*/glacier": "fipsWithServiceOnly",
        "us-gov-*/greengrass": "fipsWithServiceOnly",
        "us-gov-*/guardduty": "fipsWithServiceOnly",
        "us-gov-*/identitystore": "fipsWithServiceOnly",
        "us-gov-*/imagebuilder": "fipsWithServiceOnly",
        "us-gov-*/kafka": "fipsWithServiceOnly",
        "us-gov-*/kinesis": "fipsWithServiceOnly",
        "us-gov-*/logs": "fipsWithServiceOnly",
        "us-gov-*/mediaconvert": "fipsWithServiceOnly",
        "us-gov-*/monitoring": "fipsWithServiceOnly",
        "us-gov-*/networkmanager": "fipsWithServiceOnly",
        "us-gov-*/organizations": "fipsWithServiceOnly",
        "us-gov-*/outposts": "fipsWithServiceOnly",
        "us-gov-*/participant.connect": "fipsWithServiceOnly",
        "us-gov-*/ram": "fipsWithServiceOnly",
        "us-gov-*/rds": "fipsWithServiceOnly",
        "us-gov-*/redshift": "fipsWithServiceOnly",
        "us-gov-*/resource-groups": "fipsWithServiceOnly",
        "us-gov-*/runtime.sagemaker": "fipsWithServiceOnly",
        "us-gov-*/serverlessrepo": "fipsWithServiceOnly",
        "us-gov-*/servicecatalog-appregistry": "fipsWithServiceOnly",
        "us-gov-*/servicequotas": "fipsWithServiceOnly",
        "us-gov-*/sns": "fipsWithServiceOnly",
        "us-gov-*/sqs": "fipsWithServiceOnly",
        "us-gov-*/ssm": "fipsWithServiceOnly",
        "us-gov-*/streams.dynamodb": "fipsWithServiceOnly",
        "us-gov-*/sts": "fipsWithServiceOnly",
        "us-gov-*/support": "fipsWithServiceOnly",
        "us-gov-*/swf": "fipsWithServiceOnly",
        "us-gov-west-1/states": "fipsWithServiceOnly",
        "us-iso-east-1/elasticfilesystem": {
          endpoint: "elasticfilesystem-fips.{region}.c2s.ic.gov"
        },
        "us-gov-west-1/organizations": "fipsWithServiceOnly",
        "us-gov-west-1/route53": {
          endpoint: "route53.us-gov.amazonaws.com"
        },
        "*/resource-explorer-2": "fipsDualstackByDefault",
        "*/kendra-ranking": "dualstackByDefault",
        "*/internetmonitor": "dualstackByDefault",
        "*/codecatalyst": "fipsGlobalDualstackByDefault"
      },
      dualstackRules: {
        "*/*": {
          endpoint: "{service}.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackLegacy",
        "cn-*/s3": "dualstackLegacyCn",
        "*/s3-control": "dualstackLegacy",
        "cn-*/s3-control": "dualstackLegacyCn",
        "ap-south-1/ec2": "dualstackLegacyEc2",
        "eu-west-1/ec2": "dualstackLegacyEc2",
        "sa-east-1/ec2": "dualstackLegacyEc2",
        "us-east-1/ec2": "dualstackLegacyEc2",
        "us-east-2/ec2": "dualstackLegacyEc2",
        "us-west-2/ec2": "dualstackLegacyEc2"
      },
      dualstackFipsRules: {
        "*/*": {
          endpoint: "{service}-fips.{region}.api.aws"
        },
        "cn-*/*": {
          endpoint: "{service}-fips.{region}.api.amazonwebservices.com.cn"
        },
        "*/s3": "dualstackFipsLegacy",
        "cn-*/s3": "dualstackFipsLegacyCn",
        "*/s3-control": "dualstackFipsLegacy",
        "cn-*/s3-control": "dualstackFipsLegacyCn"
      },
      patterns: {
        globalSSL: {
          endpoint: "https://{service}.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-east-1"
        },
        globalGovCloud: {
          endpoint: "{service}.us-gov.amazonaws.com",
          globalEndpoint: true,
          signingRegion: "us-gov-west-1"
        },
        s3signature: {
          endpoint: "{service}.{region}.amazonaws.com",
          signatureVersion: "s3"
        },
        euIsoe: {
          endpoint: "{service}.{region}.cloud.adc-e.uk"
        },
        usIso: {
          endpoint: "{service}.{region}.c2s.ic.gov"
        },
        usIsob: {
          endpoint: "{service}.{region}.sc2s.sgov.gov"
        },
        fipsStandard: {
          endpoint: "{service}-fips.{region}.amazonaws.com"
        },
        fipsDotPrefix: {
          endpoint: "fips.{service}.{region}.amazonaws.com"
        },
        fipsWithoutRegion: {
          endpoint: "{service}-fips.amazonaws.com"
        },
        "fips.api.ecr": {
          endpoint: "ecr-fips.{region}.amazonaws.com"
        },
        "fips.api.sagemaker": {
          endpoint: "api-fips.sagemaker.{region}.amazonaws.com"
        },
        "fips.models.lex": {
          endpoint: "models-fips.lex.{region}.amazonaws.com"
        },
        "fips.runtime.lex": {
          endpoint: "runtime-fips.lex.{region}.amazonaws.com"
        },
        fipsWithServiceOnly: {
          endpoint: "{service}.{region}.amazonaws.com"
        },
        dualstackLegacy: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com"
        },
        dualstackLegacyCn: {
          endpoint: "{service}.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackFipsLegacy: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com"
        },
        dualstackFipsLegacyCn: {
          endpoint: "{service}-fips.dualstack.{region}.amazonaws.com.cn"
        },
        dualstackLegacyEc2: {
          endpoint: "api.ec2.{region}.aws"
        },
        dualstackByDefault: {
          endpoint: "{service}.{region}.api.aws"
        },
        fipsDualstackByDefault: {
          endpoint: "{service}-fips.{region}.api.aws"
        },
        globalDualstackByDefault: {
          endpoint: "{service}.global.api.aws"
        },
        fipsGlobalDualstackByDefault: {
          endpoint: "{service}-fips.global.api.aws"
        }
      }
    };
  }
});

// node_modules/aws-sdk/lib/region_config.js
var require_region_config = __commonJS({
  "node_modules/aws-sdk/lib/region_config.js"(exports, module) {
    var util = require_util2();
    var regionConfig = require_region_config_data();
    function generateRegionPrefix(region) {
      if (!region)
        return null;
      var parts = region.split("-");
      if (parts.length < 3)
        return null;
      return parts.slice(0, parts.length - 2).join("-") + "-*";
    }
    function derivedKeys(service) {
      var region = service.config.region;
      var regionPrefix = generateRegionPrefix(region);
      var endpointPrefix = service.api.endpointPrefix;
      return [
        [region, endpointPrefix],
        [regionPrefix, endpointPrefix],
        [region, "*"],
        [regionPrefix, "*"],
        ["*", endpointPrefix],
        [region, "internal-*"],
        ["*", "*"]
      ].map(function(item) {
        return item[0] && item[1] ? item.join("/") : null;
      });
    }
    function applyConfig(service, config) {
      util.each(config, function(key, value) {
        if (key === "globalEndpoint")
          return;
        if (service.config[key] === void 0 || service.config[key] === null) {
          service.config[key] = value;
        }
      });
    }
    function configureEndpoint(service) {
      var keys = derivedKeys(service);
      var useFipsEndpoint = service.config.useFipsEndpoint;
      var useDualstackEndpoint = service.config.useDualstackEndpoint;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!key)
          continue;
        var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;
        if (Object.prototype.hasOwnProperty.call(rules, key)) {
          var config = rules[key];
          if (typeof config === "string") {
            config = regionConfig.patterns[config];
          }
          service.isGlobalEndpoint = !!config.globalEndpoint;
          if (config.signingRegion) {
            service.signingRegion = config.signingRegion;
          }
          if (!config.signatureVersion) {
            config.signatureVersion = "v4";
          }
          var useBearer = (service.api && service.api.signatureVersion) === "bearer";
          applyConfig(service, Object.assign(
            {},
            config,
            { signatureVersion: useBearer ? "bearer" : config.signatureVersion }
          ));
          return;
        }
      }
    }
    function getEndpointSuffix(region) {
      var regionRegexes = {
        "^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$": "amazonaws.com",
        "^cn\\-\\w+\\-\\d+$": "amazonaws.com.cn",
        "^us\\-gov\\-\\w+\\-\\d+$": "amazonaws.com",
        "^us\\-iso\\-\\w+\\-\\d+$": "c2s.ic.gov",
        "^us\\-isob\\-\\w+\\-\\d+$": "sc2s.sgov.gov"
      };
      var defaultSuffix = "amazonaws.com";
      var regexes = Object.keys(regionRegexes);
      for (var i = 0; i < regexes.length; i++) {
        var regionPattern = RegExp(regexes[i]);
        var dnsSuffix = regionRegexes[regexes[i]];
        if (regionPattern.test(region))
          return dnsSuffix;
      }
      return defaultSuffix;
    }
    module.exports = {
      configureEndpoint,
      getEndpointSuffix
    };
  }
});

// node_modules/aws-sdk/lib/region/utils.js
var require_utils = __commonJS({
  "node_modules/aws-sdk/lib/region/utils.js"(exports, module) {
    function isFipsRegion(region) {
      return typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
    }
    function isGlobalRegion(region) {
      return typeof region === "string" && ["aws-global", "aws-us-gov-global"].includes(region);
    }
    function getRealRegion(region) {
      return ["fips-aws-global", "aws-fips", "aws-global"].includes(region) ? "us-east-1" : ["fips-aws-us-gov-global", "aws-us-gov-global"].includes(region) ? "us-gov-west-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "");
    }
    module.exports = {
      isFipsRegion,
      isGlobalRegion,
      getRealRegion
    };
  }
});

// node_modules/aws-sdk/lib/service.js
var require_service = __commonJS({
  "node_modules/aws-sdk/lib/service.js"(exports, module) {
    var AWS2 = require_core();
    var Api = require_api();
    var regionConfig = require_region_config();
    var inherit = AWS2.util.inherit;
    var clientCount = 0;
    var region_utils = require_utils();
    AWS2.Service = inherit({
      /**
       * Create a new service object with a configuration object
       *
       * @param config [map] a map of configuration options
       */
      constructor: function Service(config) {
        if (!this.loadServiceClass) {
          throw AWS2.util.error(
            new Error(),
            "Service must be constructed with `new' operator"
          );
        }
        if (config) {
          if (config.region) {
            var region = config.region;
            if (region_utils.isFipsRegion(region)) {
              config.region = region_utils.getRealRegion(region);
              config.useFipsEndpoint = true;
            }
            if (region_utils.isGlobalRegion(region)) {
              config.region = region_utils.getRealRegion(region);
            }
          }
          if (typeof config.useDualstack === "boolean" && typeof config.useDualstackEndpoint !== "boolean") {
            config.useDualstackEndpoint = config.useDualstack;
          }
        }
        var ServiceClass = this.loadServiceClass(config || {});
        if (ServiceClass) {
          var originalConfig = AWS2.util.copy(config);
          var svc = new ServiceClass(config);
          Object.defineProperty(svc, "_originalConfig", {
            get: function() {
              return originalConfig;
            },
            enumerable: false,
            configurable: true
          });
          svc._clientId = ++clientCount;
          return svc;
        }
        this.initialize(config);
      },
      /**
       * @api private
       */
      initialize: function initialize(config) {
        var svcConfig = AWS2.config[this.serviceIdentifier];
        this.config = new AWS2.Config(AWS2.config);
        if (svcConfig)
          this.config.update(svcConfig, true);
        if (config)
          this.config.update(config, true);
        this.validateService();
        if (!this.config.endpoint)
          regionConfig.configureEndpoint(this);
        this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
        this.setEndpoint(this.config.endpoint);
        AWS2.SequentialExecutor.call(this);
        AWS2.Service.addDefaultMonitoringListeners(this);
        if ((this.config.clientSideMonitoring || AWS2.Service._clientSideMonitoring) && this.publisher) {
          var publisher = this.publisher;
          this.addNamedListener("PUBLISH_API_CALL", "apiCall", function PUBLISH_API_CALL(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          });
          this.addNamedListener("PUBLISH_API_ATTEMPT", "apiCallAttempt", function PUBLISH_API_ATTEMPT(event) {
            process.nextTick(function() {
              publisher.eventHandler(event);
            });
          });
        }
      },
      /**
       * @api private
       */
      validateService: function validateService() {
      },
      /**
       * @api private
       */
      loadServiceClass: function loadServiceClass(serviceConfig) {
        var config = serviceConfig;
        if (!AWS2.util.isEmpty(this.api)) {
          return null;
        } else if (config.apiConfig) {
          return AWS2.Service.defineServiceApi(this.constructor, config.apiConfig);
        } else if (!this.constructor.services) {
          return null;
        } else {
          config = new AWS2.Config(AWS2.config);
          config.update(serviceConfig, true);
          var version = config.apiVersions[this.constructor.serviceIdentifier];
          version = version || config.apiVersion;
          return this.getLatestServiceClass(version);
        }
      },
      /**
       * @api private
       */
      getLatestServiceClass: function getLatestServiceClass(version) {
        version = this.getLatestServiceVersion(version);
        if (this.constructor.services[version] === null) {
          AWS2.Service.defineServiceApi(this.constructor, version);
        }
        return this.constructor.services[version];
      },
      /**
       * @api private
       */
      getLatestServiceVersion: function getLatestServiceVersion(version) {
        if (!this.constructor.services || this.constructor.services.length === 0) {
          throw new Error("No services defined on " + this.constructor.serviceIdentifier);
        }
        if (!version) {
          version = "latest";
        } else if (AWS2.util.isType(version, Date)) {
          version = AWS2.util.date.iso8601(version).split("T")[0];
        }
        if (Object.hasOwnProperty(this.constructor.services, version)) {
          return version;
        }
        var keys = Object.keys(this.constructor.services).sort();
        var selectedVersion = null;
        for (var i = keys.length - 1; i >= 0; i--) {
          if (keys[i][keys[i].length - 1] !== "*") {
            selectedVersion = keys[i];
          }
          if (keys[i].substr(0, 10) <= version) {
            return selectedVersion;
          }
        }
        throw new Error("Could not find " + this.constructor.serviceIdentifier + " API to satisfy version constraint `" + version + "'");
      },
      /**
       * @api private
       */
      api: {},
      /**
       * @api private
       */
      defaultRetryCount: 3,
      /**
       * @api private
       */
      customizeRequests: function customizeRequests(callback) {
        if (!callback) {
          this.customRequestHandler = null;
        } else if (typeof callback === "function") {
          this.customRequestHandler = callback;
        } else {
          throw new Error("Invalid callback type '" + typeof callback + "' provided in customizeRequests");
        }
      },
      /**
       * Calls an operation on a service with the given input parameters.
       *
       * @param operation [String] the name of the operation to call on the service.
       * @param params [map] a map of input options for the operation
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      makeRequest: function makeRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = null;
        }
        params = params || {};
        if (this.config.params) {
          var rules = this.api.operations[operation];
          if (rules) {
            params = AWS2.util.copy(params);
            AWS2.util.each(this.config.params, function(key, value) {
              if (rules.input.members[key]) {
                if (params[key] === void 0 || params[key] === null) {
                  params[key] = value;
                }
              }
            });
          }
        }
        var request = new AWS2.Request(this, operation, params);
        this.addAllRequestListeners(request);
        this.attachMonitoringEmitter(request);
        if (callback)
          request.send(callback);
        return request;
      },
      /**
       * Calls an operation on a service with the given input parameters, without
       * any authentication data. This method is useful for "public" API operations.
       *
       * @param operation [String] the name of the operation to call on the service.
       * @param params [map] a map of input options for the operation
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = {};
        }
        var request = this.makeRequest(operation, params).toUnauthenticated();
        return callback ? request.send(callback) : request;
      },
      /**
       * Waits for a given state
       *
       * @param state [String] the state on the service to wait for
       * @param params [map] a map of parameters to pass with each request
       * @option params $waiter [map] a map of configuration options for the waiter
       * @option params $waiter.delay [Number] The number of seconds to wait between
       *                                       requests
       * @option params $waiter.maxAttempts [Number] The maximum number of requests
       *                                             to send while waiting
       * @callback callback function(err, data)
       *   If a callback is supplied, it is called when a response is returned
       *   from the service.
       *   @param err [Error] the error object returned from the request.
       *     Set to `null` if the request is successful.
       *   @param data [Object] the de-serialized data returned from
       *     the request. Set to `null` if a request error occurs.
       */
      waitFor: function waitFor(state, params, callback) {
        var waiter = new AWS2.ResourceWaiter(this, state);
        return waiter.wait(params, callback);
      },
      /**
       * @api private
       */
      addAllRequestListeners: function addAllRequestListeners(request) {
        var list = [
          AWS2.events,
          AWS2.EventListeners.Core,
          this.serviceInterface(),
          AWS2.EventListeners.CorePost
        ];
        for (var i = 0; i < list.length; i++) {
          if (list[i])
            request.addListeners(list[i]);
        }
        if (!this.config.paramValidation) {
          request.removeListener(
            "validate",
            AWS2.EventListeners.Core.VALIDATE_PARAMETERS
          );
        }
        if (this.config.logger) {
          request.addListeners(AWS2.EventListeners.Logger);
        }
        this.setupRequestListeners(request);
        if (typeof this.constructor.prototype.customRequestHandler === "function") {
          this.constructor.prototype.customRequestHandler(request);
        }
        if (Object.prototype.hasOwnProperty.call(this, "customRequestHandler") && typeof this.customRequestHandler === "function") {
          this.customRequestHandler(request);
        }
      },
      /**
       * Event recording metrics for a whole API call.
       * @returns {object} a subset of api call metrics
       * @api private
       */
      apiCallEvent: function apiCallEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCall",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Region: request.httpRequest.region,
          MaxRetriesExceeded: 0,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
        }
        if (response.error) {
          var error = response.error;
          var statusCode = response.httpResponse.statusCode;
          if (statusCode > 299) {
            if (error.code)
              monitoringEvent.FinalAwsException = error.code;
            if (error.message)
              monitoringEvent.FinalAwsExceptionMessage = error.message;
          } else {
            if (error.code || error.name)
              monitoringEvent.FinalSdkException = error.code || error.name;
            if (error.message)
              monitoringEvent.FinalSdkExceptionMessage = error.message;
          }
        }
        return monitoringEvent;
      },
      /**
       * Event recording metrics for an API call attempt.
       * @returns {object} a subset of api call attempt metrics
       * @api private
       */
      apiAttemptEvent: function apiAttemptEvent(request) {
        var api = request.service.api.operations[request.operation];
        var monitoringEvent = {
          Type: "ApiCallAttempt",
          Api: api ? api.name : request.operation,
          Version: 1,
          Service: request.service.api.serviceId || request.service.api.endpointPrefix,
          Fqdn: request.httpRequest.endpoint.hostname,
          UserAgent: request.httpRequest.getUserAgent()
        };
        var response = request.response;
        if (response.httpResponse.statusCode) {
          monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
        }
        if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {
          monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
        }
        if (!response.httpResponse.headers)
          return monitoringEvent;
        if (request.httpRequest.headers["x-amz-security-token"]) {
          monitoringEvent.SessionToken = request.httpRequest.headers["x-amz-security-token"];
        }
        if (response.httpResponse.headers["x-amzn-requestid"]) {
          monitoringEvent.XAmznRequestId = response.httpResponse.headers["x-amzn-requestid"];
        }
        if (response.httpResponse.headers["x-amz-request-id"]) {
          monitoringEvent.XAmzRequestId = response.httpResponse.headers["x-amz-request-id"];
        }
        if (response.httpResponse.headers["x-amz-id-2"]) {
          monitoringEvent.XAmzId2 = response.httpResponse.headers["x-amz-id-2"];
        }
        return monitoringEvent;
      },
      /**
       * Add metrics of failed request.
       * @api private
       */
      attemptFailEvent: function attemptFailEvent(request) {
        var monitoringEvent = this.apiAttemptEvent(request);
        var response = request.response;
        var error = response.error;
        if (response.httpResponse.statusCode > 299) {
          if (error.code)
            monitoringEvent.AwsException = error.code;
          if (error.message)
            monitoringEvent.AwsExceptionMessage = error.message;
        } else {
          if (error.code || error.name)
            monitoringEvent.SdkException = error.code || error.name;
          if (error.message)
            monitoringEvent.SdkExceptionMessage = error.message;
        }
        return monitoringEvent;
      },
      /**
       * Attach listeners to request object to fetch metrics of each request
       * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
       * @api private
       */
      attachMonitoringEmitter: function attachMonitoringEmitter(request) {
        var attemptTimestamp;
        var attemptStartRealTime;
        var attemptLatency;
        var callStartRealTime;
        var attemptCount = 0;
        var region;
        var callTimestamp;
        var self = this;
        var addToHead = true;
        request.on("validate", function() {
          callStartRealTime = AWS2.util.realClock.now();
          callTimestamp = Date.now();
        }, addToHead);
        request.on("sign", function() {
          attemptStartRealTime = AWS2.util.realClock.now();
          attemptTimestamp = Date.now();
          region = request.httpRequest.region;
          attemptCount++;
        }, addToHead);
        request.on("validateResponse", function() {
          attemptLatency = Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
        });
        request.addNamedListener("API_CALL_ATTEMPT", "success", function API_CALL_ATTEMPT() {
          var apiAttemptEvent = self.apiAttemptEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit("apiCallAttempt", [apiAttemptEvent]);
        });
        request.addNamedListener("API_CALL_ATTEMPT_RETRY", "retry", function API_CALL_ATTEMPT_RETRY() {
          var apiAttemptEvent = self.attemptFailEvent(request);
          apiAttemptEvent.Timestamp = attemptTimestamp;
          attemptLatency = attemptLatency || Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
          apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
          apiAttemptEvent.Region = region;
          self.emit("apiCallAttempt", [apiAttemptEvent]);
        });
        request.addNamedListener("API_CALL", "complete", function API_CALL() {
          var apiCallEvent = self.apiCallEvent(request);
          apiCallEvent.AttemptCount = attemptCount;
          if (apiCallEvent.AttemptCount <= 0)
            return;
          apiCallEvent.Timestamp = callTimestamp;
          var latency = Math.round(AWS2.util.realClock.now() - callStartRealTime);
          apiCallEvent.Latency = latency >= 0 ? latency : 0;
          var response = request.response;
          if (response.error && response.error.retryable && typeof response.retryCount === "number" && typeof response.maxRetries === "number" && response.retryCount >= response.maxRetries) {
            apiCallEvent.MaxRetriesExceeded = 1;
          }
          self.emit("apiCall", [apiCallEvent]);
        });
      },
      /**
       * Override this method to setup any custom request listeners for each
       * new request to the service.
       *
       * @method_abstract This is an abstract method.
       */
      setupRequestListeners: function setupRequestListeners(request) {
      },
      /**
       * Gets the signing name for a given request
       * @api private
       */
      getSigningName: function getSigningName() {
        return this.api.signingName || this.api.endpointPrefix;
      },
      /**
       * Gets the signer class for a given request
       * @api private
       */
      getSignerClass: function getSignerClass(request) {
        var version;
        var operation = null;
        var authtype = "";
        if (request) {
          var operations = request.service.api.operations || {};
          operation = operations[request.operation] || null;
          authtype = operation ? operation.authtype : "";
        }
        if (this.config.signatureVersion) {
          version = this.config.signatureVersion;
        } else if (authtype === "v4" || authtype === "v4-unsigned-body") {
          version = "v4";
        } else if (authtype === "bearer") {
          version = "bearer";
        } else {
          version = this.api.signatureVersion;
        }
        return AWS2.Signers.RequestSigner.getVersion(version);
      },
      /**
       * @api private
       */
      serviceInterface: function serviceInterface() {
        switch (this.api.protocol) {
          case "ec2":
            return AWS2.EventListeners.Query;
          case "query":
            return AWS2.EventListeners.Query;
          case "json":
            return AWS2.EventListeners.Json;
          case "rest-json":
            return AWS2.EventListeners.RestJson;
          case "rest-xml":
            return AWS2.EventListeners.RestXml;
        }
        if (this.api.protocol) {
          throw new Error("Invalid service `protocol' " + this.api.protocol + " in API config");
        }
      },
      /**
       * @api private
       */
      successfulResponse: function successfulResponse(resp) {
        return resp.httpResponse.statusCode < 300;
      },
      /**
       * How many times a failed request should be retried before giving up.
       * the defaultRetryCount can be overriden by service classes.
       *
       * @api private
       */
      numRetries: function numRetries() {
        if (this.config.maxRetries !== void 0) {
          return this.config.maxRetries;
        } else {
          return this.defaultRetryCount;
        }
      },
      /**
       * @api private
       */
      retryDelays: function retryDelays(retryCount, err) {
        return AWS2.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
      },
      /**
       * @api private
       */
      retryableError: function retryableError(error) {
        if (this.timeoutError(error))
          return true;
        if (this.networkingError(error))
          return true;
        if (this.expiredCredentialsError(error))
          return true;
        if (this.throttledError(error))
          return true;
        if (error.statusCode >= 500)
          return true;
        return false;
      },
      /**
       * @api private
       */
      networkingError: function networkingError(error) {
        return error.code === "NetworkingError";
      },
      /**
       * @api private
       */
      timeoutError: function timeoutError(error) {
        return error.code === "TimeoutError";
      },
      /**
       * @api private
       */
      expiredCredentialsError: function expiredCredentialsError(error) {
        return error.code === "ExpiredTokenException";
      },
      /**
       * @api private
       */
      clockSkewError: function clockSkewError(error) {
        switch (error.code) {
          case "RequestTimeTooSkewed":
          case "RequestExpired":
          case "InvalidSignatureException":
          case "SignatureDoesNotMatch":
          case "AuthFailure":
          case "RequestInTheFuture":
            return true;
          default:
            return false;
        }
      },
      /**
       * @api private
       */
      getSkewCorrectedDate: function getSkewCorrectedDate() {
        return new Date(Date.now() + this.config.systemClockOffset);
      },
      /**
       * @api private
       */
      applyClockOffset: function applyClockOffset(newServerTime) {
        if (newServerTime) {
          this.config.systemClockOffset = newServerTime - Date.now();
        }
      },
      /**
       * @api private
       */
      isClockSkewed: function isClockSkewed(newServerTime) {
        if (newServerTime) {
          return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 3e5;
        }
      },
      /**
       * @api private
       */
      throttledError: function throttledError(error) {
        if (error.statusCode === 429)
          return true;
        switch (error.code) {
          case "ProvisionedThroughputExceededException":
          case "Throttling":
          case "ThrottlingException":
          case "RequestLimitExceeded":
          case "RequestThrottled":
          case "RequestThrottledException":
          case "TooManyRequestsException":
          case "TransactionInProgressException":
          case "EC2ThrottledException":
            return true;
          default:
            return false;
        }
      },
      /**
       * @api private
       */
      endpointFromTemplate: function endpointFromTemplate(endpoint) {
        if (typeof endpoint !== "string")
          return endpoint;
        var e = endpoint;
        e = e.replace(/\{service\}/g, this.api.endpointPrefix);
        e = e.replace(/\{region\}/g, this.config.region);
        e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? "https" : "http");
        return e;
      },
      /**
       * @api private
       */
      setEndpoint: function setEndpoint(endpoint) {
        this.endpoint = new AWS2.Endpoint(endpoint, this.config);
      },
      /**
       * @api private
       */
      paginationConfig: function paginationConfig(operation, throwException) {
        var paginator = this.api.operations[operation].paginator;
        if (!paginator) {
          if (throwException) {
            var e = new Error();
            throw AWS2.util.error(e, "No pagination configuration for " + operation);
          }
          return null;
        }
        return paginator;
      }
    });
    AWS2.util.update(AWS2.Service, {
      /**
       * Adds one method for each operation described in the api configuration
       *
       * @api private
       */
      defineMethods: function defineMethods(svc) {
        AWS2.util.each(svc.prototype.api.operations, function iterator(method) {
          if (svc.prototype[method])
            return;
          var operation = svc.prototype.api.operations[method];
          if (operation.authtype === "none") {
            svc.prototype[method] = function(params, callback) {
              return this.makeUnauthenticatedRequest(method, params, callback);
            };
          } else {
            svc.prototype[method] = function(params, callback) {
              return this.makeRequest(method, params, callback);
            };
          }
        });
      },
      /**
       * Defines a new Service class using a service identifier and list of versions
       * including an optional set of features (functions) to apply to the class
       * prototype.
       *
       * @param serviceIdentifier [String] the identifier for the service
       * @param versions [Array<String>] a list of versions that work with this
       *   service
       * @param features [Object] an object to attach to the prototype
       * @return [Class<Service>] the service class defined by this function.
       */
      defineService: function defineService(serviceIdentifier, versions, features) {
        AWS2.Service._serviceMap[serviceIdentifier] = true;
        if (!Array.isArray(versions)) {
          features = versions;
          versions = [];
        }
        var svc = inherit(AWS2.Service, features || {});
        if (typeof serviceIdentifier === "string") {
          AWS2.Service.addVersions(svc, versions);
          var identifier = svc.serviceIdentifier || serviceIdentifier;
          svc.serviceIdentifier = identifier;
        } else {
          svc.prototype.api = serviceIdentifier;
          AWS2.Service.defineMethods(svc);
        }
        AWS2.SequentialExecutor.call(this.prototype);
        if (!this.prototype.publisher && AWS2.util.clientSideMonitoring) {
          var Publisher = AWS2.util.clientSideMonitoring.Publisher;
          var configProvider = AWS2.util.clientSideMonitoring.configProvider;
          var publisherConfig = configProvider();
          this.prototype.publisher = new Publisher(publisherConfig);
          if (publisherConfig.enabled) {
            AWS2.Service._clientSideMonitoring = true;
          }
        }
        AWS2.SequentialExecutor.call(svc.prototype);
        AWS2.Service.addDefaultMonitoringListeners(svc.prototype);
        return svc;
      },
      /**
       * @api private
       */
      addVersions: function addVersions(svc, versions) {
        if (!Array.isArray(versions))
          versions = [versions];
        svc.services = svc.services || {};
        for (var i = 0; i < versions.length; i++) {
          if (svc.services[versions[i]] === void 0) {
            svc.services[versions[i]] = null;
          }
        }
        svc.apiVersions = Object.keys(svc.services).sort();
      },
      /**
       * @api private
       */
      defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
        var svc = inherit(superclass, {
          serviceIdentifier: superclass.serviceIdentifier
        });
        function setApi(api) {
          if (api.isApi) {
            svc.prototype.api = api;
          } else {
            svc.prototype.api = new Api(api, {
              serviceIdentifier: superclass.serviceIdentifier
            });
          }
        }
        if (typeof version === "string") {
          if (apiConfig) {
            setApi(apiConfig);
          } else {
            try {
              setApi(AWS2.apiLoader(superclass.serviceIdentifier, version));
            } catch (err) {
              throw AWS2.util.error(err, {
                message: "Could not find API configuration " + superclass.serviceIdentifier + "-" + version
              });
            }
          }
          if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
            superclass.apiVersions = superclass.apiVersions.concat(version).sort();
          }
          superclass.services[version] = svc;
        } else {
          setApi(version);
        }
        AWS2.Service.defineMethods(svc);
        return svc;
      },
      /**
       * @api private
       */
      hasService: function(identifier) {
        return Object.prototype.hasOwnProperty.call(AWS2.Service._serviceMap, identifier);
      },
      /**
       * @param attachOn attach default monitoring listeners to object
       *
       * Each monitoring event should be emitted from service client to service constructor prototype and then
       * to global service prototype like bubbling up. These default monitoring events listener will transfer
       * the monitoring events to the upper layer.
       * @api private
       */
      addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
        attachOn.addNamedListener("MONITOR_EVENTS_BUBBLE", "apiCallAttempt", function EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCallAttempt", [event]);
        });
        attachOn.addNamedListener("CALL_EVENTS_BUBBLE", "apiCall", function CALL_EVENTS_BUBBLE(event) {
          var baseClass = Object.getPrototypeOf(attachOn);
          if (baseClass._events)
            baseClass.emit("apiCall", [event]);
        });
      },
      /**
       * @api private
       */
      _serviceMap: {}
    });
    AWS2.util.mixin(AWS2.Service, AWS2.SequentialExecutor);
    module.exports = AWS2.Service;
  }
});

// node_modules/aws-sdk/lib/credentials.js
var require_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials.js"() {
    var AWS2 = require_core();
    AWS2.Credentials = AWS2.util.inherit({
      /**
       * A credentials object can be created using positional arguments or an options
       * hash.
       *
       * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
       *   Creates a Credentials object with a given set of credential information
       *   as positional arguments.
       *   @param accessKeyId [String] the AWS access key ID
       *   @param secretAccessKey [String] the AWS secret access key
       *   @param sessionToken [String] the optional AWS session token
       *   @example Create a credentials object with AWS credentials
       *     var creds = new AWS.Credentials('akid', 'secret', 'session');
       * @overload AWS.Credentials(options)
       *   Creates a Credentials object with a given set of credential information
       *   as an options hash.
       *   @option options accessKeyId [String] the AWS access key ID
       *   @option options secretAccessKey [String] the AWS secret access key
       *   @option options sessionToken [String] the optional AWS session token
       *   @example Create a credentials object with AWS credentials
       *     var creds = new AWS.Credentials({
       *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
       *     });
       */
      constructor: function Credentials() {
        AWS2.util.hideProperties(this, ["secretAccessKey"]);
        this.expired = false;
        this.expireTime = null;
        this.refreshCallbacks = [];
        if (arguments.length === 1 && typeof arguments[0] === "object") {
          var creds = arguments[0].credentials || arguments[0];
          this.accessKeyId = creds.accessKeyId;
          this.secretAccessKey = creds.secretAccessKey;
          this.sessionToken = creds.sessionToken;
        } else {
          this.accessKeyId = arguments[0];
          this.secretAccessKey = arguments[1];
          this.sessionToken = arguments[2];
        }
      },
      /**
       * @return [Integer] the number of seconds before {expireTime} during which
       *   the credentials will be considered expired.
       */
      expiryWindow: 15,
      /**
       * @return [Boolean] whether the credentials object should call {refresh}
       * @note Subclasses should override this method to provide custom refresh
       *   logic.
       */
      needsRefresh: function needsRefresh() {
        var currentTime = AWS2.util.date.getDate().getTime();
        var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
        if (this.expireTime && adjustedTime > this.expireTime) {
          return true;
        } else {
          return this.expired || !this.accessKeyId || !this.secretAccessKey;
        }
      },
      /**
       * Gets the existing credentials, refreshing them if they are not yet loaded
       * or have expired. Users should call this method before using {refresh},
       * as this will not attempt to reload credentials when they are already
       * loaded into the object.
       *
       * @callback callback function(err)
       *   When this callback is called with no error, it means either credentials
       *   do not need to be refreshed or refreshed credentials information has
       *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
       *   and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       */
      get: function get(callback) {
        var self = this;
        if (this.needsRefresh()) {
          this.refresh(function(err) {
            if (!err)
              self.expired = false;
            if (callback)
              callback(err);
          });
        } else if (callback) {
          callback();
        }
      },
      /**
       * @!method  getPromise()
       *   Returns a 'thenable' promise.
       *   Gets the existing credentials, refreshing them if they are not yet loaded
       *   or have expired. Users should call this method before using {refresh},
       *   as this will not attempt to reload credentials when they are already
       *   loaded into the object.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function()
       *     Called if the promise is fulfilled. When this callback is called, it
       *     means either credentials do not need to be refreshed or refreshed
       *     credentials information has been loaded into the object (as the
       *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `get` call.
       *   @example Calling the `getPromise` method.
       *     var promise = credProvider.getPromise();
       *     promise.then(function() { ... }, function(err) { ... });
       */
      /**
       * @!method  refreshPromise()
       *   Returns a 'thenable' promise.
       *   Refreshes the credentials. Users should call {get} before attempting
       *   to forcibly refresh credentials.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function()
       *     Called if the promise is fulfilled. When this callback is called, it
       *     means refreshed credentials information has been loaded into the object
       *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `refresh` call.
       *   @example Calling the `refreshPromise` method.
       *     var promise = credProvider.refreshPromise();
       *     promise.then(function() { ... }, function(err) { ... });
       */
      /**
       * Refreshes the credentials. Users should call {get} before attempting
       * to forcibly refresh credentials.
       *
       * @callback callback function(err)
       *   When this callback is called with no error, it means refreshed
       *   credentials information has been loaded into the object (as the
       *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @note Subclasses should override this class to reset the
       *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
       *   on the credentials object and then call the callback with
       *   any error information.
       * @see get
       */
      refresh: function refresh(callback) {
        this.expired = false;
        callback();
      },
      /**
       * @api private
       * @param callback
       */
      coalesceRefresh: function coalesceRefresh(callback, sync) {
        var self = this;
        if (self.refreshCallbacks.push(callback) === 1) {
          self.load(function onLoad(err) {
            AWS2.util.arrayEach(self.refreshCallbacks, function(callback2) {
              if (sync) {
                callback2(err);
              } else {
                AWS2.util.defer(function() {
                  callback2(err);
                });
              }
            });
            self.refreshCallbacks.length = 0;
          });
        }
      },
      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        callback();
      }
    });
    AWS2.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getPromise = AWS2.util.promisifyMethod("get", PromiseDependency);
      this.prototype.refreshPromise = AWS2.util.promisifyMethod("refresh", PromiseDependency);
    };
    AWS2.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getPromise;
      delete this.prototype.refreshPromise;
    };
    AWS2.util.addPromises(AWS2.Credentials);
  }
});

// node_modules/aws-sdk/lib/credentials/credential_provider_chain.js
var require_credential_provider_chain = __commonJS({
  "node_modules/aws-sdk/lib/credentials/credential_provider_chain.js"() {
    var AWS2 = require_core();
    AWS2.CredentialProviderChain = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * Creates a new CredentialProviderChain with a default set of providers
       * specified by {defaultProviders}.
       */
      constructor: function CredentialProviderChain(providers) {
        if (providers) {
          this.providers = providers;
        } else {
          this.providers = AWS2.CredentialProviderChain.defaultProviders.slice(0);
        }
        this.resolveCallbacks = [];
      },
      /**
       * @!method  resolvePromise()
       *   Returns a 'thenable' promise.
       *   Resolves the provider chain by searching for the first set of
       *   credentials in {providers}.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(credentials)
       *     Called if the promise is fulfilled and the provider resolves the chain
       *     to a credentials object
       *     @param credentials [AWS.Credentials] the credentials object resolved
       *       by the provider chain.
       *   @callback rejectedCallback function(error)
       *     Called if the promise is rejected.
       *     @param err [Error] the error object returned if no credentials are found.
       *   @return [Promise] A promise that represents the state of the `resolve` method call.
       *   @example Calling the `resolvePromise` method.
       *     var promise = chain.resolvePromise();
       *     promise.then(function(credentials) { ... }, function(err) { ... });
       */
      /**
       * Resolves the provider chain by searching for the first set of
       * credentials in {providers}.
       *
       * @callback callback function(err, credentials)
       *   Called when the provider resolves the chain to a credentials object
       *   or null if no credentials can be found.
       *
       *   @param err [Error] the error object returned if no credentials are
       *     found.
       *   @param credentials [AWS.Credentials] the credentials object resolved
       *     by the provider chain.
       * @return [AWS.CredentialProviderChain] the provider, for chaining.
       */
      resolve: function resolve(callback) {
        var self = this;
        if (self.providers.length === 0) {
          callback(new Error("No providers"));
          return self;
        }
        if (self.resolveCallbacks.push(callback) === 1) {
          let resolveNext2 = function(err, creds) {
            if (!err && creds || index === providers.length) {
              AWS2.util.arrayEach(self.resolveCallbacks, function(callback2) {
                callback2(err, creds);
              });
              self.resolveCallbacks.length = 0;
              return;
            }
            var provider = providers[index++];
            if (typeof provider === "function") {
              creds = provider.call();
            } else {
              creds = provider;
            }
            if (creds.get) {
              creds.get(function(getErr) {
                resolveNext2(getErr, getErr ? null : creds);
              });
            } else {
              resolveNext2(null, creds);
            }
          };
          var resolveNext = resolveNext2;
          var index = 0;
          var providers = self.providers.slice(0);
          resolveNext2();
        }
        return self;
      }
    });
    AWS2.CredentialProviderChain.defaultProviders = [];
    AWS2.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.resolvePromise = AWS2.util.promisifyMethod("resolve", PromiseDependency);
    };
    AWS2.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.resolvePromise;
    };
    AWS2.util.addPromises(AWS2.CredentialProviderChain);
  }
});

// node_modules/aws-sdk/lib/config.js
var require_config = __commonJS({
  "node_modules/aws-sdk/lib/config.js"() {
    var AWS2 = require_core();
    require_credentials();
    require_credential_provider_chain();
    var PromisesDependency;
    AWS2.Config = AWS2.util.inherit({
      /**
       * @!endgroup
       */
      /**
       * Creates a new configuration object. This is the object that passes
       * option data along to service requests, including credentials, security,
       * region information, and some service specific settings.
       *
       * @example Creating a new configuration object with credentials and region
       *   var config = new AWS.Config({
       *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
       *   });
       * @option options accessKeyId [String] your AWS access key ID.
       * @option options secretAccessKey [String] your AWS secret access key.
       * @option options sessionToken [AWS.Credentials] the optional AWS
       *   session token to sign requests with.
       * @option options credentials [AWS.Credentials] the AWS credentials
       *   to sign requests with. You can either specify this object, or
       *   specify the accessKeyId and secretAccessKey options directly.
       * @option options credentialProvider [AWS.CredentialProviderChain] the
       *   provider chain used to resolve credentials if no static `credentials`
       *   property is set.
       * @option options region [String] the region to send service requests to.
       *   See {region} for more information.
       * @option options maxRetries [Integer] the maximum amount of retries to
       *   attempt with a request. See {maxRetries} for more information.
       * @option options maxRedirects [Integer] the maximum amount of redirects to
       *   follow with a request. See {maxRedirects} for more information.
       * @option options sslEnabled [Boolean] whether to enable SSL for
       *   requests.
       * @option options paramValidation [Boolean|map] whether input parameters
       *   should be validated against the operation description before sending
       *   the request. Defaults to true. Pass a map to enable any of the
       *   following specific validation features:
       *
       *   * **min** [Boolean] &mdash; Validates that a value meets the min
       *     constraint. This is enabled by default when paramValidation is set
       *     to `true`.
       *   * **max** [Boolean] &mdash; Validates that a value meets the max
       *     constraint.
       *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
       *     regular expression.
       *   * **enum** [Boolean] &mdash; Validates that a string value matches one
       *     of the allowable enum values.
       * @option options computeChecksums [Boolean] whether to compute checksums
       *   for payload bodies when the service accepts it (currently supported
       *   in S3 only)
       * @option options convertResponseTypes [Boolean] whether types are converted
       *     when parsing response data. Currently only supported for JSON based
       *     services. Turning this off may improve performance on large response
       *     payloads. Defaults to `true`.
       * @option options correctClockSkew [Boolean] whether to apply a clock skew
       *     correction and retry requests that fail because of an skewed client
       *     clock. Defaults to `false`.
       * @option options s3ForcePathStyle [Boolean] whether to force path
       *   style URLs for S3 objects.
       * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
       *   addresses an individual bucket (false if it addresses the root API
       *   endpoint). Note that setting this configuration option requires an
       *   `endpoint` to be provided explicitly to the service constructor.
       * @option options s3DisableBodySigning [Boolean] whether S3 body signing
       *   should be disabled when using signature version `v4`. Body signing
       *   can only be disabled when using https. Defaults to `true`.
       * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
       *   is set to 'us-east-1', whether to send s3 request to global endpoints or
       *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
       *   Defaults to `legacy`
       * @option options s3UseArnRegion [Boolean] whether to override the request region
       *   with the region inferred from requested resource's ARN. Only available for S3 buckets
       *   Defaults to `true`
       *
       * @option options retryDelayOptions [map] A set of options to configure
       *   the retry delay on retryable errors. Currently supported options are:
       *
       *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
       *     exponential backoff for operation retries. Defaults to 100 ms for all
       *     services except DynamoDB, where it defaults to 50ms.
       *   * **customBackoff ** [function] &mdash; A custom function that accepts a
       *     retry count and error and returns the amount of time to delay in
       *     milliseconds. If the result is a non-zero negative value, no further
       *     retry attempts will be made. The `base` option will be ignored if this
       *     option is supplied. The function is only called for retryable errors.
       * @option options httpOptions [map] A set of options to pass to the low-level
       *   HTTP request. Currently supported options are:
       *
       *   * **proxy** [String] &mdash; the URL to proxy requests through
       *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
       *     HTTP requests with. Used for connection pooling. Defaults to the global
       *     agent (`http.globalAgent`) for non-SSL connections. Note that for
       *     SSL connections, a special Agent object is used in order to enable
       *     peer certificate verification. This feature is only available in the
       *     Node.js environment.
       *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
       *     failing to establish a connection with the server after
       *     `connectTimeout` milliseconds. This timeout has no effect once a socket
       *     connection has been established.
       *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
       *     milliseconds of inactivity on the socket. Defaults to two minutes
       *     (120000).
       *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
       *     HTTP requests. Used in the browser environment only. Set to false to
       *     send requests synchronously. Defaults to true (async on).
       *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
       *     property of an XMLHttpRequest object. Used in the browser environment
       *     only. Defaults to false.
       * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
       *   (or a date) that represents the latest possible API version that can be
       *   used in all services (unless overridden by `apiVersions`). Specify
       *   'latest' to use the latest possible version.
       * @option options apiVersions [map<String, String|Date>] a map of service
       *   identifiers (the lowercase service class name) with the API version to
       *   use when instantiating a service. Specify 'latest' for each individual
       *   that can use the latest available version.
       * @option options logger [#write,#log] an object that responds to .write()
       *   (like a stream) or .log() (like the console object) in order to log
       *   information about requests
       * @option options systemClockOffset [Number] an offset value in milliseconds
       *   to apply to all signing times. Use this to compensate for clock skew
       *   when your system may be out of sync with the service time. Note that
       *   this configuration option can only be applied to the global `AWS.config`
       *   object and cannot be overridden in service-specific configuration.
       *   Defaults to 0 milliseconds.
       * @option options signatureVersion [String] the signature version to sign
       *   requests with (overriding the API configuration). Possible values are:
       *   'v2', 'v3', 'v4'.
       * @option options signatureCache [Boolean] whether the signature to sign
       *   requests with (overriding the API configuration) is cached. Only applies
       *   to the signature version 'v4'. Defaults to `true`.
       * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
       *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
       * @option options useAccelerateEndpoint [Boolean] Whether to use the
       *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
       * @option options clientSideMonitoring [Boolean] whether to collect and
       *   publish this client's performance metrics of all its API requests.
       * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
       *   call operations with endpoints given by service dynamically. Setting this
       * config to `true` will enable endpoint discovery for all applicable operations.
       *   Setting it to `false` will explicitly disable endpoint discovery even though
       *   operations that require endpoint discovery will presumably fail. Leaving it
       *   to `undefined` means SDK will only do endpoint discovery when it's required.
       *   Defaults to `undefined`
       * @option options endpointCacheSize [Number] the size of the global cache storing
       *   endpoints from endpoint discovery operations. Once endpoint cache is created,
       *   updating this setting cannot change existing cache size.
       *   Defaults to 1000
       * @option options hostPrefixEnabled [Boolean] whether to marshal request
       *   parameters to the prefix of hostname.
       *   Defaults to `true`.
       * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
       *   to global endpoints or regional endpoints.
       *   Defaults to 'legacy'.
       * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
       *   Defaults to `false`.
       * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
       *   Defaults to `false`.
       */
      constructor: function Config(options) {
        if (options === void 0)
          options = {};
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, this.keys, function(key, value) {
          this.set(key, options[key], value);
        });
      },
      /**
       * @!group Managing Credentials
       */
      /**
       * Loads credentials from the configuration object. This is used internally
       * by the SDK to ensure that refreshable {Credentials} objects are properly
       * refreshed and loaded when sending a request. If you want to ensure that
       * your credentials are loaded prior to a request, you can use this method
       * directly to provide accurate credential data stored in the object.
       *
       * @note If you configure the SDK with static or environment credentials,
       *   the credential data should already be present in {credentials} attribute.
       *   This method is primarily necessary to load credentials from asynchronous
       *   sources, or sources that can refresh credentials periodically.
       * @example Getting your access key
       *   AWS.config.getCredentials(function(err) {
       *     if (err) console.log(err.stack); // credentials not loaded
       *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
       *   })
       * @callback callback function(err)
       *   Called when the {credentials} have been properly set on the configuration
       *   object.
       *
       *   @param err [Error] if this is set, credentials were not successfully
       *     loaded and this error provides information why.
       * @see credentials
       * @see Credentials
       */
      getCredentials: function getCredentials(callback) {
        var self = this;
        function finish(err) {
          callback(err, err ? null : self.credentials);
        }
        function credError(msg, err) {
          return new AWS2.util.error(err || new Error(), {
            code: "CredentialsError",
            message: msg,
            name: "CredentialsError"
          });
        }
        function getAsyncCredentials() {
          self.credentials.get(function(err) {
            if (err) {
              var msg = "Could not load credentials from " + self.credentials.constructor.name;
              err = credError(msg, err);
            }
            finish(err);
          });
        }
        function getStaticCredentials() {
          var err = null;
          if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {
            err = credError("Missing credentials");
          }
          finish(err);
        }
        if (self.credentials) {
          if (typeof self.credentials.get === "function") {
            getAsyncCredentials();
          } else {
            getStaticCredentials();
          }
        } else if (self.credentialProvider) {
          self.credentialProvider.resolve(function(err, creds) {
            if (err) {
              err = credError("Could not load credentials from any providers", err);
            }
            self.credentials = creds;
            finish(err);
          });
        } else {
          finish(credError("No credentials to load"));
        }
      },
      /**
       * Loads token from the configuration object. This is used internally
       * by the SDK to ensure that refreshable {Token} objects are properly
       * refreshed and loaded when sending a request. If you want to ensure that
       * your token is loaded prior to a request, you can use this method
       * directly to provide accurate token data stored in the object.
       *
       * @note If you configure the SDK with static token, the token data should
       *   already be present in {token} attribute. This method is primarily necessary
       *   to load token from asynchronous sources, or sources that can refresh
       *   token periodically.
       * @example Getting your access token
       *   AWS.config.getToken(function(err) {
       *     if (err) console.log(err.stack); // token not loaded
       *     else console.log("Token:", AWS.config.token.token);
       *   })
       * @callback callback function(err)
       *   Called when the {token} have been properly set on the configuration object.
       *
       *   @param err [Error] if this is set, token was not successfully loaded and
       *     this error provides information why.
       * @see token
       */
      getToken: function getToken(callback) {
        var self = this;
        function finish(err) {
          callback(err, err ? null : self.token);
        }
        function tokenError(msg, err) {
          return new AWS2.util.error(err || new Error(), {
            code: "TokenError",
            message: msg,
            name: "TokenError"
          });
        }
        function getAsyncToken() {
          self.token.get(function(err) {
            if (err) {
              var msg = "Could not load token from " + self.token.constructor.name;
              err = tokenError(msg, err);
            }
            finish(err);
          });
        }
        function getStaticToken() {
          var err = null;
          if (!self.token.token) {
            err = tokenError("Missing token");
          }
          finish(err);
        }
        if (self.token) {
          if (typeof self.token.get === "function") {
            getAsyncToken();
          } else {
            getStaticToken();
          }
        } else if (self.tokenProvider) {
          self.tokenProvider.resolve(function(err, token) {
            if (err) {
              err = tokenError("Could not load token from any providers", err);
            }
            self.token = token;
            finish(err);
          });
        } else {
          finish(tokenError("No token to load"));
        }
      },
      /**
       * @!group Loading and Setting Configuration Options
       */
      /**
       * @overload update(options, allowUnknownKeys = false)
       *   Updates the current configuration object with new options.
       *
       *   @example Update maxRetries property of a configuration object
       *     config.update({maxRetries: 10});
       *   @param [Object] options a map of option keys and values.
       *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
       *     the configuration object. Defaults to `false`.
       *   @see constructor
       */
      update: function update(options, allowUnknownKeys) {
        allowUnknownKeys = allowUnknownKeys || false;
        options = this.extractCredentials(options);
        AWS2.util.each.call(this, options, function(key, value) {
          if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS2.Service.hasService(key)) {
            this.set(key, value);
          }
        });
      },
      /**
       * Loads configuration data from a JSON file into this config object.
       * @note Loading configuration will reset all existing configuration
       *   on the object.
       * @!macro nobrowser
       * @param path [String] the path relative to your process's current
       *    working directory to load configuration from.
       * @return [AWS.Config] the same configuration object
       */
      loadFromPath: function loadFromPath(path) {
        this.clear();
        var options = JSON.parse(AWS2.util.readFileSync(path));
        var fileSystemCreds = new AWS2.FileSystemCredentials(path);
        var chain = new AWS2.CredentialProviderChain();
        chain.providers.unshift(fileSystemCreds);
        chain.resolve(function(err, creds) {
          if (err)
            throw err;
          else
            options.credentials = creds;
        });
        this.constructor(options);
        return this;
      },
      /**
       * Clears configuration data on this object
       *
       * @api private
       */
      clear: function clear() {
        AWS2.util.each.call(this, this.keys, function(key) {
          delete this[key];
        });
        this.set("credentials", void 0);
        this.set("credentialProvider", void 0);
      },
      /**
       * Sets a property on the configuration object, allowing for a
       * default value
       * @api private
       */
      set: function set(property, value, defaultValue) {
        if (value === void 0) {
          if (defaultValue === void 0) {
            defaultValue = this.keys[property];
          }
          if (typeof defaultValue === "function") {
            this[property] = defaultValue.call(this);
          } else {
            this[property] = defaultValue;
          }
        } else if (property === "httpOptions" && this[property]) {
          this[property] = AWS2.util.merge(this[property], value);
        } else {
          this[property] = value;
        }
      },
      /**
       * All of the keys with their default values.
       *
       * @constant
       * @api private
       */
      keys: {
        credentials: null,
        credentialProvider: null,
        region: null,
        logger: null,
        apiVersions: {},
        apiVersion: null,
        endpoint: void 0,
        httpOptions: {
          timeout: 12e4
        },
        maxRetries: void 0,
        maxRedirects: 10,
        paramValidation: true,
        sslEnabled: true,
        s3ForcePathStyle: false,
        s3BucketEndpoint: false,
        s3DisableBodySigning: true,
        s3UsEast1RegionalEndpoint: "legacy",
        s3UseArnRegion: void 0,
        computeChecksums: true,
        convertResponseTypes: true,
        correctClockSkew: false,
        customUserAgent: null,
        dynamoDbCrc32: true,
        systemClockOffset: 0,
        signatureVersion: null,
        signatureCache: true,
        retryDelayOptions: {},
        useAccelerateEndpoint: false,
        clientSideMonitoring: false,
        endpointDiscoveryEnabled: void 0,
        endpointCacheSize: 1e3,
        hostPrefixEnabled: true,
        stsRegionalEndpoints: "legacy",
        useFipsEndpoint: false,
        useDualstackEndpoint: false,
        token: null
      },
      /**
       * Extracts accessKeyId, secretAccessKey and sessionToken
       * from a configuration hash.
       *
       * @api private
       */
      extractCredentials: function extractCredentials(options) {
        if (options.accessKeyId && options.secretAccessKey) {
          options = AWS2.util.copy(options);
          options.credentials = new AWS2.Credentials(options);
        }
        return options;
      },
      /**
       * Sets the promise dependency the SDK will use wherever Promises are returned.
       * Passing `null` will force the SDK to use native Promises if they are available.
       * If native Promises are not available, passing `null` will have no effect.
       * @param [Constructor] dep A reference to a Promise constructor
       */
      setPromisesDependency: function setPromisesDependency(dep) {
        PromisesDependency = dep;
        if (dep === null && typeof Promise === "function") {
          PromisesDependency = Promise;
        }
        var constructors = [AWS2.Request, AWS2.Credentials, AWS2.CredentialProviderChain];
        if (AWS2.S3) {
          constructors.push(AWS2.S3);
          if (AWS2.S3.ManagedUpload) {
            constructors.push(AWS2.S3.ManagedUpload);
          }
        }
        AWS2.util.addPromises(constructors, PromisesDependency);
      },
      /**
       * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
       */
      getPromisesDependency: function getPromisesDependency() {
        return PromisesDependency;
      }
    });
    AWS2.config = new AWS2.Config();
  }
});

// node_modules/aws-sdk/lib/http.js
var require_http = __commonJS({
  "node_modules/aws-sdk/lib/http.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Endpoint = inherit({
      /**
       * @overload Endpoint(endpoint)
       *   Constructs a new endpoint given an endpoint URL. If the
       *   URL omits a protocol (http or https), the default protocol
       *   set in the global {AWS.config} will be used.
       *   @param endpoint [String] the URL to construct an endpoint from
       */
      constructor: function Endpoint(endpoint, config) {
        AWS2.util.hideProperties(this, ["slashes", "auth", "hash", "search", "query"]);
        if (typeof endpoint === "undefined" || endpoint === null) {
          throw new Error("Invalid endpoint: " + endpoint);
        } else if (typeof endpoint !== "string") {
          return AWS2.util.copy(endpoint);
        }
        if (!endpoint.match(/^http/)) {
          var useSSL = config && config.sslEnabled !== void 0 ? config.sslEnabled : AWS2.config.sslEnabled;
          endpoint = (useSSL ? "https" : "http") + "://" + endpoint;
        }
        AWS2.util.update(this, AWS2.util.urlParse(endpoint));
        if (this.port) {
          this.port = parseInt(this.port, 10);
        } else {
          this.port = this.protocol === "https:" ? 443 : 80;
        }
      }
    });
    AWS2.HttpRequest = inherit({
      /**
       * @api private
       */
      constructor: function HttpRequest(endpoint, region) {
        endpoint = new AWS2.Endpoint(endpoint);
        this.method = "POST";
        this.path = endpoint.path || "/";
        this.headers = {};
        this.body = "";
        this.endpoint = endpoint;
        this.region = region;
        this._userAgent = "";
        this.setUserAgent();
      },
      /**
       * @api private
       */
      setUserAgent: function setUserAgent() {
        this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS2.util.userAgent();
      },
      getUserAgentHeaderName: function getUserAgentHeaderName() {
        var prefix = AWS2.util.isBrowser() ? "X-Amz-" : "";
        return prefix + "User-Agent";
      },
      /**
       * @api private
       */
      appendToUserAgent: function appendToUserAgent(agentPartial) {
        if (typeof agentPartial === "string" && agentPartial) {
          this._userAgent += " " + agentPartial;
        }
        this.headers[this.getUserAgentHeaderName()] = this._userAgent;
      },
      /**
       * @api private
       */
      getUserAgent: function getUserAgent() {
        return this._userAgent;
      },
      /**
       * @return [String] the part of the {path} excluding the
       *   query string
       */
      pathname: function pathname() {
        return this.path.split("?", 1)[0];
      },
      /**
       * @return [String] the query string portion of the {path}
       */
      search: function search() {
        var query = this.path.split("?", 2)[1];
        if (query) {
          query = AWS2.util.queryStringParse(query);
          return AWS2.util.queryParamsToString(query);
        }
        return "";
      },
      /**
       * @api private
       * update httpRequest endpoint with endpoint string
       */
      updateEndpoint: function updateEndpoint(endpointStr) {
        var newEndpoint = new AWS2.Endpoint(endpointStr);
        this.endpoint = newEndpoint;
        this.path = newEndpoint.path || "/";
        if (this.headers["Host"]) {
          this.headers["Host"] = newEndpoint.host;
        }
      }
    });
    AWS2.HttpResponse = inherit({
      /**
       * @api private
       */
      constructor: function HttpResponse() {
        this.statusCode = void 0;
        this.headers = {};
        this.body = void 0;
        this.streaming = false;
        this.stream = null;
      },
      /**
       * Disables buffering on the HTTP response and returns the stream for reading.
       * @return [Stream, XMLHttpRequest, null] the underlying stream object.
       *   Use this object to directly read data off of the stream.
       * @note This object is only available after the {AWS.Request~httpHeaders}
       *   event has fired. This method must be called prior to
       *   {AWS.Request~httpData}.
       * @example Taking control of a stream
       *   request.on('httpHeaders', function(statusCode, headers) {
       *     if (statusCode < 300) {
       *       if (headers.etag === 'xyz') {
       *         // pipe the stream, disabling buffering
       *         var stream = this.response.httpResponse.createUnbufferedStream();
       *         stream.pipe(process.stdout);
       *       } else { // abort this request and set a better error message
       *         this.abort();
       *         this.response.error = new Error('Invalid ETag');
       *       }
       *     }
       *   }).send(console.log);
       */
      createUnbufferedStream: function createUnbufferedStream() {
        this.streaming = true;
        return this.stream;
      }
    });
    AWS2.HttpClient = inherit({});
    AWS2.HttpClient.getInstance = function getInstance() {
      if (this.singleton === void 0) {
        this.singleton = new this();
      }
      return this.singleton;
    };
  }
});

// node_modules/aws-sdk/lib/discover_endpoint.js
var require_discover_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/discover_endpoint.js"(exports, module) {
    var AWS2 = require_core();
    var util = require_util2();
    var endpointDiscoveryEnabledEnvs = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
    function getCacheKey(request) {
      var service = request.service;
      var api = service.api || {};
      var operations = api.operations;
      var identifiers = {};
      if (service.config.region) {
        identifiers.region = service.config.region;
      }
      if (api.serviceId) {
        identifiers.serviceId = api.serviceId;
      }
      if (service.config.credentials.accessKeyId) {
        identifiers.accessKeyId = service.config.credentials.accessKeyId;
      }
      return identifiers;
    }
    function marshallCustomIdentifiersHelper(result, params, shape) {
      if (!shape || params === void 0 || params === null)
        return;
      if (shape.type === "structure" && shape.required && shape.required.length > 0) {
        util.arrayEach(shape.required, function(name) {
          var memberShape = shape.members[name];
          if (memberShape.endpointDiscoveryId === true) {
            var locationName = memberShape.isLocationName ? memberShape.name : name;
            result[locationName] = String(params[name]);
          } else {
            marshallCustomIdentifiersHelper(result, params[name], memberShape);
          }
        });
      }
    }
    function marshallCustomIdentifiers(request, shape) {
      var identifiers = {};
      marshallCustomIdentifiersHelper(identifiers, request.params, shape);
      return identifiers;
    }
    function optionalDiscoverEndpoint(request) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var endpoints = AWS2.endpointCache.get(cacheKey);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        addApiVersionHeader(endpointRequest);
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        endpointRequest.removeListener("retry", AWS2.EventListeners.Core.RETRY_CHECK);
        AWS2.endpointCache.put(cacheKey, [{
          Address: "",
          CachePeriodInMinutes: 1
        }]);
        endpointRequest.send(function(err, data) {
          if (data && data.Endpoints) {
            AWS2.endpointCache.put(cacheKey, data.Endpoints);
          } else if (err) {
            AWS2.endpointCache.put(cacheKey, [{
              Address: "",
              CachePeriodInMinutes: 1
              //not to make more endpoint operation in next 1 minute
            }]);
          }
        });
      }
    }
    var requestQueue = {};
    function requiredDiscoverEndpoint(request, done) {
      var service = request.service;
      var api = service.api;
      var operationModel = api.operations ? api.operations[request.operation] : void 0;
      var inputShape = operationModel ? operationModel.input : void 0;
      var identifiers = marshallCustomIdentifiers(request, inputShape);
      var cacheKey = getCacheKey(request);
      if (Object.keys(identifiers).length > 0) {
        cacheKey = util.update(cacheKey, identifiers);
        if (operationModel)
          cacheKey.operation = operationModel.name;
      }
      var cacheKeyStr = AWS2.EndpointCache.getKeyString(cacheKey);
      var endpoints = AWS2.endpointCache.get(cacheKeyStr);
      if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
        if (!requestQueue[cacheKeyStr])
          requestQueue[cacheKeyStr] = [];
        requestQueue[cacheKeyStr].push({ request, callback: done });
        return;
      } else if (endpoints && endpoints.length > 0) {
        request.httpRequest.updateEndpoint(endpoints[0].Address);
        done();
      } else {
        var endpointRequest = service.makeRequest(api.endpointOperation, {
          Operation: operationModel.name,
          Identifiers: identifiers
        });
        endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
        addApiVersionHeader(endpointRequest);
        AWS2.endpointCache.put(cacheKeyStr, [{
          Address: "",
          CachePeriodInMinutes: 60
          //long-live cache
        }]);
        endpointRequest.send(function(err, data) {
          if (err) {
            request.response.error = util.error(err, { retryable: false });
            AWS2.endpointCache.remove(cacheKey);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.response.error = util.error(err, { retryable: false });
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          } else if (data) {
            AWS2.endpointCache.put(cacheKeyStr, data.Endpoints);
            request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
            if (requestQueue[cacheKeyStr]) {
              var pendingRequests = requestQueue[cacheKeyStr];
              util.arrayEach(pendingRequests, function(requestContext) {
                requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                requestContext.callback();
              });
              delete requestQueue[cacheKeyStr];
            }
          }
          done();
        });
      }
    }
    function addApiVersionHeader(endpointRequest) {
      var api = endpointRequest.service.api;
      var apiVersion = api.apiVersion;
      if (apiVersion && !endpointRequest.httpRequest.headers["x-amz-api-version"]) {
        endpointRequest.httpRequest.headers["x-amz-api-version"] = apiVersion;
      }
    }
    function invalidateCachedEndpoints(response) {
      var error = response.error;
      var httpResponse = response.httpResponse;
      if (error && (error.code === "InvalidEndpointException" || httpResponse.statusCode === 421)) {
        var request = response.request;
        var operations = request.service.api.operations || {};
        var inputShape = operations[request.operation] ? operations[request.operation].input : void 0;
        var identifiers = marshallCustomIdentifiers(request, inputShape);
        var cacheKey = getCacheKey(request);
        if (Object.keys(identifiers).length > 0) {
          cacheKey = util.update(cacheKey, identifiers);
          if (operations[request.operation])
            cacheKey.operation = operations[request.operation].name;
        }
        AWS2.endpointCache.remove(cacheKey);
      }
    }
    function hasCustomEndpoint(client) {
      if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
        throw util.error(new Error(), {
          code: "ConfigurationException",
          message: "Custom endpoint is supplied; endpointDiscoveryEnabled must not be true."
        });
      }
      ;
      var svcConfig = AWS2.config[client.serviceIdentifier] || {};
      return Boolean(AWS2.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);
    }
    function isFalsy(value) {
      return ["false", "0"].indexOf(value) >= 0;
    }
    function resolveEndpointDiscoveryConfig(request) {
      var service = request.service || {};
      if (service.config.endpointDiscoveryEnabled !== void 0) {
        return service.config.endpointDiscoveryEnabled;
      }
      if (util.isBrowser())
        return void 0;
      for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
        var env = endpointDiscoveryEnabledEnvs[i];
        if (Object.prototype.hasOwnProperty.call(process.env, env)) {
          if (process.env[env] === "" || process.env[env] === void 0) {
            throw util.error(new Error(), {
              code: "ConfigurationException",
              message: "environmental variable " + env + " cannot be set to nothing"
            });
          }
          return !isFalsy(process.env[env]);
        }
      }
      var configFile = {};
      try {
        configFile = AWS2.util.iniLoader ? AWS2.util.iniLoader.loadFrom({
          isConfig: true,
          filename: process.env[AWS2.util.sharedConfigFileEnv]
        }) : {};
      } catch (e) {
      }
      var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile] || {};
      if (Object.prototype.hasOwnProperty.call(sharedFileConfig, "endpoint_discovery_enabled")) {
        if (sharedFileConfig.endpoint_discovery_enabled === void 0) {
          throw util.error(new Error(), {
            code: "ConfigurationException",
            message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing"
          });
        }
        return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
      }
      return void 0;
    }
    function discoverEndpoint(request, done) {
      var service = request.service || {};
      if (hasCustomEndpoint(service) || request.isPresigned())
        return done();
      var operations = service.api.operations || {};
      var operationModel = operations[request.operation];
      var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : "NULL";
      var isEnabled = resolveEndpointDiscoveryConfig(request);
      var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
      if (isEnabled || hasRequiredEndpointDiscovery) {
        request.httpRequest.appendToUserAgent("endpoint-discovery");
      }
      switch (isEndpointDiscoveryRequired) {
        case "OPTIONAL":
          if (isEnabled || hasRequiredEndpointDiscovery) {
            optionalDiscoverEndpoint(request);
            request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          }
          done();
          break;
        case "REQUIRED":
          if (isEnabled === false) {
            request.response.error = util.error(new Error(), {
              code: "ConfigurationException",
              message: "Endpoint Discovery is disabled but " + service.api.className + "." + request.operation + "() requires it. Please check your configurations."
            });
            done();
            break;
          }
          request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
          requiredDiscoverEndpoint(request, done);
          break;
        case "NULL":
        default:
          done();
          break;
      }
    }
    module.exports = {
      discoverEndpoint,
      requiredDiscoverEndpoint,
      optionalDiscoverEndpoint,
      marshallCustomIdentifiers,
      getCacheKey,
      invalidateCachedEndpoint: invalidateCachedEndpoints
    };
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports, module) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty2.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty2.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    var forEach = function forEach2(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (toStr.call(list) === "[object Array]") {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
    module.exports = forEach;
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var gOPD = require_gopd();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var getPrototypeOf = Object.getPrototypeOf;
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache["$" + typedArray] = callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        // eslint-disable-next-line no-extra-parens
        /** @type {Record<`\$${TypedArrayName}`, Getter>} */
        /** @type {any} */
        cache,
        /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/aws-sdk/lib/event_listeners.js
var require_event_listeners = __commonJS({
  "node_modules/aws-sdk/lib/event_listeners.js"() {
    var AWS2 = require_core();
    var SequentialExecutor = require_sequential_executor();
    var DISCOVER_ENDPOINT = require_discover_endpoint().discoverEndpoint;
    AWS2.EventListeners = {
      /**
       * @!attribute VALIDATE_CREDENTIALS
       *   A request listener that validates whether the request is being
       *   sent with credentials.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating credentials
       *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
       *     request.removeListener('validate', listener);
       *   @readonly
       *   @return [Function]
       * @!attribute VALIDATE_REGION
       *   A request listener that validates whether the region is set
       *   for a request.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating region configuration
       *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
       *     request.removeListener('validate', listener);
       *   @readonly
       *   @return [Function]
       * @!attribute VALIDATE_PARAMETERS
       *   A request listener that validates input parameters in a request.
       *   Handles the {AWS.Request~validate 'validate' Request event}
       *   @example Sending a request without validating parameters
       *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
       *     request.removeListener('validate', listener);
       *   @example Disable parameter validation globally
       *     AWS.EventListeners.Core.removeListener('validate',
       *       AWS.EventListeners.Core.VALIDATE_REGION);
       *   @readonly
       *   @return [Function]
       * @!attribute SEND
       *   A request listener that initiates the HTTP connection for a
       *   request being sent. Handles the {AWS.Request~send 'send' Request event}
       *   @example Replacing the HTTP handler
       *     var listener = AWS.EventListeners.Core.SEND;
       *     request.removeListener('send', listener);
       *     request.on('send', function(response) {
       *       customHandler.send(response);
       *     });
       *   @return [Function]
       *   @readonly
       * @!attribute HTTP_DATA
       *   A request listener that reads data from the HTTP connection in order
       *   to build the response data.
       *   Handles the {AWS.Request~httpData 'httpData' Request event}.
       *   Remove this handler if you are overriding the 'httpData' event and
       *   do not want extra data processing and buffering overhead.
       *   @example Disabling default data processing
       *     var listener = AWS.EventListeners.Core.HTTP_DATA;
       *     request.removeListener('httpData', listener);
       *   @return [Function]
       *   @readonly
       */
      Core: {}
      /* doc hack */
    };
    function getOperationAuthtype(req) {
      if (!req.service.api.operations) {
        return "";
      }
      var operation = req.service.api.operations[req.operation];
      return operation ? operation.authtype : "";
    }
    function getIdentityType(req) {
      var service = req.service;
      if (service.config.signatureVersion) {
        return service.config.signatureVersion;
      }
      if (service.api.signatureVersion) {
        return service.api.signatureVersion;
      }
      return getOperationAuthtype(req);
    }
    AWS2.EventListeners = {
      Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
        addAsync(
          "VALIDATE_CREDENTIALS",
          "validate",
          function VALIDATE_CREDENTIALS(req, done) {
            if (!req.service.api.signatureVersion && !req.service.config.signatureVersion)
              return done();
            var identityType = getIdentityType(req);
            if (identityType === "bearer") {
              req.service.config.getToken(function(err) {
                if (err) {
                  req.response.error = AWS2.util.error(err, { code: "TokenError" });
                }
                done();
              });
              return;
            }
            req.service.config.getCredentials(function(err) {
              if (err) {
                req.response.error = AWS2.util.error(
                  err,
                  {
                    code: "CredentialsError",
                    message: "Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1"
                  }
                );
              }
              done();
            });
          }
        );
        add("VALIDATE_REGION", "validate", function VALIDATE_REGION(req) {
          if (!req.service.isGlobalEndpoint) {
            var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
            if (!req.service.config.region) {
              req.response.error = AWS2.util.error(
                new Error(),
                { code: "ConfigError", message: "Missing region in config" }
              );
            } else if (!dnsHostRegex.test(req.service.config.region)) {
              req.response.error = AWS2.util.error(
                new Error(),
                { code: "ConfigError", message: "Invalid region in config" }
              );
            }
          }
        });
        add("BUILD_IDEMPOTENCY_TOKENS", "validate", function BUILD_IDEMPOTENCY_TOKENS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var idempotentMembers = operation.idempotentMembers;
          if (!idempotentMembers.length) {
            return;
          }
          var params = AWS2.util.copy(req.params);
          for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
            if (!params[idempotentMembers[i]]) {
              params[idempotentMembers[i]] = AWS2.util.uuid.v4();
            }
          }
          req.params = params;
        });
        add("VALIDATE_PARAMETERS", "validate", function VALIDATE_PARAMETERS(req) {
          if (!req.service.api.operations) {
            return;
          }
          var rules = req.service.api.operations[req.operation].input;
          var validation = req.service.config.paramValidation;
          new AWS2.ParamValidator(validation).validate(rules, req.params);
        });
        add("COMPUTE_CHECKSUM", "afterBuild", function COMPUTE_CHECKSUM(req) {
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          if (!operation) {
            return;
          }
          var body = req.httpRequest.body;
          var isNonStreamingPayload = body && (AWS2.util.Buffer.isBuffer(body) || typeof body === "string");
          var headers = req.httpRequest.headers;
          if (operation.httpChecksumRequired && req.service.config.computeChecksums && isNonStreamingPayload && !headers["Content-MD5"]) {
            var md5 = AWS2.util.crypto.md5(body, "base64");
            headers["Content-MD5"] = md5;
          }
        });
        addAsync("COMPUTE_SHA256", "afterBuild", function COMPUTE_SHA256(req, done) {
          req.haltHandlersOnError();
          if (!req.service.api.operations) {
            return;
          }
          var operation = req.service.api.operations[req.operation];
          var authtype = operation ? operation.authtype : "";
          if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion)
            return done();
          if (req.service.getSignerClass(req) === AWS2.Signers.V4) {
            var body = req.httpRequest.body || "";
            if (authtype.indexOf("unsigned-body") >= 0) {
              req.httpRequest.headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
              return done();
            }
            AWS2.util.computeSha256(body, function(err, sha) {
              if (err) {
                done(err);
              } else {
                req.httpRequest.headers["X-Amz-Content-Sha256"] = sha;
                done();
              }
            });
          } else {
            done();
          }
        });
        add("SET_CONTENT_LENGTH", "afterBuild", function SET_CONTENT_LENGTH(req) {
          var authtype = getOperationAuthtype(req);
          var payloadMember = AWS2.util.getRequestPayloadShape(req);
          if (req.httpRequest.headers["Content-Length"] === void 0) {
            try {
              var length = AWS2.util.string.byteLength(req.httpRequest.body);
              req.httpRequest.headers["Content-Length"] = length;
            } catch (err) {
              if (payloadMember && payloadMember.isStreaming) {
                if (payloadMember.requiresLength) {
                  throw err;
                } else if (authtype.indexOf("unsigned-body") >= 0) {
                  req.httpRequest.headers["Transfer-Encoding"] = "chunked";
                  return;
                } else {
                  throw err;
                }
              }
              throw err;
            }
          }
        });
        add("SET_HTTP_HOST", "afterBuild", function SET_HTTP_HOST(req) {
          req.httpRequest.headers["Host"] = req.httpRequest.endpoint.host;
        });
        add("SET_TRACE_ID", "afterBuild", function SET_TRACE_ID(req) {
          var traceIdHeaderName = "X-Amzn-Trace-Id";
          if (AWS2.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
            var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
            var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
            var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
            var traceId = process.env[ENV_TRACE_ID];
            if (typeof functionName === "string" && functionName.length > 0 && typeof traceId === "string" && traceId.length > 0) {
              req.httpRequest.headers[traceIdHeaderName] = traceId;
            }
          }
        });
        add("RESTART", "restart", function RESTART() {
          var err = this.response.error;
          if (!err || !err.retryable)
            return;
          this.httpRequest = new AWS2.HttpRequest(
            this.service.endpoint,
            this.service.region
          );
          if (this.response.retryCount < this.service.config.maxRetries) {
            this.response.retryCount++;
          } else {
            this.response.error = null;
          }
        });
        var addToHead = true;
        addAsync("DISCOVER_ENDPOINT", "sign", DISCOVER_ENDPOINT, addToHead);
        addAsync("SIGN", "sign", function SIGN(req, done) {
          var service = req.service;
          var identityType = getIdentityType(req);
          if (!identityType || identityType.length === 0)
            return done();
          if (identityType === "bearer") {
            service.config.getToken(function(err, token) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var SignerClass = service.getSignerClass(req);
                var signer = new SignerClass(req.httpRequest);
                signer.addAuthorization(token);
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          } else {
            service.config.getCredentials(function(err, credentials) {
              if (err) {
                req.response.error = err;
                return done();
              }
              try {
                var date = service.getSkewCorrectedDate();
                var SignerClass = service.getSignerClass(req);
                var operations = req.service.api.operations || {};
                var operation = operations[req.operation];
                var signer = new SignerClass(
                  req.httpRequest,
                  service.getSigningName(req),
                  {
                    signatureCache: service.config.signatureCache,
                    operation,
                    signatureVersion: service.api.signatureVersion
                  }
                );
                signer.setServiceClientId(service._clientId);
                delete req.httpRequest.headers["Authorization"];
                delete req.httpRequest.headers["Date"];
                delete req.httpRequest.headers["X-Amz-Date"];
                signer.addAuthorization(credentials, date);
                req.signedAt = date;
              } catch (e) {
                req.response.error = e;
              }
              done();
            });
          }
        });
        add("VALIDATE_RESPONSE", "validateResponse", function VALIDATE_RESPONSE(resp) {
          if (this.service.successfulResponse(resp, this)) {
            resp.data = {};
            resp.error = null;
          } else {
            resp.data = null;
            resp.error = AWS2.util.error(
              new Error(),
              { code: "UnknownError", message: "An unknown error occurred." }
            );
          }
        });
        add("ERROR", "error", function ERROR(err, resp) {
          var awsQueryCompatible = resp.request.service.api.awsQueryCompatible;
          if (awsQueryCompatible) {
            var headers = resp.httpResponse.headers;
            var queryErrorCode = headers ? headers["x-amzn-query-error"] : void 0;
            if (queryErrorCode && queryErrorCode.includes(";")) {
              resp.error.code = queryErrorCode.split(";")[0];
            }
          }
        }, true);
        addAsync("SEND", "send", function SEND(resp, done) {
          resp.httpResponse._abortCallback = done;
          resp.error = null;
          resp.data = null;
          function callback(httpResp) {
            resp.httpResponse.stream = httpResp;
            var stream = resp.request.httpRequest.stream;
            var service = resp.request.service;
            var api = service.api;
            var operationName = resp.request.operation;
            var operation = api.operations[operationName] || {};
            httpResp.on("headers", function onHeaders(statusCode, headers, statusMessage) {
              resp.request.emit(
                "httpHeaders",
                [statusCode, headers, resp, statusMessage]
              );
              if (!resp.httpResponse.streaming) {
                if (AWS2.HttpClient.streamsApiVersion === 2) {
                  if (operation.hasEventOutput && service.successfulResponse(resp)) {
                    resp.request.emit("httpDone");
                    done();
                    return;
                  }
                  httpResp.on("readable", function onReadable() {
                    var data = httpResp.read();
                    if (data !== null) {
                      resp.request.emit("httpData", [data, resp]);
                    }
                  });
                } else {
                  httpResp.on("data", function onData(data) {
                    resp.request.emit("httpData", [data, resp]);
                  });
                }
              }
            });
            httpResp.on("end", function onEnd() {
              if (!stream || !stream.didCallback) {
                if (AWS2.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
                  return;
                }
                resp.request.emit("httpDone");
                done();
              }
            });
          }
          function progress(httpResp) {
            httpResp.on("sendProgress", function onSendProgress(value) {
              resp.request.emit("httpUploadProgress", [value, resp]);
            });
            httpResp.on("receiveProgress", function onReceiveProgress(value) {
              resp.request.emit("httpDownloadProgress", [value, resp]);
            });
          }
          function error(err) {
            if (err.code !== "RequestAbortedError") {
              var errCode = err.code === "TimeoutError" ? err.code : "NetworkingError";
              err = AWS2.util.error(err, {
                code: errCode,
                region: resp.request.httpRequest.region,
                hostname: resp.request.httpRequest.endpoint.hostname,
                retryable: true
              });
            }
            resp.error = err;
            resp.request.emit("httpError", [resp.error, resp], function() {
              done();
            });
          }
          function executeSend() {
            var http = AWS2.HttpClient.getInstance();
            var httpOptions = resp.request.service.config.httpOptions || {};
            try {
              var stream = http.handleRequest(
                resp.request.httpRequest,
                httpOptions,
                callback,
                error
              );
              progress(stream);
            } catch (err) {
              error(err);
            }
          }
          var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3;
          if (timeDiff >= 60 * 10) {
            this.emit("sign", [this], function(err) {
              if (err)
                done(err);
              else
                executeSend();
            });
          } else {
            executeSend();
          }
        });
        add(
          "HTTP_HEADERS",
          "httpHeaders",
          function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
            resp.httpResponse.statusCode = statusCode;
            resp.httpResponse.statusMessage = statusMessage;
            resp.httpResponse.headers = headers;
            resp.httpResponse.body = AWS2.util.buffer.toBuffer("");
            resp.httpResponse.buffers = [];
            resp.httpResponse.numBytes = 0;
            var dateHeader = headers.date || headers.Date;
            var service = resp.request.service;
            if (dateHeader) {
              var serverTime = Date.parse(dateHeader);
              if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
                service.applyClockOffset(serverTime);
              }
            }
          }
        );
        add("HTTP_DATA", "httpData", function HTTP_DATA(chunk, resp) {
          if (chunk) {
            if (AWS2.util.isNode()) {
              resp.httpResponse.numBytes += chunk.length;
              var total = resp.httpResponse.headers["content-length"];
              var progress = { loaded: resp.httpResponse.numBytes, total };
              resp.request.emit("httpDownloadProgress", [progress, resp]);
            }
            resp.httpResponse.buffers.push(AWS2.util.buffer.toBuffer(chunk));
          }
        });
        add("HTTP_DONE", "httpDone", function HTTP_DONE(resp) {
          if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
            var body = AWS2.util.buffer.concat(resp.httpResponse.buffers);
            resp.httpResponse.body = body;
          }
          delete resp.httpResponse.numBytes;
          delete resp.httpResponse.buffers;
        });
        add("FINALIZE_ERROR", "retry", function FINALIZE_ERROR(resp) {
          if (resp.httpResponse.statusCode) {
            resp.error.statusCode = resp.httpResponse.statusCode;
            if (resp.error.retryable === void 0) {
              resp.error.retryable = this.service.retryableError(resp.error, this);
            }
          }
        });
        add("INVALIDATE_CREDENTIALS", "retry", function INVALIDATE_CREDENTIALS(resp) {
          if (!resp.error)
            return;
          switch (resp.error.code) {
            case "RequestExpired":
            case "ExpiredTokenException":
            case "ExpiredToken":
              resp.error.retryable = true;
              resp.request.service.config.credentials.expired = true;
          }
        });
        add("EXPIRED_SIGNATURE", "retry", function EXPIRED_SIGNATURE(resp) {
          var err = resp.error;
          if (!err)
            return;
          if (typeof err.code === "string" && typeof err.message === "string") {
            if (err.code.match(/Signature/) && err.message.match(/expired/)) {
              resp.error.retryable = true;
            }
          }
        });
        add("CLOCK_SKEWED", "retry", function CLOCK_SKEWED(resp) {
          if (!resp.error)
            return;
          if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
            resp.error.retryable = true;
          }
        });
        add("REDIRECT", "retry", function REDIRECT(resp) {
          if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers["location"]) {
            this.httpRequest.endpoint = new AWS2.Endpoint(resp.httpResponse.headers["location"]);
            this.httpRequest.headers["Host"] = this.httpRequest.endpoint.host;
            this.httpRequest.path = this.httpRequest.endpoint.path;
            resp.error.redirect = true;
            resp.error.retryable = true;
          }
        });
        add("RETRY_CHECK", "retry", function RETRY_CHECK(resp) {
          if (resp.error) {
            if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.error.retryDelay = 0;
            } else if (resp.retryCount < resp.maxRetries) {
              resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
            }
          }
        });
        addAsync("RESET_RETRY_STATE", "afterRetry", function RESET_RETRY_STATE(resp, done) {
          var delay, willRetry = false;
          if (resp.error) {
            delay = resp.error.retryDelay || 0;
            if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
              resp.retryCount++;
              willRetry = true;
            } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
              resp.redirectCount++;
              willRetry = true;
            }
          }
          if (willRetry && delay >= 0) {
            resp.error = null;
            setTimeout(done, delay);
          } else {
            done();
          }
        });
      }),
      CorePost: new SequentialExecutor().addNamedListeners(function(add) {
        add("EXTRACT_REQUEST_ID", "extractData", AWS2.util.extractRequestId);
        add("EXTRACT_REQUEST_ID", "extractError", AWS2.util.extractRequestId);
        add("ENOTFOUND_ERROR", "httpError", function ENOTFOUND_ERROR(err) {
          function isDNSError(err2) {
            return err2.errno === "ENOTFOUND" || typeof err2.errno === "number" && typeof AWS2.util.getSystemErrorName === "function" && ["EAI_NONAME", "EAI_NODATA"].indexOf(AWS2.util.getSystemErrorName(err2.errno) >= 0);
          }
          if (err.code === "NetworkingError" && isDNSError(err)) {
            var message = "Inaccessible host: `" + err.hostname + "' at port `" + err.port + "'. This service may not be available in the `" + err.region + "' region.";
            this.response.error = AWS2.util.error(new Error(message), {
              code: "UnknownEndpoint",
              region: err.region,
              hostname: err.hostname,
              retryable: true,
              originalError: err
            });
          }
        });
      }),
      Logger: new SequentialExecutor().addNamedListeners(function(add) {
        add("LOG_REQUEST", "complete", function LOG_REQUEST(resp) {
          var req = resp.request;
          var logger = req.service.config.logger;
          if (!logger)
            return;
          function filterSensitiveLog(inputShape, shape) {
            if (!shape) {
              return shape;
            }
            if (inputShape.isSensitive) {
              return "***SensitiveInformation***";
            }
            switch (inputShape.type) {
              case "structure":
                var struct = {};
                AWS2.util.each(shape, function(subShapeName, subShape) {
                  if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                    struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                  } else {
                    struct[subShapeName] = subShape;
                  }
                });
                return struct;
              case "list":
                var list = [];
                AWS2.util.arrayEach(shape, function(subShape, index) {
                  list.push(filterSensitiveLog(inputShape.member, subShape));
                });
                return list;
              case "map":
                var map = {};
                AWS2.util.each(shape, function(key, value) {
                  map[key] = filterSensitiveLog(inputShape.value, value);
                });
                return map;
              default:
                return shape;
            }
          }
          function buildMessage() {
            var time = resp.request.service.getSkewCorrectedDate().getTime();
            var delta = (time - req.startTime.getTime()) / 1e3;
            var ansi = logger.isTTY ? true : false;
            var status = resp.httpResponse.statusCode;
            var censoredParams = req.params;
            if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {
              var inputShape = req.service.api.operations[req.operation].input;
              censoredParams = filterSensitiveLog(inputShape, req.params);
            }
            var params = require_util().inspect(censoredParams, true, null);
            var message = "";
            if (ansi)
              message += "\x1B[33m";
            message += "[AWS " + req.service.serviceIdentifier + " " + status;
            message += " " + delta.toString() + "s " + resp.retryCount + " retries]";
            if (ansi)
              message += "\x1B[0;1m";
            message += " " + AWS2.util.string.lowerFirst(req.operation);
            message += "(" + params + ")";
            if (ansi)
              message += "\x1B[0m";
            return message;
          }
          var line = buildMessage();
          if (typeof logger.log === "function") {
            logger.log(line);
          } else if (typeof logger.write === "function") {
            logger.write(line + "\n");
          }
        });
      }),
      Json: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Rest: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      RestJson: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_json();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
        add("UNSET_CONTENT_LENGTH", "afterBuild", svc.unsetContentLength);
      }),
      RestXml: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_rest_xml();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      }),
      Query: new SequentialExecutor().addNamedListeners(function(add) {
        var svc = require_query();
        add("BUILD", "build", svc.buildRequest);
        add("EXTRACT_DATA", "extractData", svc.extractData);
        add("EXTRACT_ERROR", "extractError", svc.extractError);
      })
    };
  }
});

// node_modules/aws-sdk/lib/state_machine.js
var require_state_machine = __commonJS({
  "node_modules/aws-sdk/lib/state_machine.js"(exports, module) {
    function AcceptorStateMachine(states, state) {
      this.currentState = state || null;
      this.states = states || {};
    }
    AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
      if (typeof finalState === "function") {
        inputError = bindObject;
        bindObject = done;
        done = finalState;
        finalState = null;
      }
      var self = this;
      var state = self.states[self.currentState];
      state.fn.call(bindObject || self, inputError, function(err) {
        if (err) {
          if (state.fail)
            self.currentState = state.fail;
          else
            return done ? done.call(bindObject, err) : null;
        } else {
          if (state.accept)
            self.currentState = state.accept;
          else
            return done ? done.call(bindObject) : null;
        }
        if (self.currentState === finalState) {
          return done ? done.call(bindObject, err) : null;
        }
        self.runTo(finalState, done, bindObject, err);
      });
    };
    AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
      if (typeof acceptState === "function") {
        fn = acceptState;
        acceptState = null;
        failState = null;
      } else if (typeof failState === "function") {
        fn = failState;
        failState = null;
      }
      if (!this.currentState)
        this.currentState = name;
      this.states[name] = { accept: acceptState, fail: failState, fn };
      return this;
    };
    module.exports = AcceptorStateMachine;
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports) {
    (function(exports2) {
      "use strict";
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i = 0; i < first.length; i++) {
            if (strictDeepEqual(first[i], second[i]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }
        return values;
      }
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TYPE_NAME_TABLE = {
        0: "number",
        1: "any",
        2: "string",
        3: "array",
        4: "object",
        5: "boolean",
        6: "expression",
        7: "null",
        8: "Array<number>",
        9: "Array<string>"
      };
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
      }
      function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
      }
      function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
      }
      function Lexer() {
      }
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({ type: TOK_AND, value: "&&", start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: "&", start });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({ type: TOK_OR, value: "||", start });
              } else {
                tokens.push({ type: TOK_PIPE, value: "|", start });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return { type: TOK_FILTER, value: "[?", start };
          } else if (stream[this._current] === "]") {
            this._current++;
            return { type: TOK_FLATTEN, value: "[]", start };
          } else {
            return { type: TOK_LBRACKET, value: "[", start };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_NE, value: "!=", start };
            } else {
              return { type: TOK_NOT, value: "!", start };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_LTE, value: "<=", start };
            } else {
              return { type: TOK_LT, value: "<", start };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_GTE, value: ">=", start };
            } else {
              return { type: TOK_GT, value: ">", start };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_EQ, value: "==", start };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            literal = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser() {
      }
      Parser.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t = this._lookaheadToken(0);
            var error = new Error(
              "Unexpected token type: " + t.type + ", value: " + t.value
            );
            error.name = "ParserError";
            throw error;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: "", start: expression.length });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return { type: "Literal", value: token.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: "Field", name: token.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: "Field", name: token.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              }
              return node;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: "NotExpression", children: [right] };
            case TOK_STAR:
              left = { type: "Identity" };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: "ValueProjection", children: [left, right] };
            case TOK_FILTER:
              return this.led(token.type, { type: "Identity" });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: "Identity" }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{ type: "Identity" }, right]
                };
              }
              return this._parseMultiselectList();
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: "ExpressionReference", children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: "Subexpression", children: [left, right] };
              }
              this._advance();
              right = this._parseProjectionRHS(rbp);
              return { type: "ValueProjection", children: [left, right] };
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: "OrExpression", children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: "AndExpression", children: [left, right] };
            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: "Function", name, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: "FilterProjection", children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              }
              this._match(TOK_STAR);
              this._match(TOK_RBRACKET);
              right = this._parseProjectionRHS(bindingPower.Star);
              return { type: "Projection", children: [left, right] };
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Expected " + tokenType + ", got: " + t.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function(token) {
          var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = { type: "IndexExpression", children: [left, right] };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t = this._lookahead(0);
              var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
              error.name = "Parsererror";
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: "Comparator", name: comparator, children: [left, right] };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: "Identity" };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
            error.name = "ParserError";
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: "MultiSelectList", children: expressions };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: "KeyValuePair", name: keyName, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: "MultiSelectHash", children: pairs };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value !== null && isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              }
              return null;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === void 0) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                for (i = start; i < stop; i += step) {
                  result.push(value[i]);
                }
              } else {
                for (i = start; i > stop; i += step) {
                  result.push(value[i]);
                }
              }
              return result;
            case "Projection":
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          // name: [function, <signature>]
          // The <signature> can be:
          //
          // {
          //   args: [[type1, type2], [type1, type2]],
          //   variadic: true|false
          // }
          //
          // Each arg in the arg list is a list of valid types
          // (if the function is overloaded and supports multiple
          // types.  If the type is "any" then no type checking
          // occurs on the argument.  Variadic is optional
          // and if not provided is assumed to be false.
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [
              { types: [TYPE_STRING, TYPE_ARRAY] },
              { types: [TYPE_ANY] }
            ]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [
              { types: [TYPE_STRING] },
              { types: [TYPE_ARRAY_STRING] }
            ]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
          },
          "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }]
          }
        };
      }
      Runtime.prototype = {
        callFunction: function(name, resolvedArgs) {
          var functionEntry = this.functionTable[name];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name + "()");
          }
          this._validateArgs(name, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              var expected = currentSpec.map(function(typeIdentifier) {
                return TYPE_NAME_TABLE[typeIdentifier];
              }).join(",");
              throw new Error("TypeError: " + name + "() expected argument " + (i + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i = 0; i < argValue.length; i++) {
                if (!this._typeMatches(
                  this._getTypeName(argValue[i]),
                  subtype,
                  argValue[i]
                )) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
          }
          return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i = 0; i < elements.length; i++) {
            mapped.push(interpreter.visit(exprefNode, elements[i]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i = 0; i < resolvedArgs.length; i++) {
            var current = resolvedArgs[i];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i = 0; i < listToSum.length; i++) {
            sum += listToSum[i];
          }
          return sum;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];
          for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }
          return values;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
              return resolvedArgs[i];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0])
          );
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i = 0; i < sortedArray.length; i++) {
            decorated.push([i, sortedArray[i]]);
          }
          decorated.sort(function(a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA)
              );
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB)
              );
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function(x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search(data, expression) {
        var parser = new Parser();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }
      exports2.tokenize = tokenize;
      exports2.compile = compile;
      exports2.search = search;
      exports2.strictDeepEqual = strictDeepEqual;
    })(typeof exports === "undefined" ? exports.jmespath = {} : exports);
  }
});

// node_modules/aws-sdk/lib/request.js
var require_request = __commonJS({
  "node_modules/aws-sdk/lib/request.js"() {
    var AWS2 = require_core();
    var AcceptorStateMachine = require_state_machine();
    var inherit = AWS2.util.inherit;
    var domain = AWS2.util.domain;
    var jmespath = require_jmespath();
    var hardErrorStates = { success: 1, error: 1, complete: 1 };
    function isTerminalState(machine) {
      return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
    }
    var fsm = new AcceptorStateMachine();
    fsm.setupStates = function() {
      var transition = function(_, done) {
        var self = this;
        self._haltHandlersOnError = false;
        self.emit(self._asm.currentState, function(err) {
          if (err) {
            if (isTerminalState(self)) {
              if (domain && self.domain instanceof domain.Domain) {
                err.domainEmitter = self;
                err.domain = self.domain;
                err.domainThrown = false;
                self.domain.emit("error", err);
              } else {
                throw err;
              }
            } else {
              self.response.error = err;
              done(err);
            }
          } else {
            done(self.response.error);
          }
        });
      };
      this.addState("validate", "build", "error", transition);
      this.addState("build", "afterBuild", "restart", transition);
      this.addState("afterBuild", "sign", "restart", transition);
      this.addState("sign", "send", "retry", transition);
      this.addState("retry", "afterRetry", "afterRetry", transition);
      this.addState("afterRetry", "sign", "error", transition);
      this.addState("send", "validateResponse", "retry", transition);
      this.addState("validateResponse", "extractData", "extractError", transition);
      this.addState("extractError", "extractData", "retry", transition);
      this.addState("extractData", "success", "retry", transition);
      this.addState("restart", "build", "error", transition);
      this.addState("success", "complete", "complete", transition);
      this.addState("error", "complete", "complete", transition);
      this.addState("complete", null, null, transition);
    };
    fsm.setupStates();
    AWS2.Request = inherit({
      /**
       * Creates a request for an operation on a given service with
       * a set of input parameters.
       *
       * @param service [AWS.Service] the service to perform the operation on
       * @param operation [String] the operation to perform on the service
       * @param params [Object] parameters to send to the operation.
       *   See the operation's documentation for the format of the
       *   parameters.
       */
      constructor: function Request(service, operation, params) {
        var endpoint = service.endpoint;
        var region = service.config.region;
        var customUserAgent = service.config.customUserAgent;
        if (service.signingRegion) {
          region = service.signingRegion;
        } else if (service.isGlobalEndpoint) {
          region = "us-east-1";
        }
        this.domain = domain && domain.active;
        this.service = service;
        this.operation = operation;
        this.params = params || {};
        this.httpRequest = new AWS2.HttpRequest(endpoint, region);
        this.httpRequest.appendToUserAgent(customUserAgent);
        this.startTime = service.getSkewCorrectedDate();
        this.response = new AWS2.Response(this);
        this._asm = new AcceptorStateMachine(fsm.states, "validate");
        this._haltHandlersOnError = false;
        AWS2.SequentialExecutor.call(this);
        this.emit = this.emitEvent;
      },
      /**
       * @!group Sending a Request
       */
      /**
       * @overload send(callback = null)
       *   Sends the request object.
       *
       *   @callback callback function(err, data)
       *     If a callback is supplied, it is called when a response is returned
       *     from the service.
       *     @context [AWS.Request] the request object being sent.
       *     @param err [Error] the error object returned from the request.
       *       Set to `null` if the request is successful.
       *     @param data [Object] the de-serialized data returned from
       *       the request. Set to `null` if a request error occurs.
       *   @example Sending a request with a callback
       *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     request.send(function(err, data) { console.log(err, data); });
       *   @example Sending a request with no callback (using event handlers)
       *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     request.on('complete', function(response) { ... }); // register a callback
       *     request.send();
       */
      send: function send(callback) {
        if (callback) {
          this.httpRequest.appendToUserAgent("callback");
          this.on("complete", function(resp) {
            callback.call(resp, resp.error, resp.data);
          });
        }
        this.runTo();
        return this.response;
      },
      /**
       * @!method  promise()
       *   Sends the request and returns a 'thenable' promise.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(data)
       *     Called if the promise is fulfilled.
       *     @param data [Object] the de-serialized data returned from the request.
       *   @callback rejectedCallback function(error)
       *     Called if the promise is rejected.
       *     @param error [Error] the error object returned from the request.
       *   @return [Promise] A promise that represents the state of the request.
       *   @example Sending a request using promises.
       *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
       *     var result = request.promise();
       *     result.then(function(data) { ... }, function(error) { ... });
       */
      /**
       * @api private
       */
      build: function build(callback) {
        return this.runTo("send", callback);
      },
      /**
       * @api private
       */
      runTo: function runTo(state, done) {
        this._asm.runTo(state, done, this);
        return this;
      },
      /**
       * Aborts a request, emitting the error and complete events.
       *
       * @!macro nobrowser
       * @example Aborting a request after sending
       *   var params = {
       *     Bucket: 'bucket', Key: 'key',
       *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
       *   };
       *   var request = s3.putObject(params);
       *   request.send(function (err, data) {
       *     if (err) console.log("Error:", err.code, err.message);
       *     else console.log(data);
       *   });
       *
       *   // abort request in 1 second
       *   setTimeout(request.abort.bind(request), 1000);
       *
       *   // prints "Error: RequestAbortedError Request aborted by user"
       * @return [AWS.Request] the same request object, for chaining.
       * @since v1.4.0
       */
      abort: function abort() {
        this.removeAllListeners("validateResponse");
        this.removeAllListeners("extractError");
        this.on("validateResponse", function addAbortedError(resp) {
          resp.error = AWS2.util.error(new Error("Request aborted by user"), {
            code: "RequestAbortedError",
            retryable: false
          });
        });
        if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
          this.httpRequest.stream.abort();
          if (this.httpRequest._abortCallback) {
            this.httpRequest._abortCallback();
          } else {
            this.removeAllListeners("send");
          }
        }
        return this;
      },
      /**
       * Iterates over each page of results given a pageable request, calling
       * the provided callback with each page of data. After all pages have been
       * retrieved, the callback is called with `null` data.
       *
       * @note This operation can generate multiple requests to a service.
       * @example Iterating over multiple pages of objects in an S3 bucket
       *   var pages = 1;
       *   s3.listObjects().eachPage(function(err, data) {
       *     if (err) return;
       *     console.log("Page", pages++);
       *     console.log(data);
       *   });
       * @example Iterating over multiple pages with an asynchronous callback
       *   s3.listObjects(params).eachPage(function(err, data, done) {
       *     doSomethingAsyncAndOrExpensive(function() {
       *       // The next page of results isn't fetched until done is called
       *       done();
       *     });
       *   });
       * @callback callback function(err, data, [doneCallback])
       *   Called with each page of resulting data from the request. If the
       *   optional `doneCallback` is provided in the function, it must be called
       *   when the callback is complete.
       *
       *   @param err [Error] an error object, if an error occurred.
       *   @param data [Object] a single page of response data. If there is no
       *     more data, this object will be `null`.
       *   @param doneCallback [Function] an optional done callback. If this
       *     argument is defined in the function declaration, it should be called
       *     when the next page is ready to be retrieved. This is useful for
       *     controlling serial pagination across asynchronous operations.
       *   @return [Boolean] if the callback returns `false`, pagination will
       *     stop.
       *
       * @see AWS.Request.eachItem
       * @see AWS.Response.nextPage
       * @since v1.4.0
       */
      eachPage: function eachPage(callback) {
        callback = AWS2.util.fn.makeAsync(callback, 3);
        function wrappedCallback(response) {
          callback.call(response, response.error, response.data, function(result) {
            if (result === false)
              return;
            if (response.hasNextPage()) {
              response.nextPage().on("complete", wrappedCallback).send();
            } else {
              callback.call(response, null, null, AWS2.util.fn.noop);
            }
          });
        }
        this.on("complete", wrappedCallback).send();
      },
      /**
       * Enumerates over individual items of a request, paging the responses if
       * necessary.
       *
       * @api experimental
       * @since v1.4.0
       */
      eachItem: function eachItem(callback) {
        var self = this;
        function wrappedCallback(err, data) {
          if (err)
            return callback(err, null);
          if (data === null)
            return callback(null, null);
          var config = self.service.paginationConfig(self.operation);
          var resultKey = config.resultKey;
          if (Array.isArray(resultKey))
            resultKey = resultKey[0];
          var items = jmespath.search(data, resultKey);
          var continueIteration = true;
          AWS2.util.arrayEach(items, function(item) {
            continueIteration = callback(null, item);
            if (continueIteration === false) {
              return AWS2.util.abort;
            }
          });
          return continueIteration;
        }
        this.eachPage(wrappedCallback);
      },
      /**
       * @return [Boolean] whether the operation can return multiple pages of
       *   response data.
       * @see AWS.Response.eachPage
       * @since v1.4.0
       */
      isPageable: function isPageable() {
        return this.service.paginationConfig(this.operation) ? true : false;
      },
      /**
       * Sends the request and converts the request object into a readable stream
       * that can be read from or piped into a writable stream.
       *
       * @note The data read from a readable stream contains only
       *   the raw HTTP body contents.
       * @example Manually reading from a stream
       *   request.createReadStream().on('data', function(data) {
       *     console.log("Got data:", data.toString());
       *   });
       * @example Piping a request body into a file
       *   var out = fs.createWriteStream('/path/to/outfile.jpg');
       *   s3.service.getObject(params).createReadStream().pipe(out);
       * @return [Stream] the readable stream object that can be piped
       *   or read from (by registering 'data' event listeners).
       * @!macro nobrowser
       */
      createReadStream: function createReadStream() {
        var streams = AWS2.util.stream;
        var req = this;
        var stream = null;
        if (AWS2.HttpClient.streamsApiVersion === 2) {
          stream = new streams.PassThrough();
          process.nextTick(function() {
            req.send();
          });
        } else {
          stream = new streams.Stream();
          stream.readable = true;
          stream.sent = false;
          stream.on("newListener", function(event) {
            if (!stream.sent && event === "data") {
              stream.sent = true;
              process.nextTick(function() {
                req.send();
              });
            }
          });
        }
        this.on("error", function(err) {
          stream.emit("error", err);
        });
        this.on("httpHeaders", function streamHeaders(statusCode, headers, resp) {
          if (statusCode < 300) {
            req.removeListener("httpData", AWS2.EventListeners.Core.HTTP_DATA);
            req.removeListener("httpError", AWS2.EventListeners.Core.HTTP_ERROR);
            req.on("httpError", function streamHttpError(error) {
              resp.error = error;
              resp.error.retryable = false;
            });
            var shouldCheckContentLength = false;
            var expectedLen;
            if (req.httpRequest.method !== "HEAD") {
              expectedLen = parseInt(headers["content-length"], 10);
            }
            if (expectedLen !== void 0 && !isNaN(expectedLen) && expectedLen >= 0) {
              shouldCheckContentLength = true;
              var receivedLen = 0;
            }
            var checkContentLengthAndEmit = function checkContentLengthAndEmit2() {
              if (shouldCheckContentLength && receivedLen !== expectedLen) {
                stream.emit("error", AWS2.util.error(
                  new Error("Stream content length mismatch. Received " + receivedLen + " of " + expectedLen + " bytes."),
                  { code: "StreamContentLengthMismatch" }
                ));
              } else if (AWS2.HttpClient.streamsApiVersion === 2) {
                stream.end();
              } else {
                stream.emit("end");
              }
            };
            var httpStream = resp.httpResponse.createUnbufferedStream();
            if (AWS2.HttpClient.streamsApiVersion === 2) {
              if (shouldCheckContentLength) {
                var lengthAccumulator = new streams.PassThrough();
                lengthAccumulator._write = function(chunk) {
                  if (chunk && chunk.length) {
                    receivedLen += chunk.length;
                  }
                  return streams.PassThrough.prototype._write.apply(this, arguments);
                };
                lengthAccumulator.on("end", checkContentLengthAndEmit);
                stream.on("error", function(err) {
                  shouldCheckContentLength = false;
                  httpStream.unpipe(lengthAccumulator);
                  lengthAccumulator.emit("end");
                  lengthAccumulator.end();
                });
                httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
              } else {
                httpStream.pipe(stream);
              }
            } else {
              if (shouldCheckContentLength) {
                httpStream.on("data", function(arg) {
                  if (arg && arg.length) {
                    receivedLen += arg.length;
                  }
                });
              }
              httpStream.on("data", function(arg) {
                stream.emit("data", arg);
              });
              httpStream.on("end", checkContentLengthAndEmit);
            }
            httpStream.on("error", function(err) {
              shouldCheckContentLength = false;
              stream.emit("error", err);
            });
          }
        });
        return stream;
      },
      /**
       * @param [Array,Response] args This should be the response object,
       *   or an array of args to send to the event.
       * @api private
       */
      emitEvent: function emit(eventName, args, done) {
        if (typeof args === "function") {
          done = args;
          args = null;
        }
        if (!done)
          done = function() {
          };
        if (!args)
          args = this.eventParameters(eventName, this.response);
        var origEmit = AWS2.SequentialExecutor.prototype.emit;
        origEmit.call(this, eventName, args, function(err) {
          if (err)
            this.response.error = err;
          done.call(this, err);
        });
      },
      /**
       * @api private
       */
      eventParameters: function eventParameters(eventName) {
        switch (eventName) {
          case "restart":
          case "validate":
          case "sign":
          case "build":
          case "afterValidate":
          case "afterBuild":
            return [this];
          case "error":
            return [this.response.error, this.response];
          default:
            return [this.response];
        }
      },
      /**
       * @api private
       */
      presign: function presign(expires, callback) {
        if (!callback && typeof expires === "function") {
          callback = expires;
          expires = null;
        }
        return new AWS2.Signers.Presign().sign(this.toGet(), expires, callback);
      },
      /**
       * @api private
       */
      isPresigned: function isPresigned() {
        return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, "presigned-expires");
      },
      /**
       * @api private
       */
      toUnauthenticated: function toUnauthenticated() {
        this._unAuthenticated = true;
        this.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_CREDENTIALS);
        this.removeListener("sign", AWS2.EventListeners.Core.SIGN);
        return this;
      },
      /**
       * @api private
       */
      toGet: function toGet() {
        if (this.service.api.protocol === "query" || this.service.api.protocol === "ec2") {
          this.removeListener("build", this.buildAsGet);
          this.addListener("build", this.buildAsGet);
        }
        return this;
      },
      /**
       * @api private
       */
      buildAsGet: function buildAsGet(request) {
        request.httpRequest.method = "GET";
        request.httpRequest.path = request.service.endpoint.path + "?" + request.httpRequest.body;
        request.httpRequest.body = "";
        delete request.httpRequest.headers["Content-Length"];
        delete request.httpRequest.headers["Content-Type"];
      },
      /**
       * @api private
       */
      haltHandlersOnError: function haltHandlersOnError() {
        this._haltHandlersOnError = true;
      }
    });
    AWS2.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = function promise() {
        var self = this;
        this.httpRequest.appendToUserAgent("promise");
        return new PromiseDependency(function(resolve, reject) {
          self.on("complete", function(resp) {
            if (resp.error) {
              reject(resp.error);
            } else {
              resolve(Object.defineProperty(
                resp.data || {},
                "$response",
                { value: resp }
              ));
            }
          });
          self.runTo();
        });
      };
    };
    AWS2.Request.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };
    AWS2.util.addPromises(AWS2.Request);
    AWS2.util.mixin(AWS2.Request, AWS2.SequentialExecutor);
  }
});

// node_modules/aws-sdk/lib/response.js
var require_response = __commonJS({
  "node_modules/aws-sdk/lib/response.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    AWS2.Response = inherit({
      /**
       * @api private
       */
      constructor: function Response(request) {
        this.request = request;
        this.data = null;
        this.error = null;
        this.retryCount = 0;
        this.redirectCount = 0;
        this.httpResponse = new AWS2.HttpResponse();
        if (request) {
          this.maxRetries = request.service.numRetries();
          this.maxRedirects = request.service.config.maxRedirects;
        }
      },
      /**
       * Creates a new request for the next page of response data, calling the
       * callback with the page data if a callback is provided.
       *
       * @callback callback function(err, data)
       *   Called when a page of data is returned from the next request.
       *
       *   @param err [Error] an error object, if an error occurred in the request
       *   @param data [Object] the next page of data, or null, if there are no
       *     more pages left.
       * @return [AWS.Request] the request object for the next page of data
       * @return [null] if no callback is provided and there are no pages left
       *   to retrieve.
       * @since v1.4.0
       */
      nextPage: function nextPage(callback) {
        var config;
        var service = this.request.service;
        var operation = this.request.operation;
        try {
          config = service.paginationConfig(operation, true);
        } catch (e) {
          this.error = e;
        }
        if (!this.hasNextPage()) {
          if (callback)
            callback(this.error, null);
          else if (this.error)
            throw this.error;
          return null;
        }
        var params = AWS2.util.copy(this.request.params);
        if (!this.nextPageTokens) {
          return callback ? callback(null, null) : null;
        } else {
          var inputTokens = config.inputToken;
          if (typeof inputTokens === "string")
            inputTokens = [inputTokens];
          for (var i = 0; i < inputTokens.length; i++) {
            params[inputTokens[i]] = this.nextPageTokens[i];
          }
          return service.makeRequest(this.request.operation, params, callback);
        }
      },
      /**
       * @return [Boolean] whether more pages of data can be returned by further
       *   requests
       * @since v1.4.0
       */
      hasNextPage: function hasNextPage() {
        this.cacheNextPageTokens();
        if (this.nextPageTokens)
          return true;
        if (this.nextPageTokens === void 0)
          return void 0;
        else
          return false;
      },
      /**
       * @api private
       */
      cacheNextPageTokens: function cacheNextPageTokens() {
        if (Object.prototype.hasOwnProperty.call(this, "nextPageTokens"))
          return this.nextPageTokens;
        this.nextPageTokens = void 0;
        var config = this.request.service.paginationConfig(this.request.operation);
        if (!config)
          return this.nextPageTokens;
        this.nextPageTokens = null;
        if (config.moreResults) {
          if (!jmespath.search(this.data, config.moreResults)) {
            return this.nextPageTokens;
          }
        }
        var exprs = config.outputToken;
        if (typeof exprs === "string")
          exprs = [exprs];
        AWS2.util.arrayEach.call(this, exprs, function(expr) {
          var output = jmespath.search(this.data, expr);
          if (output) {
            this.nextPageTokens = this.nextPageTokens || [];
            this.nextPageTokens.push(output);
          }
        });
        return this.nextPageTokens;
      }
    });
  }
});

// node_modules/aws-sdk/lib/resource_waiter.js
var require_resource_waiter2 = __commonJS({
  "node_modules/aws-sdk/lib/resource_waiter.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var jmespath = require_jmespath();
    function CHECK_ACCEPTORS(resp) {
      var waiter = resp.request._waiter;
      var acceptors = waiter.config.acceptors;
      var acceptorMatched = false;
      var state = "retry";
      acceptors.forEach(function(acceptor) {
        if (!acceptorMatched) {
          var matcher = waiter.matchers[acceptor.matcher];
          if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
            acceptorMatched = true;
            state = acceptor.state;
          }
        }
      });
      if (!acceptorMatched && resp.error)
        state = "failure";
      if (state === "success") {
        waiter.setSuccess(resp);
      } else {
        waiter.setError(resp, state === "retry");
      }
    }
    AWS2.ResourceWaiter = inherit({
      /**
       * Waits for a given state on a service object
       * @param service [Service] the service object to wait on
       * @param state [String] the state (defined in waiter configuration) to wait
       *   for.
       * @example Create a waiter for running EC2 instances
       *   var ec2 = new AWS.EC2;
       *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
       */
      constructor: function constructor(service, state) {
        this.service = service;
        this.state = state;
        this.loadWaiterConfig(this.state);
      },
      service: null,
      state: null,
      config: null,
      matchers: {
        path: function(resp, expected, argument) {
          try {
            var result = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          return jmespath.strictDeepEqual(result, expected);
        },
        pathAll: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          if (!numResults)
            return false;
          for (var ind = 0; ind < numResults; ind++) {
            if (!jmespath.strictDeepEqual(results[ind], expected)) {
              return false;
            }
          }
          return true;
        },
        pathAny: function(resp, expected, argument) {
          try {
            var results = jmespath.search(resp.data, argument);
          } catch (err) {
            return false;
          }
          if (!Array.isArray(results))
            results = [results];
          var numResults = results.length;
          for (var ind = 0; ind < numResults; ind++) {
            if (jmespath.strictDeepEqual(results[ind], expected)) {
              return true;
            }
          }
          return false;
        },
        status: function(resp, expected) {
          var statusCode = resp.httpResponse.statusCode;
          return typeof statusCode === "number" && statusCode === expected;
        },
        error: function(resp, expected) {
          if (typeof expected === "string" && resp.error) {
            return expected === resp.error.code;
          }
          return expected === !!resp.error;
        }
      },
      listeners: new AWS2.SequentialExecutor().addNamedListeners(function(add) {
        add("RETRY_CHECK", "retry", function(resp) {
          var waiter = resp.request._waiter;
          if (resp.error && resp.error.code === "ResourceNotReady") {
            resp.error.retryDelay = (waiter.config.delay || 0) * 1e3;
          }
        });
        add("CHECK_OUTPUT", "extractData", CHECK_ACCEPTORS);
        add("CHECK_ERROR", "extractError", CHECK_ACCEPTORS);
      }),
      /**
       * @return [AWS.Request]
       */
      wait: function wait(params, callback) {
        if (typeof params === "function") {
          callback = params;
          params = void 0;
        }
        if (params && params.$waiter) {
          params = AWS2.util.copy(params);
          if (typeof params.$waiter.delay === "number") {
            this.config.delay = params.$waiter.delay;
          }
          if (typeof params.$waiter.maxAttempts === "number") {
            this.config.maxAttempts = params.$waiter.maxAttempts;
          }
          delete params.$waiter;
        }
        var request = this.service.makeRequest(this.config.operation, params);
        request._waiter = this;
        request.response.maxRetries = this.config.maxAttempts;
        request.addListeners(this.listeners);
        if (callback)
          request.send(callback);
        return request;
      },
      setSuccess: function setSuccess(resp) {
        resp.error = null;
        resp.data = resp.data || {};
        resp.request.removeAllListeners("extractData");
      },
      setError: function setError(resp, retryable) {
        resp.data = null;
        resp.error = AWS2.util.error(resp.error || new Error(), {
          code: "ResourceNotReady",
          message: "Resource is not in the state " + this.state,
          retryable
        });
      },
      /**
       * Loads waiter configuration from API configuration
       *
       * @api private
       */
      loadWaiterConfig: function loadWaiterConfig(state) {
        if (!this.service.api.waiters[state]) {
          throw new AWS2.util.error(new Error(), {
            code: "StateNotFoundError",
            message: "State " + state + " not found."
          });
        }
        this.config = AWS2.util.copy(this.service.api.waiters[state]);
      }
    });
  }
});

// node_modules/aws-sdk/lib/signers/v2.js
var require_v2 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v2.js"(exports, module) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V2 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        if (!date)
          date = AWS2.util.date.getDate();
        var r = this.request;
        r.params.Timestamp = AWS2.util.date.iso8601(date);
        r.params.SignatureVersion = "2";
        r.params.SignatureMethod = "HmacSHA256";
        r.params.AWSAccessKeyId = credentials.accessKeyId;
        if (credentials.sessionToken) {
          r.params.SecurityToken = credentials.sessionToken;
        }
        delete r.params.Signature;
        r.params.Signature = this.signature(credentials);
        r.body = AWS2.util.queryParamsToString(r.params);
        r.headers["Content-Length"] = r.body.length;
      },
      signature: function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push(this.request.endpoint.host.toLowerCase());
        parts.push(this.request.pathname());
        parts.push(AWS2.util.queryParamsToString(this.request.params));
        return parts.join("\n");
      }
    });
    module.exports = AWS2.Signers.V2;
  }
});

// node_modules/aws-sdk/lib/signers/v3.js
var require_v3 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3.js"(exports, module) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.V3 = inherit(AWS2.Signers.RequestSigner, {
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.rfc822(date);
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        this.request.headers["X-Amzn-Authorization"] = this.authorization(credentials, datetime);
      },
      authorization: function authorization(credentials) {
        return "AWS3 AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,SignedHeaders=" + this.signedHeaders() + ",Signature=" + this.signature(credentials);
      },
      signedHeaders: function signedHeaders() {
        var headers = [];
        AWS2.util.arrayEach(this.headersToSign(), function iterator(h) {
          headers.push(h.toLowerCase());
        });
        return headers.sort().join(";");
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = this.request.headers;
        var parts = [];
        AWS2.util.arrayEach(this.headersToSign(), function iterator(h) {
          parts.push(h.toLowerCase().trim() + ":" + String(headers[h]).trim());
        });
        return parts.sort().join("\n") + "\n";
      },
      headersToSign: function headersToSign() {
        var headers = [];
        AWS2.util.each(this.request.headers, function iterator(k) {
          if (k === "Host" || k === "Content-Encoding" || k.match(/^X-Amz/i)) {
            headers.push(k);
          }
        });
        return headers;
      },
      signature: function signature(credentials) {
        return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
      },
      stringToSign: function stringToSign() {
        var parts = [];
        parts.push(this.request.method);
        parts.push("/");
        parts.push("");
        parts.push(this.canonicalHeaders());
        parts.push(this.request.body);
        return AWS2.util.crypto.sha256(parts.join("\n"));
      }
    });
    module.exports = AWS2.Signers.V3;
  }
});

// node_modules/aws-sdk/lib/signers/v3https.js
var require_v3https = __commonJS({
  "node_modules/aws-sdk/lib/signers/v3https.js"(exports, module) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    require_v3();
    AWS2.Signers.V3Https = inherit(AWS2.Signers.V3, {
      authorization: function authorization(credentials) {
        return "AWS3-HTTPS AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,Signature=" + this.signature(credentials);
      },
      stringToSign: function stringToSign() {
        return this.request.headers["X-Amz-Date"];
      }
    });
    module.exports = AWS2.Signers.V3Https;
  }
});

// node_modules/aws-sdk/lib/signers/v4_credentials.js
var require_v4_credentials = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4_credentials.js"(exports, module) {
    var AWS2 = require_core();
    var cachedSecret = {};
    var cacheQueue = [];
    var maxCacheEntries = 50;
    var v4Identifier = "aws4_request";
    module.exports = {
      /**
       * @api private
       *
       * @param date [String]
       * @param region [String]
       * @param serviceName [String]
       * @return [String]
       */
      createScope: function createScope(date, region, serviceName) {
        return [
          date.substr(0, 8),
          region,
          serviceName,
          v4Identifier
        ].join("/");
      },
      /**
       * @api private
       *
       * @param credentials [Credentials]
       * @param date [String]
       * @param region [String]
       * @param service [String]
       * @param shouldCache [Boolean]
       * @return [String]
       */
      getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {
        var credsIdentifier = AWS2.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, "base64");
        var cacheKey = [credsIdentifier, date, region, service].join("_");
        shouldCache = shouldCache !== false;
        if (shouldCache && cacheKey in cachedSecret) {
          return cachedSecret[cacheKey];
        }
        var kDate = AWS2.util.crypto.hmac(
          "AWS4" + credentials.secretAccessKey,
          date,
          "buffer"
        );
        var kRegion = AWS2.util.crypto.hmac(kDate, region, "buffer");
        var kService = AWS2.util.crypto.hmac(kRegion, service, "buffer");
        var signingKey = AWS2.util.crypto.hmac(kService, v4Identifier, "buffer");
        if (shouldCache) {
          cachedSecret[cacheKey] = signingKey;
          cacheQueue.push(cacheKey);
          if (cacheQueue.length > maxCacheEntries) {
            delete cachedSecret[cacheQueue.shift()];
          }
        }
        return signingKey;
      },
      /**
       * @api private
       *
       * Empties the derived signing key cache. Made available for testing purposes
       * only.
       */
      emptyCache: function emptyCache() {
        cachedSecret = {};
        cacheQueue = [];
      }
    };
  }
});

// node_modules/aws-sdk/lib/signers/v4.js
var require_v4 = __commonJS({
  "node_modules/aws-sdk/lib/signers/v4.js"(exports, module) {
    var AWS2 = require_core();
    var v4Credentials = require_v4_credentials();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    AWS2.Signers.V4 = inherit(AWS2.Signers.RequestSigner, {
      constructor: function V4(request, serviceName, options) {
        AWS2.Signers.RequestSigner.call(this, request);
        this.serviceName = serviceName;
        options = options || {};
        this.signatureCache = typeof options.signatureCache === "boolean" ? options.signatureCache : true;
        this.operation = options.operation;
        this.signatureVersion = options.signatureVersion;
      },
      algorithm: "AWS4-HMAC-SHA256",
      addAuthorization: function addAuthorization(credentials, date) {
        var datetime = AWS2.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, "");
        if (this.isPresigned()) {
          this.updateForPresigned(credentials, datetime);
        } else {
          this.addHeaders(credentials, datetime);
        }
        this.request.headers["Authorization"] = this.authorization(credentials, datetime);
      },
      addHeaders: function addHeaders(credentials, datetime) {
        this.request.headers["X-Amz-Date"] = datetime;
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
      },
      updateForPresigned: function updateForPresigned(credentials, datetime) {
        var credString = this.credentialString(datetime);
        var qs = {
          "X-Amz-Date": datetime,
          "X-Amz-Algorithm": this.algorithm,
          "X-Amz-Credential": credentials.accessKeyId + "/" + credString,
          "X-Amz-Expires": this.request.headers[expiresHeader],
          "X-Amz-SignedHeaders": this.signedHeaders()
        };
        if (credentials.sessionToken) {
          qs["X-Amz-Security-Token"] = credentials.sessionToken;
        }
        if (this.request.headers["Content-Type"]) {
          qs["Content-Type"] = this.request.headers["Content-Type"];
        }
        if (this.request.headers["Content-MD5"]) {
          qs["Content-MD5"] = this.request.headers["Content-MD5"];
        }
        if (this.request.headers["Cache-Control"]) {
          qs["Cache-Control"] = this.request.headers["Cache-Control"];
        }
        AWS2.util.each.call(this, this.request.headers, function(key, value) {
          if (key === expiresHeader)
            return;
          if (this.isSignableHeader(key)) {
            var lowerKey = key.toLowerCase();
            if (lowerKey.indexOf("x-amz-meta-") === 0) {
              qs[lowerKey] = value;
            } else if (lowerKey.indexOf("x-amz-") === 0) {
              qs[key] = value;
            }
          }
        });
        var sep = this.request.path.indexOf("?") >= 0 ? "&" : "?";
        this.request.path += sep + AWS2.util.queryParamsToString(qs);
      },
      authorization: function authorization(credentials, datetime) {
        var parts = [];
        var credString = this.credentialString(datetime);
        parts.push(this.algorithm + " Credential=" + credentials.accessKeyId + "/" + credString);
        parts.push("SignedHeaders=" + this.signedHeaders());
        parts.push("Signature=" + this.signature(credentials, datetime));
        return parts.join(", ");
      },
      signature: function signature(credentials, datetime) {
        var signingKey = v4Credentials.getSigningKey(
          credentials,
          datetime.substr(0, 8),
          this.request.region,
          this.serviceName,
          this.signatureCache
        );
        return AWS2.util.crypto.hmac(signingKey, this.stringToSign(datetime), "hex");
      },
      stringToSign: function stringToSign(datetime) {
        var parts = [];
        parts.push("AWS4-HMAC-SHA256");
        parts.push(datetime);
        parts.push(this.credentialString(datetime));
        parts.push(this.hexEncodedHash(this.canonicalString()));
        return parts.join("\n");
      },
      canonicalString: function canonicalString() {
        var parts = [], pathname = this.request.pathname();
        if (this.serviceName !== "s3" && this.signatureVersion !== "s3v4")
          pathname = AWS2.util.uriEscapePath(pathname);
        parts.push(this.request.method);
        parts.push(pathname);
        parts.push(this.request.search());
        parts.push(this.canonicalHeaders() + "\n");
        parts.push(this.signedHeaders());
        parts.push(this.hexEncodedBodyHash());
        return parts.join("\n");
      },
      canonicalHeaders: function canonicalHeaders() {
        var headers = [];
        AWS2.util.each.call(this, this.request.headers, function(key, item) {
          headers.push([key, item]);
        });
        headers.sort(function(a, b) {
          return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, headers, function(item) {
          var key = item[0].toLowerCase();
          if (this.isSignableHeader(key)) {
            var value = item[1];
            if (typeof value === "undefined" || value === null || typeof value.toString !== "function") {
              throw AWS2.util.error(new Error("Header " + key + " contains invalid value"), {
                code: "InvalidHeader"
              });
            }
            parts.push(key + ":" + this.canonicalHeaderValues(value.toString()));
          }
        });
        return parts.join("\n");
      },
      canonicalHeaderValues: function canonicalHeaderValues(values) {
        return values.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
      },
      signedHeaders: function signedHeaders() {
        var keys = [];
        AWS2.util.each.call(this, this.request.headers, function(key) {
          key = key.toLowerCase();
          if (this.isSignableHeader(key))
            keys.push(key);
        });
        return keys.sort().join(";");
      },
      credentialString: function credentialString(datetime) {
        return v4Credentials.createScope(
          datetime.substr(0, 8),
          this.request.region,
          this.serviceName
        );
      },
      hexEncodedHash: function hash(string) {
        return AWS2.util.crypto.sha256(string, "hex");
      },
      hexEncodedBodyHash: function hexEncodedBodyHash() {
        var request = this.request;
        if (this.isPresigned() && ["s3", "s3-object-lambda"].indexOf(this.serviceName) > -1 && !request.body) {
          return "UNSIGNED-PAYLOAD";
        } else if (request.headers["X-Amz-Content-Sha256"]) {
          return request.headers["X-Amz-Content-Sha256"];
        } else {
          return this.hexEncodedHash(this.request.body || "");
        }
      },
      unsignableHeaders: [
        "authorization",
        "content-type",
        "content-length",
        "user-agent",
        expiresHeader,
        "expect",
        "x-amzn-trace-id"
      ],
      isSignableHeader: function isSignableHeader(key) {
        if (key.toLowerCase().indexOf("x-amz-") === 0)
          return true;
        return this.unsignableHeaders.indexOf(key) < 0;
      },
      isPresigned: function isPresigned() {
        return this.request.headers[expiresHeader] ? true : false;
      }
    });
    module.exports = AWS2.Signers.V4;
  }
});

// node_modules/aws-sdk/lib/signers/s3.js
var require_s3 = __commonJS({
  "node_modules/aws-sdk/lib/signers/s3.js"(exports, module) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.S3 = inherit(AWS2.Signers.RequestSigner, {
      /**
       * When building the stringToSign, these sub resource params should be
       * part of the canonical resource string with their NON-decoded values
       */
      subResources: {
        "acl": 1,
        "accelerate": 1,
        "analytics": 1,
        "cors": 1,
        "lifecycle": 1,
        "delete": 1,
        "inventory": 1,
        "location": 1,
        "logging": 1,
        "metrics": 1,
        "notification": 1,
        "partNumber": 1,
        "policy": 1,
        "requestPayment": 1,
        "replication": 1,
        "restore": 1,
        "tagging": 1,
        "torrent": 1,
        "uploadId": 1,
        "uploads": 1,
        "versionId": 1,
        "versioning": 1,
        "versions": 1,
        "website": 1
      },
      // when building the stringToSign, these querystring params should be
      // part of the canonical resource string with their NON-encoded values
      responseHeaders: {
        "response-content-type": 1,
        "response-content-language": 1,
        "response-expires": 1,
        "response-cache-control": 1,
        "response-content-disposition": 1,
        "response-content-encoding": 1
      },
      addAuthorization: function addAuthorization(credentials, date) {
        if (!this.request.headers["presigned-expires"]) {
          this.request.headers["X-Amz-Date"] = AWS2.util.date.rfc822(date);
        }
        if (credentials.sessionToken) {
          this.request.headers["x-amz-security-token"] = credentials.sessionToken;
        }
        var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
        var auth = "AWS " + credentials.accessKeyId + ":" + signature;
        this.request.headers["Authorization"] = auth;
      },
      stringToSign: function stringToSign() {
        var r = this.request;
        var parts = [];
        parts.push(r.method);
        parts.push(r.headers["Content-MD5"] || "");
        parts.push(r.headers["Content-Type"] || "");
        parts.push(r.headers["presigned-expires"] || "");
        var headers = this.canonicalizedAmzHeaders();
        if (headers)
          parts.push(headers);
        parts.push(this.canonicalizedResource());
        return parts.join("\n");
      },
      canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {
        var amzHeaders = [];
        AWS2.util.each(this.request.headers, function(name) {
          if (name.match(/^x-amz-/i))
            amzHeaders.push(name);
        });
        amzHeaders.sort(function(a, b) {
          return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
        });
        var parts = [];
        AWS2.util.arrayEach.call(this, amzHeaders, function(name) {
          parts.push(name.toLowerCase() + ":" + String(this.request.headers[name]));
        });
        return parts.join("\n");
      },
      canonicalizedResource: function canonicalizedResource() {
        var r = this.request;
        var parts = r.path.split("?");
        var path = parts[0];
        var querystring = parts[1];
        var resource = "";
        if (r.virtualHostedBucket)
          resource += "/" + r.virtualHostedBucket;
        resource += path;
        if (querystring) {
          var resources = [];
          AWS2.util.arrayEach.call(this, querystring.split("&"), function(param) {
            var name = param.split("=")[0];
            var value = param.split("=")[1];
            if (this.subResources[name] || this.responseHeaders[name]) {
              var subresource = { name };
              if (value !== void 0) {
                if (this.subResources[name]) {
                  subresource.value = value;
                } else {
                  subresource.value = decodeURIComponent(value);
                }
              }
              resources.push(subresource);
            }
          });
          resources.sort(function(a, b) {
            return a.name < b.name ? -1 : 1;
          });
          if (resources.length) {
            querystring = [];
            AWS2.util.arrayEach(resources, function(res) {
              if (res.value === void 0) {
                querystring.push(res.name);
              } else {
                querystring.push(res.name + "=" + res.value);
              }
            });
            resource += "?" + querystring.join("&");
          }
        }
        return resource;
      },
      sign: function sign(secret, string) {
        return AWS2.util.crypto.hmac(secret, string, "base64", "sha1");
      }
    });
    module.exports = AWS2.Signers.S3;
  }
});

// node_modules/aws-sdk/lib/signers/presign.js
var require_presign = __commonJS({
  "node_modules/aws-sdk/lib/signers/presign.js"(exports, module) {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    var expiresHeader = "presigned-expires";
    function signedUrlBuilder(request) {
      var expires = request.httpRequest.headers[expiresHeader];
      var signerClass = request.service.getSignerClass(request);
      delete request.httpRequest.headers["User-Agent"];
      delete request.httpRequest.headers["X-Amz-User-Agent"];
      if (signerClass === AWS2.Signers.V4) {
        if (expires > 604800) {
          var message = "Presigning does not support expiry time greater than a week with SigV4 signing.";
          throw AWS2.util.error(new Error(), {
            code: "InvalidExpiryTime",
            message,
            retryable: false
          });
        }
        request.httpRequest.headers[expiresHeader] = expires;
      } else if (signerClass === AWS2.Signers.S3) {
        var now = request.service ? request.service.getSkewCorrectedDate() : AWS2.util.date.getDate();
        request.httpRequest.headers[expiresHeader] = parseInt(
          AWS2.util.date.unixTimestamp(now) + expires,
          10
        ).toString();
      } else {
        throw AWS2.util.error(new Error(), {
          message: "Presigning only supports S3 or SigV4 signing.",
          code: "UnsupportedSigner",
          retryable: false
        });
      }
    }
    function signedUrlSigner(request) {
      var endpoint = request.httpRequest.endpoint;
      var parsedUrl = AWS2.util.urlParse(request.httpRequest.path);
      var queryParams = {};
      if (parsedUrl.search) {
        queryParams = AWS2.util.queryStringParse(parsedUrl.search.substr(1));
      }
      var auth = request.httpRequest.headers["Authorization"].split(" ");
      if (auth[0] === "AWS") {
        auth = auth[1].split(":");
        queryParams["Signature"] = auth.pop();
        queryParams["AWSAccessKeyId"] = auth.join(":");
        AWS2.util.each(request.httpRequest.headers, function(key, value) {
          if (key === expiresHeader)
            key = "Expires";
          if (key.indexOf("x-amz-meta-") === 0) {
            delete queryParams[key];
            key = key.toLowerCase();
          }
          queryParams[key] = value;
        });
        delete request.httpRequest.headers[expiresHeader];
        delete queryParams["Authorization"];
        delete queryParams["Host"];
      } else if (auth[0] === "AWS4-HMAC-SHA256") {
        auth.shift();
        var rest = auth.join(" ");
        var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
        queryParams["X-Amz-Signature"] = signature;
        delete queryParams["Expires"];
      }
      endpoint.pathname = parsedUrl.pathname;
      endpoint.search = AWS2.util.queryParamsToString(queryParams);
    }
    AWS2.Signers.Presign = inherit({
      /**
       * @api private
       */
      sign: function sign(request, expireTime, callback) {
        request.httpRequest.headers[expiresHeader] = expireTime || 3600;
        request.on("build", signedUrlBuilder);
        request.on("sign", signedUrlSigner);
        request.removeListener(
          "afterBuild",
          AWS2.EventListeners.Core.SET_CONTENT_LENGTH
        );
        request.removeListener(
          "afterBuild",
          AWS2.EventListeners.Core.COMPUTE_SHA256
        );
        request.emit("beforePresign", [request]);
        if (callback) {
          request.build(function() {
            if (this.response.error)
              callback(this.response.error);
            else {
              callback(null, AWS2.util.urlFormat(request.httpRequest.endpoint));
            }
          });
        } else {
          request.build();
          if (request.response.error)
            throw request.response.error;
          return AWS2.util.urlFormat(request.httpRequest.endpoint);
        }
      }
    });
    module.exports = AWS2.Signers.Presign;
  }
});

// node_modules/aws-sdk/lib/signers/bearer.js
var require_bearer = __commonJS({
  "node_modules/aws-sdk/lib/signers/bearer.js"() {
    var AWS2 = require_core();
    AWS2.Signers.Bearer = AWS2.util.inherit(AWS2.Signers.RequestSigner, {
      constructor: function Bearer(request) {
        AWS2.Signers.RequestSigner.call(this, request);
      },
      addAuthorization: function addAuthorization(token) {
        this.request.headers["Authorization"] = "Bearer " + token.token;
      }
    });
  }
});

// node_modules/aws-sdk/lib/signers/request_signer.js
var require_request_signer = __commonJS({
  "node_modules/aws-sdk/lib/signers/request_signer.js"() {
    var AWS2 = require_core();
    var inherit = AWS2.util.inherit;
    AWS2.Signers.RequestSigner = inherit({
      constructor: function RequestSigner(request) {
        this.request = request;
      },
      setServiceClientId: function setServiceClientId(id) {
        this.serviceClientId = id;
      },
      getServiceClientId: function getServiceClientId() {
        return this.serviceClientId;
      }
    });
    AWS2.Signers.RequestSigner.getVersion = function getVersion(version) {
      switch (version) {
        case "v2":
          return AWS2.Signers.V2;
        case "v3":
          return AWS2.Signers.V3;
        case "s3v4":
          return AWS2.Signers.V4;
        case "v4":
          return AWS2.Signers.V4;
        case "s3":
          return AWS2.Signers.S3;
        case "v3https":
          return AWS2.Signers.V3Https;
        case "bearer":
          return AWS2.Signers.Bearer;
      }
      throw new Error("Unknown signing version " + version);
    };
    require_v2();
    require_v3();
    require_v3https();
    require_v4();
    require_s3();
    require_presign();
    require_bearer();
  }
});

// node_modules/aws-sdk/lib/param_validator.js
var require_param_validator = __commonJS({
  "node_modules/aws-sdk/lib/param_validator.js"() {
    var AWS2 = require_core();
    AWS2.ParamValidator = AWS2.util.inherit({
      /**
       * Create a new validator object.
       *
       * @param validation [Boolean|map] whether input parameters should be
       *     validated against the operation description before sending the
       *     request. Pass a map to enable any of the following specific
       *     validation features:
       *
       *     * **min** [Boolean] &mdash; Validates that a value meets the min
       *       constraint. This is enabled by default when paramValidation is set
       *       to `true`.
       *     * **max** [Boolean] &mdash; Validates that a value meets the max
       *       constraint.
       *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
       *       regular expression.
       *     * **enum** [Boolean] &mdash; Validates that a string value matches one
       *       of the allowable enum values.
       */
      constructor: function ParamValidator(validation) {
        if (validation === true || validation === void 0) {
          validation = { "min": true };
        }
        this.validation = validation;
      },
      validate: function validate(shape, params, context) {
        this.errors = [];
        this.validateMember(shape, params || {}, context || "params");
        if (this.errors.length > 1) {
          var msg = this.errors.join("\n* ");
          msg = "There were " + this.errors.length + " validation errors:\n* " + msg;
          throw AWS2.util.error(
            new Error(msg),
            { code: "MultipleValidationErrors", errors: this.errors }
          );
        } else if (this.errors.length === 1) {
          throw this.errors[0];
        } else {
          return true;
        }
      },
      fail: function fail(code, message) {
        this.errors.push(AWS2.util.error(new Error(message), { code }));
      },
      validateStructure: function validateStructure(shape, params, context) {
        if (shape.isDocument)
          return true;
        this.validateType(params, context, ["object"], "structure");
        var paramName;
        for (var i = 0; shape.required && i < shape.required.length; i++) {
          paramName = shape.required[i];
          var value = params[paramName];
          if (value === void 0 || value === null) {
            this.fail(
              "MissingRequiredParameter",
              "Missing required key '" + paramName + "' in " + context
            );
          }
        }
        for (paramName in params) {
          if (!Object.prototype.hasOwnProperty.call(params, paramName))
            continue;
          var paramValue = params[paramName], memberShape = shape.members[paramName];
          if (memberShape !== void 0) {
            var memberContext = [context, paramName].join(".");
            this.validateMember(memberShape, paramValue, memberContext);
          } else if (paramValue !== void 0 && paramValue !== null) {
            this.fail(
              "UnexpectedParameter",
              "Unexpected key '" + paramName + "' found in " + context
            );
          }
        }
        return true;
      },
      validateMember: function validateMember(shape, param, context) {
        switch (shape.type) {
          case "structure":
            return this.validateStructure(shape, param, context);
          case "list":
            return this.validateList(shape, param, context);
          case "map":
            return this.validateMap(shape, param, context);
          default:
            return this.validateScalar(shape, param, context);
        }
      },
      validateList: function validateList(shape, params, context) {
        if (this.validateType(params, context, [Array])) {
          this.validateRange(shape, params.length, context, "list member count");
          for (var i = 0; i < params.length; i++) {
            this.validateMember(shape.member, params[i], context + "[" + i + "]");
          }
        }
      },
      validateMap: function validateMap(shape, params, context) {
        if (this.validateType(params, context, ["object"], "map")) {
          var mapCount = 0;
          for (var param in params) {
            if (!Object.prototype.hasOwnProperty.call(params, param))
              continue;
            this.validateMember(
              shape.key,
              param,
              context + "[key='" + param + "']"
            );
            this.validateMember(
              shape.value,
              params[param],
              context + "['" + param + "']"
            );
            mapCount++;
          }
          this.validateRange(shape, mapCount, context, "map member count");
        }
      },
      validateScalar: function validateScalar(shape, value, context) {
        switch (shape.type) {
          case null:
          case void 0:
          case "string":
            return this.validateString(shape, value, context);
          case "base64":
          case "binary":
            return this.validatePayload(value, context);
          case "integer":
          case "float":
            return this.validateNumber(shape, value, context);
          case "boolean":
            return this.validateType(value, context, ["boolean"]);
          case "timestamp":
            return this.validateType(
              value,
              context,
              [
                Date,
                /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/,
                "number"
              ],
              "Date object, ISO-8601 string, or a UNIX timestamp"
            );
          default:
            return this.fail("UnkownType", "Unhandled type " + shape.type + " for " + context);
        }
      },
      validateString: function validateString(shape, value, context) {
        var validTypes = ["string"];
        if (shape.isJsonValue) {
          validTypes = validTypes.concat(["number", "object", "boolean"]);
        }
        if (value !== null && this.validateType(value, context, validTypes)) {
          this.validateEnum(shape, value, context);
          this.validateRange(shape, value.length, context, "string length");
          this.validatePattern(shape, value, context);
          this.validateUri(shape, value, context);
        }
      },
      validateUri: function validateUri(shape, value, context) {
        if (shape["location"] === "uri") {
          if (value.length === 0) {
            this.fail("UriParameterError", 'Expected uri parameter to have length >= 1, but found "' + value + '" for ' + context);
          }
        }
      },
      validatePattern: function validatePattern(shape, value, context) {
        if (this.validation["pattern"] && shape["pattern"] !== void 0) {
          if (!new RegExp(shape["pattern"]).test(value)) {
            this.fail("PatternMatchError", 'Provided value "' + value + '" does not match regex pattern /' + shape["pattern"] + "/ for " + context);
          }
        }
      },
      validateRange: function validateRange(shape, value, context, descriptor) {
        if (this.validation["min"]) {
          if (shape["min"] !== void 0 && value < shape["min"]) {
            this.fail("MinRangeError", "Expected " + descriptor + " >= " + shape["min"] + ", but found " + value + " for " + context);
          }
        }
        if (this.validation["max"]) {
          if (shape["max"] !== void 0 && value > shape["max"]) {
            this.fail("MaxRangeError", "Expected " + descriptor + " <= " + shape["max"] + ", but found " + value + " for " + context);
          }
        }
      },
      validateEnum: function validateRange(shape, value, context) {
        if (this.validation["enum"] && shape["enum"] !== void 0) {
          if (shape["enum"].indexOf(value) === -1) {
            this.fail("EnumError", "Found string value of " + value + ", but expected " + shape["enum"].join("|") + " for " + context);
          }
        }
      },
      validateType: function validateType(value, context, acceptedTypes, type) {
        if (value === null || value === void 0)
          return false;
        var foundInvalidType = false;
        for (var i = 0; i < acceptedTypes.length; i++) {
          if (typeof acceptedTypes[i] === "string") {
            if (typeof value === acceptedTypes[i])
              return true;
          } else if (acceptedTypes[i] instanceof RegExp) {
            if ((value || "").toString().match(acceptedTypes[i]))
              return true;
          } else {
            if (value instanceof acceptedTypes[i])
              return true;
            if (AWS2.util.isType(value, acceptedTypes[i]))
              return true;
            if (!type && !foundInvalidType)
              acceptedTypes = acceptedTypes.slice();
            acceptedTypes[i] = AWS2.util.typeName(acceptedTypes[i]);
          }
          foundInvalidType = true;
        }
        var acceptedType = type;
        if (!acceptedType) {
          acceptedType = acceptedTypes.join(", ").replace(/,([^,]+)$/, ", or$1");
        }
        var vowel = acceptedType.match(/^[aeiou]/i) ? "n" : "";
        this.fail("InvalidParameterType", "Expected " + context + " to be a" + vowel + " " + acceptedType);
        return false;
      },
      validateNumber: function validateNumber(shape, value, context) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string") {
          var castedValue = parseFloat(value);
          if (castedValue.toString() === value)
            value = castedValue;
        }
        if (this.validateType(value, context, ["number"])) {
          this.validateRange(shape, value, context, "numeric value");
        }
      },
      validatePayload: function validatePayload(value, context) {
        if (value === null || value === void 0)
          return;
        if (typeof value === "string")
          return;
        if (value && typeof value.byteLength === "number")
          return;
        if (AWS2.util.isNode()) {
          var Stream = AWS2.util.stream.Stream;
          if (AWS2.util.Buffer.isBuffer(value) || value instanceof Stream)
            return;
        } else {
          if (typeof Blob !== void 0 && value instanceof Blob)
            return;
        }
        var types = ["Buffer", "Stream", "File", "Blob", "ArrayBuffer", "DataView"];
        if (value) {
          for (var i = 0; i < types.length; i++) {
            if (AWS2.util.isType(value, types[i]))
              return;
            if (AWS2.util.typeName(value.constructor) === types[i])
              return;
          }
        }
        this.fail("InvalidParameterType", "Expected " + context + " to be a string, Buffer, Stream, Blob, or typed array object");
      }
    });
  }
});

// node_modules/aws-sdk/lib/maintenance_mode_message.js
var require_maintenance_mode_message = __commonJS({
  "node_modules/aws-sdk/lib/maintenance_mode_message.js"(exports, module) {
    var warning = [
      "The AWS SDK for JavaScript (v2) will enter maintenance mode",
      "on September 8, 2024 and reach end-of-support on September 8, 2025.\n",
      "Please migrate your code to use AWS SDK for JavaScript (v3).",
      "For more information, check blog post at https://a.co/cUPnyil"
    ].join("\n");
    module.exports = {
      suppress: false
    };
    function emitWarning() {
      if (typeof process === "undefined")
        return;
      if (typeof process.env === "object" && typeof process.env.AWS_EXECUTION_ENV !== "undefined" && process.env.AWS_EXECUTION_ENV.indexOf("AWS_Lambda_") === 0) {
        return;
      }
      if (typeof process.env === "object" && typeof process.env.AWS_SDK_JS_SUPPRESS_MAINTENANCE_MODE_MESSAGE !== "undefined") {
        return;
      }
      if (typeof process.emitWarning === "function") {
        process.emitWarning(warning, {
          type: "NOTE"
        });
      }
    }
    setTimeout(function() {
      if (!module.exports.suppress) {
        emitWarning();
      }
    }, 0);
  }
});

// node_modules/aws-sdk/lib/core.js
var require_core = __commonJS({
  "node_modules/aws-sdk/lib/core.js"(exports, module) {
    var AWS2 = { util: require_util2() };
    var _hidden = {};
    _hidden.toString();
    module.exports = AWS2;
    AWS2.util.update(AWS2, {
      /**
       * @constant
       */
      VERSION: "2.1598.0",
      /**
       * @api private
       */
      Signers: {},
      /**
       * @api private
       */
      Protocol: {
        Json: require_json(),
        Query: require_query(),
        Rest: require_rest(),
        RestJson: require_rest_json(),
        RestXml: require_rest_xml()
      },
      /**
       * @api private
       */
      XML: {
        Builder: require_builder2(),
        Parser: null
        // conditionally set based on environment
      },
      /**
       * @api private
       */
      JSON: {
        Builder: require_builder(),
        Parser: require_parser()
      },
      /**
       * @api private
       */
      Model: {
        Api: require_api(),
        Operation: require_operation(),
        Shape: require_shape(),
        Paginator: require_paginator(),
        ResourceWaiter: require_resource_waiter()
      },
      /**
       * @api private
       */
      apiLoader: require_api_loader(),
      /**
       * @api private
       */
      EndpointCache: require_endpoint_cache().EndpointCache
    });
    require_sequential_executor();
    require_service();
    require_config();
    require_http();
    require_event_listeners();
    require_request();
    require_response();
    require_resource_waiter2();
    require_request_signer();
    require_param_validator();
    require_maintenance_mode_message();
    AWS2.events = new AWS2.SequentialExecutor();
    AWS2.util.memoizedProperty(AWS2, "endpointCache", function() {
      return new AWS2.EndpointCache(AWS2.config.endpointCacheSize);
    }, true);
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/uuid/dist/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/dist/rng-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/dist/bytesToUuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
    }
    var _default = bytesToUuid;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/v1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng_browser());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : (0, _bytesToUuid.default)(b);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function uuidToBytes(uuid) {
      var bytes = [];
      uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
        bytes.push(parseInt(hex, 16));
      });
      return bytes;
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      var bytes = new Array(str.length);
      for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL;
    function _default(name, version, hashfunc) {
      var generateUUID = function(value, namespace, buf, offset) {
        var off = buf && offset || 0;
        if (typeof value == "string")
          value = stringToBytes(value);
        if (typeof namespace == "string")
          namespace = uuidToBytes(namespace);
        if (!Array.isArray(value))
          throw TypeError("value must be an array of bytes");
        if (!Array.isArray(namespace) || namespace.length !== 16)
          throw TypeError("namespace must be uuid string or an Array of 16 byte values");
        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          for (var idx = 0; idx < 16; ++idx) {
            buf[off + idx] = bytes[idx];
          }
        }
        return buf || (0, _bytesToUuid.default)(bytes);
      };
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/md5-browser.js
var require_md5_browser = __commonJS({
  "node_modules/uuid/dist/md5-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes == "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = new Array(msg.length);
        for (var i = 0; i < msg.length; i++)
          bytes[i] = msg.charCodeAt(i);
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      var i;
      var x;
      var output = [];
      var length32 = input.length * 32;
      var hexTab = "0123456789abcdef";
      var hex;
      for (i = 0; i < length32; i += 8) {
        x = input[i >> 5] >>> i % 32 & 255;
        hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var i;
      var olda;
      var oldb;
      var oldc;
      var oldd;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function bytesToWords(input) {
      var i;
      var output = [];
      output[(input.length >> 2) - 1] = void 0;
      for (i = 0; i < output.length; i += 1) {
        output[i] = 0;
      }
      var length8 = input.length * 8;
      for (i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    function safeAdd(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v3.js
var require_v32 = __commonJS({
  "node_modules/uuid/dist/v3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5_browser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v4.js
var require_v42 = __commonJS({
  "node_modules/uuid/dist/v4.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng_browser());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || (0, _bytesToUuid.default)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/sha1-browser.js
var require_sha1_browser = __commonJS({
  "node_modules/uuid/dist/sha1-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z;
        case 1:
          return x ^ y ^ z;
        case 2:
          return x & y ^ x & z ^ y & z;
        case 3:
          return x ^ y ^ z;
      }
    }
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    function sha1(bytes) {
      var K = [1518500249, 1859775393, 2400959708, 3395469782];
      var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes == "string") {
        var msg = unescape(encodeURIComponent(bytes));
        bytes = new Array(msg.length);
        for (var i = 0; i < msg.length; i++)
          bytes[i] = msg.charCodeAt(i);
      }
      bytes.push(128);
      var l = bytes.length / 4 + 2;
      var N = Math.ceil(l / 16);
      var M = new Array(N);
      for (var i = 0; i < N; i++) {
        M[i] = new Array(16);
        for (var j = 0; j < 16; j++) {
          M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (var i = 0; i < N; i++) {
        var W = new Array(80);
        for (var t = 0; t < 16; t++)
          W[t] = M[i][t];
        for (var t = 16; t < 80; t++) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];
        for (var t = 0; t < 80; t++) {
          var s = Math.floor(t / 20);
          var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
          e = d;
          d = c;
          c = ROTL(b, 30) >>> 0;
          b = a;
          a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/v5.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1_browser());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/uuid/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v32());
    var _v3 = _interopRequireDefault(require_v42());
    var _v4 = _interopRequireDefault(require_v5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/aws-sdk/lib/util.js
var require_util2 = __commonJS({
  "node_modules/aws-sdk/lib/util.js"(exports, module) {
    var AWS2;
    var util = {
      environment: "nodejs",
      engine: function engine() {
        if (util.isBrowser() && typeof navigator !== "undefined") {
          return navigator.userAgent;
        } else {
          var engine2 = process.platform + "/" + process.version;
          if (process.env.AWS_EXECUTION_ENV) {
            engine2 += " exec-env/" + process.env.AWS_EXECUTION_ENV;
          }
          return engine2;
        }
      },
      userAgent: function userAgent() {
        var name = util.environment;
        var agent = "aws-sdk-" + name + "/" + require_core().VERSION;
        if (name === "nodejs")
          agent += " " + util.engine();
        return agent;
      },
      uriEscape: function uriEscape(string) {
        var output = encodeURIComponent(string);
        output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);
        output = output.replace(/[*]/g, function(ch) {
          return "%" + ch.charCodeAt(0).toString(16).toUpperCase();
        });
        return output;
      },
      uriEscapePath: function uriEscapePath(string) {
        var parts = [];
        util.arrayEach(string.split("/"), function(part) {
          parts.push(util.uriEscape(part));
        });
        return parts.join("/");
      },
      urlParse: function urlParse(url) {
        return util.url.parse(url);
      },
      urlFormat: function urlFormat(url) {
        return util.url.format(url);
      },
      queryStringParse: function queryStringParse(qs) {
        return util.querystring.parse(qs);
      },
      queryParamsToString: function queryParamsToString(params) {
        var items = [];
        var escape2 = util.uriEscape;
        var sortedKeys = Object.keys(params).sort();
        util.arrayEach(sortedKeys, function(name) {
          var value = params[name];
          var ename = escape2(name);
          var result = ename + "=";
          if (Array.isArray(value)) {
            var vals = [];
            util.arrayEach(value, function(item) {
              vals.push(escape2(item));
            });
            result = ename + "=" + vals.sort().join("&" + ename + "=");
          } else if (value !== void 0 && value !== null) {
            result = ename + "=" + escape2(value);
          }
          items.push(result);
        });
        return items.join("&");
      },
      readFileSync: function readFileSync(path) {
        if (util.isBrowser())
          return null;
        return require_fs().readFileSync(path, "utf-8");
      },
      base64: {
        encode: function encode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 encode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          var buf = util.buffer.toBuffer(string);
          return buf.toString("base64");
        },
        decode: function decode64(string) {
          if (typeof string === "number") {
            throw util.error(new Error("Cannot base64 decode number " + string));
          }
          if (string === null || typeof string === "undefined") {
            return string;
          }
          return util.buffer.toBuffer(string, "base64");
        }
      },
      buffer: {
        /**
         * Buffer constructor for Node buffer and buffer pollyfill
         */
        toBuffer: function(data, encoding) {
          return typeof util.Buffer.from === "function" && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
        },
        alloc: function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new Error("size passed to alloc must be a number.");
          }
          if (typeof util.Buffer.alloc === "function") {
            return util.Buffer.alloc(size, fill, encoding);
          } else {
            var buf = new util.Buffer(size);
            if (fill !== void 0 && typeof buf.fill === "function") {
              buf.fill(fill, void 0, void 0, encoding);
            }
            return buf;
          }
        },
        toStream: function toStream(buffer) {
          if (!util.Buffer.isBuffer(buffer))
            buffer = util.buffer.toBuffer(buffer);
          var readable = new util.stream.Readable();
          var pos = 0;
          readable._read = function(size) {
            if (pos >= buffer.length)
              return readable.push(null);
            var end = pos + size;
            if (end > buffer.length)
              end = buffer.length;
            readable.push(buffer.slice(pos, end));
            pos = end;
          };
          return readable;
        },
        /**
         * Concatenates a list of Buffer objects.
         */
        concat: function(buffers) {
          var length = 0, offset = 0, buffer = null, i;
          for (i = 0; i < buffers.length; i++) {
            length += buffers[i].length;
          }
          buffer = util.buffer.alloc(length);
          for (i = 0; i < buffers.length; i++) {
            buffers[i].copy(buffer, offset);
            offset += buffers[i].length;
          }
          return buffer;
        }
      },
      string: {
        byteLength: function byteLength(string) {
          if (string === null || string === void 0)
            return 0;
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          if (typeof string.byteLength === "number") {
            return string.byteLength;
          } else if (typeof string.length === "number") {
            return string.length;
          } else if (typeof string.size === "number") {
            return string.size;
          } else if (typeof string.path === "string") {
            return require_fs().lstatSync(string.path).size;
          } else {
            throw util.error(
              new Error("Cannot determine length of " + string),
              { object: string }
            );
          }
        },
        upperFirst: function upperFirst(string) {
          return string[0].toUpperCase() + string.substr(1);
        },
        lowerFirst: function lowerFirst(string) {
          return string[0].toLowerCase() + string.substr(1);
        }
      },
      ini: {
        parse: function string(ini) {
          var currentSection, map = {};
          util.arrayEach(ini.split(/\r?\n/), function(line) {
            line = line.split(/(^|\s)[;#]/)[0].trim();
            var isSection = line[0] === "[" && line[line.length - 1] === "]";
            if (isSection) {
              currentSection = line.substring(1, line.length - 1);
              if (currentSection === "__proto__" || currentSection.split(/\s/)[1] === "__proto__") {
                throw util.error(
                  new Error("Cannot load profile name '" + currentSection + "' from shared ini file.")
                );
              }
            } else if (currentSection) {
              var indexOfEqualsSign = line.indexOf("=");
              var start = 0;
              var end = line.length - 1;
              var isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
              if (isAssignment) {
                var name = line.substring(0, indexOfEqualsSign).trim();
                var value = line.substring(indexOfEqualsSign + 1).trim();
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
              }
            }
          });
          return map;
        }
      },
      fn: {
        noop: function() {
        },
        callback: function(err) {
          if (err)
            throw err;
        },
        /**
         * Turn a synchronous function into as "async" function by making it call
         * a callback. The underlying function is called with all but the last argument,
         * which is treated as the callback. The callback is passed passed a first argument
         * of null on success to mimick standard node callbacks.
         */
        makeAsync: function makeAsync(fn, expectedArgs) {
          if (expectedArgs && expectedArgs <= fn.length) {
            return fn;
          }
          return function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            var result = fn.apply(null, args);
            callback(result);
          };
        }
      },
      /**
       * Date and time utility functions.
       */
      date: {
        /**
         * @return [Date] the current JavaScript date object. Since all
         *   AWS services rely on this date object, you can override
         *   this function to provide a special time value to AWS service
         *   requests.
         */
        getDate: function getDate() {
          if (!AWS2)
            AWS2 = require_core();
          if (AWS2.config.systemClockOffset) {
            return new Date((/* @__PURE__ */ new Date()).getTime() + AWS2.config.systemClockOffset);
          } else {
            return /* @__PURE__ */ new Date();
          }
        },
        /**
         * @return [String] the date in ISO-8601 format
         */
        iso8601: function iso8601(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toISOString().replace(/\.\d{3}Z$/, "Z");
        },
        /**
         * @return [String] the date in RFC 822 format
         */
        rfc822: function rfc822(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.toUTCString();
        },
        /**
         * @return [Integer] the UNIX timestamp value for the current time
         */
        unixTimestamp: function unixTimestamp(date) {
          if (date === void 0) {
            date = util.date.getDate();
          }
          return date.getTime() / 1e3;
        },
        /**
         * @param [String,number,Date] date
         * @return [Date]
         */
        from: function format(date) {
          if (typeof date === "number") {
            return new Date(date * 1e3);
          } else {
            return new Date(date);
          }
        },
        /**
         * Given a Date or date-like value, this function formats the
         * date into a string of the requested value.
         * @param [String,number,Date] date
         * @param [String] formatter Valid formats are:
         #   * 'iso8601'
         #   * 'rfc822'
         #   * 'unixTimestamp'
         * @return [String]
         */
        format: function format(date, formatter) {
          if (!formatter)
            formatter = "iso8601";
          return util.date[formatter](util.date.from(date));
        },
        parseTimestamp: function parseTimestamp(value) {
          if (typeof value === "number") {
            return new Date(value * 1e3);
          } else if (value.match(/^\d+$/)) {
            return new Date(value * 1e3);
          } else if (value.match(/^\d{4}/)) {
            return new Date(value);
          } else if (value.match(/^\w{3},/)) {
            return new Date(value);
          } else {
            throw util.error(
              new Error("unhandled timestamp format: " + value),
              { code: "TimestampParserError" }
            );
          }
        }
      },
      crypto: {
        crc32Table: [
          0,
          1996959894,
          3993919788,
          2567524794,
          124634137,
          1886057615,
          3915621685,
          2657392035,
          249268274,
          2044508324,
          3772115230,
          2547177864,
          162941995,
          2125561021,
          3887607047,
          2428444049,
          498536548,
          1789927666,
          4089016648,
          2227061214,
          450548861,
          1843258603,
          4107580753,
          2211677639,
          325883990,
          1684777152,
          4251122042,
          2321926636,
          335633487,
          1661365465,
          4195302755,
          2366115317,
          997073096,
          1281953886,
          3579855332,
          2724688242,
          1006888145,
          1258607687,
          3524101629,
          2768942443,
          901097722,
          1119000684,
          3686517206,
          2898065728,
          853044451,
          1172266101,
          3705015759,
          2882616665,
          651767980,
          1373503546,
          3369554304,
          3218104598,
          565507253,
          1454621731,
          3485111705,
          3099436303,
          671266974,
          1594198024,
          3322730930,
          2970347812,
          795835527,
          1483230225,
          3244367275,
          3060149565,
          1994146192,
          31158534,
          2563907772,
          4023717930,
          1907459465,
          112637215,
          2680153253,
          3904427059,
          2013776290,
          251722036,
          2517215374,
          3775830040,
          2137656763,
          141376813,
          2439277719,
          3865271297,
          1802195444,
          476864866,
          2238001368,
          4066508878,
          1812370925,
          453092731,
          2181625025,
          4111451223,
          1706088902,
          314042704,
          2344532202,
          4240017532,
          1658658271,
          366619977,
          2362670323,
          4224994405,
          1303535960,
          984961486,
          2747007092,
          3569037538,
          1256170817,
          1037604311,
          2765210733,
          3554079995,
          1131014506,
          879679996,
          2909243462,
          3663771856,
          1141124467,
          855842277,
          2852801631,
          3708648649,
          1342533948,
          654459306,
          3188396048,
          3373015174,
          1466479909,
          544179635,
          3110523913,
          3462522015,
          1591671054,
          702138776,
          2966460450,
          3352799412,
          1504918807,
          783551873,
          3082640443,
          3233442989,
          3988292384,
          2596254646,
          62317068,
          1957810842,
          3939845945,
          2647816111,
          81470997,
          1943803523,
          3814918930,
          2489596804,
          225274430,
          2053790376,
          3826175755,
          2466906013,
          167816743,
          2097651377,
          4027552580,
          2265490386,
          503444072,
          1762050814,
          4150417245,
          2154129355,
          426522225,
          1852507879,
          4275313526,
          2312317920,
          282753626,
          1742555852,
          4189708143,
          2394877945,
          397917763,
          1622183637,
          3604390888,
          2714866558,
          953729732,
          1340076626,
          3518719985,
          2797360999,
          1068828381,
          1219638859,
          3624741850,
          2936675148,
          906185462,
          1090812512,
          3747672003,
          2825379669,
          829329135,
          1181335161,
          3412177804,
          3160834842,
          628085408,
          1382605366,
          3423369109,
          3138078467,
          570562233,
          1426400815,
          3317316542,
          2998733608,
          733239954,
          1555261956,
          3268935591,
          3050360625,
          752459403,
          1541320221,
          2607071920,
          3965973030,
          1969922972,
          40735498,
          2617837225,
          3943577151,
          1913087877,
          83908371,
          2512341634,
          3803740692,
          2075208622,
          213261112,
          2463272603,
          3855990285,
          2094854071,
          198958881,
          2262029012,
          4057260610,
          1759359992,
          534414190,
          2176718541,
          4139329115,
          1873836001,
          414664567,
          2282248934,
          4279200368,
          1711684554,
          285281116,
          2405801727,
          4167216745,
          1634467795,
          376229701,
          2685067896,
          3608007406,
          1308918612,
          956543938,
          2808555105,
          3495958263,
          1231636301,
          1047427035,
          2932959818,
          3654703836,
          1088359270,
          936918e3,
          2847714899,
          3736837829,
          1202900863,
          817233897,
          3183342108,
          3401237130,
          1404277552,
          615818150,
          3134207493,
          3453421203,
          1423857449,
          601450431,
          3009837614,
          3294710456,
          1567103746,
          711928724,
          3020668471,
          3272380065,
          1510334235,
          755167117
        ],
        crc32: function crc32(data) {
          var tbl = util.crypto.crc32Table;
          var crc = 0 ^ -1;
          if (typeof data === "string") {
            data = util.buffer.toBuffer(data);
          }
          for (var i = 0; i < data.length; i++) {
            var code = data.readUInt8(i);
            crc = crc >>> 8 ^ tbl[(crc ^ code) & 255];
          }
          return (crc ^ -1) >>> 0;
        },
        hmac: function hmac(key, string, digest, fn) {
          if (!digest)
            digest = "binary";
          if (digest === "buffer") {
            digest = void 0;
          }
          if (!fn)
            fn = "sha256";
          if (typeof string === "string")
            string = util.buffer.toBuffer(string);
          return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
        },
        md5: function md5(data, digest, callback) {
          return util.crypto.hash("md5", data, digest, callback);
        },
        sha256: function sha256(data, digest, callback) {
          return util.crypto.hash("sha256", data, digest, callback);
        },
        hash: function(algorithm, data, digest, callback) {
          var hash = util.crypto.createHash(algorithm);
          if (!digest) {
            digest = "binary";
          }
          if (digest === "buffer") {
            digest = void 0;
          }
          if (typeof data === "string")
            data = util.buffer.toBuffer(data);
          var sliceFn = util.arraySliceFn(data);
          var isBuffer = util.Buffer.isBuffer(data);
          if (util.isBrowser() && typeof ArrayBuffer !== "undefined" && data && data.buffer instanceof ArrayBuffer)
            isBuffer = true;
          if (callback && typeof data === "object" && typeof data.on === "function" && !isBuffer) {
            data.on("data", function(chunk) {
              hash.update(chunk);
            });
            data.on("error", function(err) {
              callback(err);
            });
            data.on("end", function() {
              callback(null, hash.digest(digest));
            });
          } else if (callback && sliceFn && !isBuffer && typeof FileReader !== "undefined") {
            var index = 0, size = 1024 * 512;
            var reader = new FileReader();
            reader.onerror = function() {
              callback(new Error("Failed to read data."));
            };
            reader.onload = function() {
              var buf = new util.Buffer(new Uint8Array(reader.result));
              hash.update(buf);
              index += buf.length;
              reader._continueReading();
            };
            reader._continueReading = function() {
              if (index >= data.size) {
                callback(null, hash.digest(digest));
                return;
              }
              var back = index + size;
              if (back > data.size)
                back = data.size;
              reader.readAsArrayBuffer(sliceFn.call(data, index, back));
            };
            reader._continueReading();
          } else {
            if (util.isBrowser() && typeof data === "object" && !isBuffer) {
              data = new util.Buffer(new Uint8Array(data));
            }
            var out = hash.update(data).digest(digest);
            if (callback)
              callback(null, out);
            return out;
          }
        },
        toHex: function toHex(data) {
          var out = [];
          for (var i = 0; i < data.length; i++) {
            out.push(("0" + data.charCodeAt(i).toString(16)).substr(-2, 2));
          }
          return out.join("");
        },
        createHash: function createHash(algorithm) {
          return util.crypto.lib.createHash(algorithm);
        }
      },
      /** @!ignore */
      /* Abort constant */
      abort: {},
      each: function each(object, iterFunction) {
        for (var key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            var ret = iterFunction.call(this, key, object[key]);
            if (ret === util.abort)
              break;
          }
        }
      },
      arrayEach: function arrayEach(array, iterFunction) {
        for (var idx in array) {
          if (Object.prototype.hasOwnProperty.call(array, idx)) {
            var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
            if (ret === util.abort)
              break;
          }
        }
      },
      update: function update(obj1, obj2) {
        util.each(obj2, function iterator(key, item) {
          obj1[key] = item;
        });
        return obj1;
      },
      merge: function merge(obj1, obj2) {
        return util.update(util.copy(obj1), obj2);
      },
      copy: function copy(object) {
        if (object === null || object === void 0)
          return object;
        var dupe = {};
        for (var key in object) {
          dupe[key] = object[key];
        }
        return dupe;
      },
      isEmpty: function isEmpty(obj) {
        for (var prop in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, prop)) {
            return false;
          }
        }
        return true;
      },
      arraySliceFn: function arraySliceFn(obj) {
        var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
        return typeof fn === "function" ? fn : null;
      },
      isType: function isType(obj, type) {
        if (typeof type === "function")
          type = util.typeName(type);
        return Object.prototype.toString.call(obj) === "[object " + type + "]";
      },
      typeName: function typeName(type) {
        if (Object.prototype.hasOwnProperty.call(type, "name"))
          return type.name;
        var str = type.toString();
        var match = str.match(/^\s*function (.+)\(/);
        return match ? match[1] : str;
      },
      error: function error(err, options) {
        var originalError = null;
        if (typeof err.message === "string" && err.message !== "") {
          if (typeof options === "string" || options && options.message) {
            originalError = util.copy(err);
            originalError.message = err.message;
          }
        }
        err.message = err.message || null;
        if (typeof options === "string") {
          err.message = options;
        } else if (typeof options === "object" && options !== null) {
          util.update(err, options);
          if (options.message)
            err.message = options.message;
          if (options.code || options.name)
            err.code = options.code || options.name;
          if (options.stack)
            err.stack = options.stack;
        }
        if (typeof Object.defineProperty === "function") {
          Object.defineProperty(err, "name", { writable: true, enumerable: false });
          Object.defineProperty(err, "message", { enumerable: true });
        }
        err.name = String(options && options.name || err.name || err.code || "Error");
        err.time = /* @__PURE__ */ new Date();
        if (originalError) {
          err.originalError = originalError;
        }
        for (var key in options || {}) {
          if (key[0] === "[" && key[key.length - 1] === "]") {
            key = key.slice(1, -1);
            if (key === "code" || key === "message") {
              continue;
            }
            err["[" + key + "]"] = "See error." + key + " for details.";
            Object.defineProperty(err, key, {
              value: err[key] || options && options[key] || originalError && originalError[key],
              enumerable: false,
              writable: true
            });
          }
        }
        return err;
      },
      /**
       * @api private
       */
      inherit: function inherit(klass, features) {
        var newObject = null;
        if (features === void 0) {
          features = klass;
          klass = Object;
          newObject = {};
        } else {
          var ctor = function ConstructorWrapper() {
          };
          ctor.prototype = klass.prototype;
          newObject = new ctor();
        }
        if (features.constructor === Object) {
          features.constructor = function() {
            if (klass !== Object) {
              return klass.apply(this, arguments);
            }
          };
        }
        features.constructor.prototype = newObject;
        util.update(features.constructor.prototype, features);
        features.constructor.__super__ = klass;
        return features.constructor;
      },
      /**
       * @api private
       */
      mixin: function mixin() {
        var klass = arguments[0];
        for (var i = 1; i < arguments.length; i++) {
          for (var prop in arguments[i].prototype) {
            var fn = arguments[i].prototype[prop];
            if (prop !== "constructor") {
              klass.prototype[prop] = fn;
            }
          }
        }
        return klass;
      },
      /**
       * @api private
       */
      hideProperties: function hideProperties(obj, props) {
        if (typeof Object.defineProperty !== "function")
          return;
        util.arrayEach(props, function(key) {
          Object.defineProperty(obj, key, {
            enumerable: false,
            writable: true,
            configurable: true
          });
        });
      },
      /**
       * @api private
       */
      property: function property(obj, name, value, enumerable, isValue) {
        var opts = {
          configurable: true,
          enumerable: enumerable !== void 0 ? enumerable : true
        };
        if (typeof value === "function" && !isValue) {
          opts.get = value;
        } else {
          opts.value = value;
          opts.writable = true;
        }
        Object.defineProperty(obj, name, opts);
      },
      /**
       * @api private
       */
      memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
        var cachedValue = null;
        util.property(obj, name, function() {
          if (cachedValue === null) {
            cachedValue = get();
          }
          return cachedValue;
        }, enumerable);
      },
      /**
       * TODO Remove in major version revision
       * This backfill populates response data without the
       * top-level payload name.
       *
       * @api private
       */
      hoistPayloadMember: function hoistPayloadMember(resp) {
        var req = resp.request;
        var operationName = req.operation;
        var operation = req.service.api.operations[operationName];
        var output = operation.output;
        if (output.payload && !operation.hasEventOutput) {
          var payloadMember = output.members[output.payload];
          var responsePayload = resp.data[output.payload];
          if (payloadMember.type === "structure") {
            util.each(responsePayload, function(key, value) {
              util.property(resp.data, key, value, false);
            });
          }
        }
      },
      /**
       * Compute SHA-256 checksums of streams
       *
       * @api private
       */
      computeSha256: function computeSha256(body, done) {
        if (util.isNode()) {
          var Stream = util.stream.Stream;
          var fs = require_fs();
          if (typeof Stream === "function" && body instanceof Stream) {
            if (typeof body.path === "string") {
              var settings = {};
              if (typeof body.start === "number") {
                settings.start = body.start;
              }
              if (typeof body.end === "number") {
                settings.end = body.end;
              }
              body = fs.createReadStream(body.path, settings);
            } else {
              return done(new Error("Non-file stream objects are not supported with SigV4"));
            }
          }
        }
        util.crypto.sha256(body, "hex", function(err, sha) {
          if (err)
            done(err);
          else
            done(null, sha);
        });
      },
      /**
       * @api private
       */
      isClockSkewed: function isClockSkewed(serverTime) {
        if (serverTime) {
          util.property(
            AWS2.config,
            "isClockSkewed",
            Math.abs((/* @__PURE__ */ new Date()).getTime() - serverTime) >= 3e5,
            false
          );
          return AWS2.config.isClockSkewed;
        }
      },
      applyClockOffset: function applyClockOffset(serverTime) {
        if (serverTime)
          AWS2.config.systemClockOffset = serverTime - (/* @__PURE__ */ new Date()).getTime();
      },
      /**
       * @api private
       */
      extractRequestId: function extractRequestId(resp) {
        var requestId = resp.httpResponse.headers["x-amz-request-id"] || resp.httpResponse.headers["x-amzn-requestid"];
        if (!requestId && resp.data && resp.data.ResponseMetadata) {
          requestId = resp.data.ResponseMetadata.RequestId;
        }
        if (requestId) {
          resp.requestId = requestId;
        }
        if (resp.error) {
          resp.error.requestId = requestId;
        }
      },
      /**
       * @api private
       */
      addPromises: function addPromises(constructors, PromiseDependency) {
        var deletePromises = false;
        if (PromiseDependency === void 0 && AWS2 && AWS2.config) {
          PromiseDependency = AWS2.config.getPromisesDependency();
        }
        if (PromiseDependency === void 0 && typeof Promise !== "undefined") {
          PromiseDependency = Promise;
        }
        if (typeof PromiseDependency !== "function")
          deletePromises = true;
        if (!Array.isArray(constructors))
          constructors = [constructors];
        for (var ind = 0; ind < constructors.length; ind++) {
          var constructor = constructors[ind];
          if (deletePromises) {
            if (constructor.deletePromisesFromClass) {
              constructor.deletePromisesFromClass();
            }
          } else if (constructor.addPromisesToClass) {
            constructor.addPromisesToClass(PromiseDependency);
          }
        }
      },
      /**
       * @api private
       * Return a function that will return a promise whose fate is decided by the
       * callback behavior of the given method with `methodName`. The method to be
       * promisified should conform to node.js convention of accepting a callback as
       * last argument and calling that callback with error as the first argument
       * and success value on the second argument.
       */
      promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
        return function promise() {
          var self = this;
          var args = Array.prototype.slice.call(arguments);
          return new PromiseDependency(function(resolve, reject) {
            args.push(function(err, data) {
              if (err) {
                reject(err);
              } else {
                resolve(data);
              }
            });
            self[methodName].apply(self, args);
          });
        };
      },
      /**
       * @api private
       */
      isDualstackAvailable: function isDualstackAvailable(service) {
        if (!service)
          return false;
        var metadata = require_metadata();
        if (typeof service !== "string")
          service = service.serviceIdentifier;
        if (typeof service !== "string" || !metadata.hasOwnProperty(service))
          return false;
        return !!metadata[service].dualstackAvailable;
      },
      /**
       * @api private
       */
      calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
        if (!retryDelayOptions)
          retryDelayOptions = {};
        var customBackoff = retryDelayOptions.customBackoff || null;
        if (typeof customBackoff === "function") {
          return customBackoff(retryCount, err);
        }
        var base = typeof retryDelayOptions.base === "number" ? retryDelayOptions.base : 100;
        var delay = Math.random() * (Math.pow(2, retryCount) * base);
        return delay;
      },
      /**
       * @api private
       */
      handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
        if (!options)
          options = {};
        var http = AWS2.HttpClient.getInstance();
        var httpOptions = options.httpOptions || {};
        var retryCount = 0;
        var errCallback = function(err) {
          var maxRetries = options.maxRetries || 0;
          if (err && err.code === "TimeoutError")
            err.retryable = true;
          if (err && err.retryable && retryCount < maxRetries) {
            var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
            if (delay >= 0) {
              retryCount++;
              setTimeout(sendRequest, delay + (err.retryAfter || 0));
              return;
            }
          }
          cb(err);
        };
        var sendRequest = function() {
          var data = "";
          http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
            httpResponse.on("data", function(chunk) {
              data += chunk.toString();
            });
            httpResponse.on("end", function() {
              var statusCode = httpResponse.statusCode;
              if (statusCode < 300) {
                cb(null, data);
              } else {
                var retryAfter = parseInt(httpResponse.headers["retry-after"], 10) * 1e3 || 0;
                var err = util.error(
                  new Error(),
                  {
                    statusCode,
                    retryable: statusCode >= 500 || statusCode === 429
                  }
                );
                if (retryAfter && err.retryable)
                  err.retryAfter = retryAfter;
                errCallback(err);
              }
            });
          }, errCallback);
        };
        AWS2.util.defer(sendRequest);
      },
      /**
       * @api private
       */
      uuid: {
        v4: function uuidV4() {
          return require_dist().v4();
        }
      },
      /**
       * @api private
       */
      convertPayloadToString: function convertPayloadToString(resp) {
        var req = resp.request;
        var operation = req.operation;
        var rules = req.service.api.operations[operation].output || {};
        if (rules.payload && resp.data[rules.payload]) {
          resp.data[rules.payload] = resp.data[rules.payload].toString();
        }
      },
      /**
       * @api private
       */
      defer: function defer(callback) {
        if (typeof process === "object" && typeof process.nextTick === "function") {
          process.nextTick(callback);
        } else if (typeof setImmediate === "function") {
          setImmediate(callback);
        } else {
          setTimeout(callback, 0);
        }
      },
      /**
       * @api private
       */
      getRequestPayloadShape: function getRequestPayloadShape(req) {
        var operations = req.service.api.operations;
        if (!operations)
          return void 0;
        var operation = (operations || {})[req.operation];
        if (!operation || !operation.input || !operation.input.payload)
          return void 0;
        return operation.input.members[operation.input.payload];
      },
      getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
        var profiles = {};
        var profilesFromConfig = {};
        if (process.env[util.configOptInEnv]) {
          var profilesFromConfig = iniLoader.loadFrom({
            isConfig: true,
            filename: process.env[util.sharedConfigFileEnv]
          });
        }
        var profilesFromCreds = {};
        try {
          var profilesFromCreds = iniLoader.loadFrom({
            filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]
          });
        } catch (error) {
          if (!process.env[util.configOptInEnv])
            throw error;
        }
        for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
        }
        for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
          profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
        }
        return profiles;
        function objectAssign(target, source) {
          for (var i2 = 0, keys = Object.keys(source); i2 < keys.length; i2++) {
            target[keys[i2]] = source[keys[i2]];
          }
          return target;
        }
      },
      /**
       * @api private
       */
      ARN: {
        validate: function validateARN(str) {
          return str && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
        },
        parse: function parseARN(arn) {
          var matched = arn.split(":");
          return {
            partition: matched[1],
            service: matched[2],
            region: matched[3],
            accountId: matched[4],
            resource: matched.slice(5).join(":")
          };
        },
        build: function buildARN(arnObject) {
          if (arnObject.service === void 0 || arnObject.region === void 0 || arnObject.accountId === void 0 || arnObject.resource === void 0)
            throw util.error(new Error("Input ARN object is invalid"));
          return "arn:" + (arnObject.partition || "aws") + ":" + arnObject.service + ":" + arnObject.region + ":" + arnObject.accountId + ":" + arnObject.resource;
        }
      },
      /**
       * @api private
       */
      defaultProfile: "default",
      /**
       * @api private
       */
      configOptInEnv: "AWS_SDK_LOAD_CONFIG",
      /**
       * @api private
       */
      sharedCredentialsFileEnv: "AWS_SHARED_CREDENTIALS_FILE",
      /**
       * @api private
       */
      sharedConfigFileEnv: "AWS_CONFIG_FILE",
      /**
       * @api private
       */
      imdsDisabledEnv: "AWS_EC2_METADATA_DISABLED"
    };
    module.exports = util;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var isArray = require_isarray();
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
    exports.kMaxLength = kMaxLength();
    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } };
        return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0;
      } catch (e) {
        return false;
      }
    }
    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError("Invalid typed array length");
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        that = new Uint8Array(length);
        that.__proto__ = Buffer.prototype;
      } else {
        if (that === null) {
          that = new Buffer(length);
        }
        that.length = length;
      }
      return that;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length);
      }
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new Error(
            "If encoding is specified then the first argument must be a string"
          );
        }
        return allocUnsafe(this, arg);
      }
      return from(this, arg, encodingOrOffset, length);
    }
    Buffer.poolSize = 8192;
    Buffer._augment = function(arr) {
      arr.__proto__ = Buffer.prototype;
      return arr;
    };
    function from(that, value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(that, value, encodingOrOffset);
      }
      return fromObject(that, value);
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      Buffer.__proto__ = Uint8Array;
      if (typeof Symbol !== "undefined" && Symbol.species && Buffer[Symbol.species] === Buffer) {
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        });
      }
    }
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }
    function alloc(that, size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(that, size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
      }
      return createBuffer(that, size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(null, size, fill, encoding);
    };
    function allocUnsafe(that, size) {
      assertSize(size);
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0;
        }
      }
      return that;
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    function fromString(that, string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      var length = byteLength(string, encoding) | 0;
      that = createBuffer(that, length);
      var actual = that.write(string, encoding);
      if (actual !== length) {
        that = that.slice(0, actual);
      }
      return that;
    }
    function fromArrayLike(that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      that = createBuffer(that, length);
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255;
      }
      return that;
    }
    function fromArrayBuffer(that, array, byteOffset, length) {
      array.byteLength;
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError("'length' is out of bounds");
      }
      if (byteOffset === void 0 && length === void 0) {
        array = new Uint8Array(array);
      } else if (length === void 0) {
        array = new Uint8Array(array, byteOffset);
      } else {
        array = new Uint8Array(array, byteOffset, length);
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        that = array;
        that.__proto__ = Buffer.prototype;
      } else {
        that = fromArrayLike(that, array);
      }
      return that;
    }
    function fromObject(that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        that = createBuffer(that, len);
        if (that.length === 0) {
          return that;
        }
        obj.copy(that, 0, 0, len);
        return that;
      }
      if (obj) {
        if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
          if (typeof obj.length !== "number" || isnan(obj.length)) {
            return createBuffer(that, 0);
          }
          return fromArrayLike(that, obj);
        }
        if (obj.type === "Buffer" && isArray(obj.data)) {
          return fromArrayLike(that, obj.data);
        }
      }
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }
    function checked(length) {
      if (length >= kMaxLength()) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return !!(b != null && b._isBuffer);
    };
    Buffer.compare = function compare(a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        string = "" + string;
      }
      var len = string.length;
      if (len === 0)
        return 0;
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
          case void 0:
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase)
              return utf8ToBytes(string).length;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      var loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === 0;
    };
    Buffer.prototype.inspect = function inspect() {
      var str = "";
      var max = exports.INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      var i;
      if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          var found = true;
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      var strLen = string.length;
      if (strLen % 2 !== 0)
        throw new TypeError("Invalid hex string");
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (isNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;
      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      var res = "";
      var i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      var ret = "";
      end = Math.min(buf.length, end);
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      var out = "";
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = "";
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0)
        value = 65535 + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
      }
    }
    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0)
        value = 4294967295 + value + 1;
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
      }
    }
    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = stringtrim(str).replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function stringtrim(str) {
      if (str.trim)
        return str.trim();
      return str.replace(/^\s+|\s+$/g, "");
    }
    function toHex(n) {
      if (n < 16)
        return "0" + n.toString(16);
      return n.toString(16);
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isnan(val) {
      return val !== val;
    }
  }
});

// node_modules/aws-sdk/lib/browserHashUtils.js
var require_browserHashUtils = __commonJS({
  "node_modules/aws-sdk/lib/browserHashUtils.js"(exports, module) {
    var Buffer = require_buffer().Buffer;
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "undefined") {
      ArrayBuffer.isView = function(arg) {
        return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
      };
    }
    var viewStrings = [
      "[object Int8Array]",
      "[object Uint8Array]",
      "[object Uint8ClampedArray]",
      "[object Int16Array]",
      "[object Uint16Array]",
      "[object Int32Array]",
      "[object Uint32Array]",
      "[object Float32Array]",
      "[object Float64Array]",
      "[object DataView]"
    ];
    function isEmptyData(data) {
      if (typeof data === "string") {
        return data.length === 0;
      }
      return data.byteLength === 0;
    }
    function convertToBuffer(data) {
      if (typeof data === "string") {
        data = new Buffer(data, "utf8");
      }
      if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data);
    }
    module.exports = exports = {
      isEmptyData,
      convertToBuffer
    };
  }
});

// node_modules/aws-sdk/lib/browserHmac.js
var require_browserHmac = __commonJS({
  "node_modules/aws-sdk/lib/browserHmac.js"(exports, module) {
    var hashUtils = require_browserHashUtils();
    function Hmac(hashCtor, secret) {
      this.hash = new hashCtor();
      this.outer = new hashCtor();
      var inner = bufferFromSecret(hashCtor, secret);
      var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
      outer.set(inner);
      for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
        inner[i] ^= 54;
        outer[i] ^= 92;
      }
      this.hash.update(inner);
      this.outer.update(outer);
      for (var i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
      }
    }
    module.exports = exports = Hmac;
    Hmac.prototype.update = function(toHash) {
      if (hashUtils.isEmptyData(toHash) || this.error) {
        return this;
      }
      try {
        this.hash.update(hashUtils.convertToBuffer(toHash));
      } catch (e) {
        this.error = e;
      }
      return this;
    };
    Hmac.prototype.digest = function(encoding) {
      if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
      }
      return this.outer.digest(encoding);
    };
    function bufferFromSecret(hashCtor, secret) {
      var input = hashUtils.convertToBuffer(secret);
      if (input.byteLength > hashCtor.BLOCK_SIZE) {
        var bufferHash = new hashCtor();
        bufferHash.update(input);
        input = bufferHash.digest();
      }
      var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
      buffer.set(input);
      return buffer;
    }
  }
});

// node_modules/aws-sdk/lib/browserMd5.js
var require_browserMd5 = __commonJS({
  "node_modules/aws-sdk/lib/browserMd5.js"(exports, module) {
    var hashUtils = require_browserHashUtils();
    var Buffer = require_buffer().Buffer;
    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 16;
    function Md5() {
      this.state = [
        1732584193,
        4023233417,
        2562383102,
        271733878
      ];
      this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
    module.exports = exports = Md5;
    Md5.BLOCK_SIZE = BLOCK_SIZE;
    Md5.prototype.update = function(sourceData) {
      if (hashUtils.isEmptyData(sourceData)) {
        return this;
      } else if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      var data = hashUtils.convertToBuffer(sourceData);
      var position = 0;
      var byteLength = data.byteLength;
      this.bytesHashed += byteLength;
      while (byteLength > 0) {
        this.buffer.setUint8(this.bufferLength++, data[position++]);
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }
      return this;
    };
    Md5.prototype.digest = function(encoding) {
      if (!this.finished) {
        var _a = this, buffer = _a.buffer, undecoratedLength = _a.bufferLength, bytesHashed = _a.bytesHashed;
        var bitsHashed = bytesHashed * 8;
        buffer.setUint8(this.bufferLength++, 128);
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
            buffer.setUint8(i, 0);
          }
          this.hashBuffer();
          this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
          buffer.setUint8(i, 0);
        }
        buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
        buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 4294967296), true);
        this.hashBuffer();
        this.finished = true;
      }
      var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
      for (var i = 0; i < 4; i++) {
        out.setUint32(i * 4, this.state[i], true);
      }
      var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
      return encoding ? buff.toString(encoding) : buff;
    };
    Md5.prototype.hashBuffer = function() {
      var _a = this, buffer = _a.buffer, state = _a.state;
      var a = state[0], b = state[1], c = state[2], d = state[3];
      a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 3614090360);
      d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 3905402710);
      c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 606105819);
      b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 3250441966);
      a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 4118548399);
      d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 1200080426);
      c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 2821735955);
      b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 4249261313);
      a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 1770035416);
      d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 2336552879);
      c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 4294925233);
      b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 2304563134);
      a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 1804603682);
      d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 4254626195);
      c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 2792965006);
      b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 1236535329);
      a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 4129170786);
      d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 3225465664);
      c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 643717713);
      b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 3921069994);
      a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 3593408605);
      d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 38016083);
      c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 3634488961);
      b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 3889429448);
      a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 568446438);
      d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 3275163606);
      c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 4107603335);
      b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 1163531501);
      a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 2850285829);
      d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 4243563512);
      c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 1735328473);
      b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 2368359562);
      a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 4294588738);
      d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 2272392833);
      c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 1839030562);
      b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 4259657740);
      a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 2763975236);
      d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 1272893353);
      c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 4139469664);
      b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 3200236656);
      a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 681279174);
      d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 3936430074);
      c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 3572445317);
      b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 76029189);
      a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 3654602809);
      d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 3873151461);
      c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 530742520);
      b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 3299628645);
      a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 4096336452);
      d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 1126891415);
      c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 2878612391);
      b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 4237533241);
      a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 1700485571);
      d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 2399980690);
      c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 4293915773);
      b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 2240044497);
      a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 1873313359);
      d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 4264355552);
      c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 2734768916);
      b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 1309151649);
      a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 4149444226);
      d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 3174756917);
      c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 718787259);
      b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 3951481745);
      state[0] = a + state[0] & 4294967295;
      state[1] = b + state[1] & 4294967295;
      state[2] = c + state[2] & 4294967295;
      state[3] = d + state[3] & 4294967295;
    };
    function cmn(q, a, b, x, s, t) {
      a = (a + q & 4294967295) + (x + t & 4294967295) & 4294967295;
      return (a << s | a >>> 32 - s) + b & 4294967295;
    }
    function ff(a, b, c, d, x, s, t) {
      return cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function gg(a, b, c, d, x, s, t) {
      return cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function hh(a, b, c, d, x, s, t) {
      return cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function ii(a, b, c, d, x, s, t) {
      return cmn(c ^ (b | ~d), a, b, x, s, t);
    }
  }
});

// node_modules/aws-sdk/lib/browserSha1.js
var require_browserSha1 = __commonJS({
  "node_modules/aws-sdk/lib/browserSha1.js"(exports, module) {
    var Buffer = require_buffer().Buffer;
    var hashUtils = require_browserHashUtils();
    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 20;
    var KEY = new Uint32Array([
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ]);
    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    function Sha1() {
      this.h0 = 1732584193;
      this.h1 = 4023233417;
      this.h2 = 2562383102;
      this.h3 = 271733878;
      this.h4 = 3285377520;
      this.block = new Uint32Array(80);
      this.offset = 0;
      this.shift = 24;
      this.totalLength = 0;
    }
    module.exports = exports = Sha1;
    Sha1.BLOCK_SIZE = BLOCK_SIZE;
    Sha1.prototype.update = function(data) {
      if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      if (hashUtils.isEmptyData(data)) {
        return this;
      }
      data = hashUtils.convertToBuffer(data);
      var length = data.length;
      this.totalLength += length * 8;
      for (var i = 0; i < length; i++) {
        this.write(data[i]);
      }
      return this;
    };
    Sha1.prototype.write = function write(byte) {
      this.block[this.offset] |= (byte & 255) << this.shift;
      if (this.shift) {
        this.shift -= 8;
      } else {
        this.offset++;
        this.shift = 24;
      }
      if (this.offset === 16)
        this.processBlock();
    };
    Sha1.prototype.digest = function(encoding) {
      this.write(128);
      if (this.offset > 14 || this.offset === 14 && this.shift < 24) {
        this.processBlock();
      }
      this.offset = 14;
      this.shift = 24;
      this.write(0);
      this.write(0);
      this.write(this.totalLength > 1099511627775 ? this.totalLength / 1099511627776 : 0);
      this.write(this.totalLength > 4294967295 ? this.totalLength / 4294967296 : 0);
      for (var s = 24; s >= 0; s -= 8) {
        this.write(this.totalLength >> s);
      }
      var out = new Buffer(DIGEST_LENGTH);
      var outView = new DataView(out.buffer);
      outView.setUint32(0, this.h0, false);
      outView.setUint32(4, this.h1, false);
      outView.setUint32(8, this.h2, false);
      outView.setUint32(12, this.h3, false);
      outView.setUint32(16, this.h4, false);
      return encoding ? out.toString(encoding) : out;
    };
    Sha1.prototype.processBlock = function processBlock() {
      for (var i = 16; i < 80; i++) {
        var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
        this.block[i] = w << 1 | w >>> 31;
      }
      var a = this.h0;
      var b = this.h1;
      var c = this.h2;
      var d = this.h3;
      var e = this.h4;
      var f, k;
      for (i = 0; i < 80; i++) {
        if (i < 20) {
          f = d ^ b & (c ^ d);
          k = 1518500249;
        } else if (i < 40) {
          f = b ^ c ^ d;
          k = 1859775393;
        } else if (i < 60) {
          f = b & c | d & (b | c);
          k = 2400959708;
        } else {
          f = b ^ c ^ d;
          k = 3395469782;
        }
        var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i] | 0);
        e = d;
        d = c;
        c = b << 30 | b >>> 2;
        b = a;
        a = temp;
      }
      this.h0 = this.h0 + a | 0;
      this.h1 = this.h1 + b | 0;
      this.h2 = this.h2 + c | 0;
      this.h3 = this.h3 + d | 0;
      this.h4 = this.h4 + e | 0;
      this.offset = 0;
      for (i = 0; i < 16; i++) {
        this.block[i] = 0;
      }
    };
  }
});

// node_modules/aws-sdk/lib/browserSha256.js
var require_browserSha256 = __commonJS({
  "node_modules/aws-sdk/lib/browserSha256.js"(exports, module) {
    var Buffer = require_buffer().Buffer;
    var hashUtils = require_browserHashUtils();
    var BLOCK_SIZE = 64;
    var DIGEST_LENGTH = 32;
    var KEY = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
    function Sha256() {
      this.state = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.temp = new Int32Array(64);
      this.buffer = new Uint8Array(64);
      this.bufferLength = 0;
      this.bytesHashed = 0;
      this.finished = false;
    }
    module.exports = exports = Sha256;
    Sha256.BLOCK_SIZE = BLOCK_SIZE;
    Sha256.prototype.update = function(data) {
      if (this.finished) {
        throw new Error("Attempted to update an already finished hash.");
      }
      if (hashUtils.isEmptyData(data)) {
        return this;
      }
      data = hashUtils.convertToBuffer(data);
      var position = 0;
      var byteLength = data.byteLength;
      this.bytesHashed += byteLength;
      if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      }
      while (byteLength > 0) {
        this.buffer[this.bufferLength++] = data[position++];
        byteLength--;
        if (this.bufferLength === BLOCK_SIZE) {
          this.hashBuffer();
          this.bufferLength = 0;
        }
      }
      return this;
    };
    Sha256.prototype.digest = function(encoding) {
      if (!this.finished) {
        var bitsHashed = this.bytesHashed * 8;
        var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
        var undecoratedLength = this.bufferLength;
        bufferView.setUint8(this.bufferLength++, 128);
        if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
            bufferView.setUint8(i, 0);
          }
          this.hashBuffer();
          this.bufferLength = 0;
        }
        for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
          bufferView.setUint8(i, 0);
        }
        bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
        bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
        this.hashBuffer();
        this.finished = true;
      }
      var out = new Buffer(DIGEST_LENGTH);
      for (var i = 0; i < 8; i++) {
        out[i * 4] = this.state[i] >>> 24 & 255;
        out[i * 4 + 1] = this.state[i] >>> 16 & 255;
        out[i * 4 + 2] = this.state[i] >>> 8 & 255;
        out[i * 4 + 3] = this.state[i] >>> 0 & 255;
      }
      return encoding ? out.toString(encoding) : out;
    };
    Sha256.prototype.hashBuffer = function() {
      var _a = this, buffer = _a.buffer, state = _a.state;
      var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
      for (var i = 0; i < BLOCK_SIZE; i++) {
        if (i < 16) {
          this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;
        } else {
          var u = this.temp[i - 2];
          var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
          u = this.temp[i - 15];
          var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
          this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
        }
        var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i] + this.temp[i] | 0) | 0) | 0;
        var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
        state7 = state6;
        state6 = state5;
        state5 = state4;
        state4 = state3 + t1 | 0;
        state3 = state2;
        state2 = state1;
        state1 = state0;
        state0 = t1 + t2 | 0;
      }
      state[0] += state0;
      state[1] += state1;
      state[2] += state2;
      state[3] += state3;
      state[4] += state4;
      state[5] += state5;
      state[6] += state6;
      state[7] += state7;
    };
  }
});

// node_modules/aws-sdk/lib/browserCryptoLib.js
var require_browserCryptoLib = __commonJS({
  "node_modules/aws-sdk/lib/browserCryptoLib.js"(exports, module) {
    var Hmac = require_browserHmac();
    var Md5 = require_browserMd5();
    var Sha1 = require_browserSha1();
    var Sha256 = require_browserSha256();
    module.exports = exports = {
      createHash: function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5") {
          return new Md5();
        } else if (alg === "sha256") {
          return new Sha256();
        } else if (alg === "sha1") {
          return new Sha1();
        }
        throw new Error("Hash algorithm " + alg + " is not supported in the browser SDK");
      },
      createHmac: function createHmac(alg, key) {
        alg = alg.toLowerCase();
        if (alg === "md5") {
          return new Hmac(Md5, key);
        } else if (alg === "sha256") {
          return new Hmac(Sha256, key);
        } else if (alg === "sha1") {
          return new Hmac(Sha1, key);
        }
        throw new Error("HMAC algorithm " + alg + " is not supported in the browser SDK");
      },
      createSign: function() {
        throw new Error("createSign is not implemented in the browser");
      }
    };
  }
});

// node_modules/url/node_modules/punycode/punycode.js
var require_punycode = __commonJS({
  "node_modules/url/node_modules/punycode/punycode.js"(exports, module) {
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/querystring/decode.js
var require_decode = __commonJS({
  "node_modules/querystring/decode.js"(exports, module) {
    "use strict";
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module.exports = function(qs, sep, eq, options) {
      sep = sep || "&";
      eq = eq || "=";
      var obj = {};
      if (typeof qs !== "string" || qs.length === 0) {
        return obj;
      }
      var regexp = /\+/g;
      qs = qs.split(sep);
      var maxKeys = 1e3;
      if (options && typeof options.maxKeys === "number") {
        maxKeys = options.maxKeys;
      }
      var len = qs.length;
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }
      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = "";
        }
        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);
        if (!hasOwnProperty2(obj, k)) {
          obj[k] = v;
        } else if (Array.isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }
      return obj;
    };
  }
});

// node_modules/querystring/encode.js
var require_encode = __commonJS({
  "node_modules/querystring/encode.js"(exports, module) {
    "use strict";
    var stringifyPrimitive = function(v) {
      switch (typeof v) {
        case "string":
          return v;
        case "boolean":
          return v ? "true" : "false";
        case "number":
          return isFinite(v) ? v : "";
        default:
          return "";
      }
    };
    module.exports = function(obj, sep, eq, name) {
      sep = sep || "&";
      eq = eq || "=";
      if (obj === null) {
        obj = void 0;
      }
      if (typeof obj === "object") {
        return Object.keys(obj).map(function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (Array.isArray(obj[k])) {
            return obj[k].map(function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }
      if (!name)
        return "";
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };
  }
});

// node_modules/querystring/index.js
var require_querystring = __commonJS({
  "node_modules/querystring/index.js"(exports) {
    "use strict";
    exports.decode = exports.parse = require_decode();
    exports.encode = exports.stringify = require_encode();
  }
});

// node_modules/url/url.js
var require_url = __commonJS({
  "node_modules/url/url.js"(exports) {
    var punycode = require_punycode();
    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;
    exports.Url = Url;
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/;
    var unsafeProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    var querystring = require_querystring();
    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && isObject(url) && url instanceof Url)
        return url;
      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      if (!isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }
      var rest = url;
      rest = rest.trim();
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        if (hostEnd === -1)
          hostEnd = rest.length;
        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost();
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part)
              continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = "/" + notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        } else {
          this.hostname = this.hostname.toLowerCase();
        }
        if (!ipv6Hostname) {
          var domainArray = this.hostname.split(".");
          var newOut = [];
          for (var i = 0; i < domainArray.length; ++i) {
            var s = domainArray[i];
            newOut.push(s.match(/[^A-Za-z0-9_-]/) ? "xn--" + punycode.encode(s) : s);
          }
          this.hostname = newOut.join(".");
        }
        var p = this.port ? ":" + this.port : "";
        var h = this.hostname || "";
        this.host = h + p;
        this.href += this.host;
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== "/") {
            rest = "/" + rest;
          }
        }
      }
      if (!unsafeProtocol[lowerProto]) {
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        this.search = "";
        this.query = {};
      }
      if (rest)
        this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "/";
      }
      if (this.pathname || this.search) {
        var p = this.pathname || "";
        var s = this.search || "";
        this.path = p + s;
      }
      this.href = this.format();
      return this;
    };
    function urlFormat(obj) {
      if (isString(obj))
        obj = urlParse(obj);
      if (!(obj instanceof Url))
        return Url.prototype.format.call(obj);
      return obj.format();
    }
    Url.prototype.format = function() {
      var auth = this.auth || "";
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ":");
        auth += "@";
      }
      var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          host += ":" + this.port;
        }
      }
      if (this.query && isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }
      var search = this.search || query && "?" + query || "";
      if (protocol && protocol.substr(-1) !== ":")
        protocol += ":";
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname.charAt(0) !== "/")
          pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash.charAt(0) !== "#")
        hash = "#" + hash;
      if (search && search.charAt(0) !== "?")
        search = "?" + search;
      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace("#", "%23");
      return protocol + host + pathname + search + hash;
    };
    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }
    Url.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };
    function urlResolveObject(source, relative) {
      if (!source)
        return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }
    Url.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }
      var result = new Url();
      Object.keys(this).forEach(function(k) {
        result[k] = this[k];
      }, this);
      result.hash = relative.hash;
      if (relative.href === "") {
        result.href = result.format();
        return result;
      }
      if (relative.slashes && !relative.protocol) {
        Object.keys(relative).forEach(function(k) {
          if (k !== "protocol")
            result[k] = relative[k];
        });
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = "/";
        }
        result.href = result.format();
        return result;
      }
      if (relative.protocol && relative.protocol !== result.protocol) {
        if (!slashedProtocol[relative.protocol]) {
          Object.keys(relative).forEach(function(k) {
            result[k] = relative[k];
          });
          result.href = result.format();
          return result;
        }
        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || "").split("/");
          while (relPath.length && !(relative.host = relPath.shift()))
            ;
          if (!relative.host)
            relative.host = "";
          if (!relative.hostname)
            relative.hostname = "";
          if (relPath[0] !== "")
            relPath.unshift("");
          if (relPath.length < 2)
            relPath.unshift("");
          result.pathname = relPath.join("/");
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || "";
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        if (result.pathname || result.search) {
          var p = result.pathname || "";
          var s = result.search || "";
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }
      var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
      if (psychotic) {
        result.hostname = "";
        result.port = null;
        if (result.host) {
          if (srcPath[0] === "")
            srcPath[0] = result.host;
          else
            srcPath.unshift(result.host);
        }
        result.host = "";
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === "")
              relPath[0] = relative.host;
            else
              relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
      }
      if (isRelAbs) {
        result.host = relative.host || relative.host === "" ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
      } else if (relPath.length) {
        if (!srcPath)
          srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
        }
        result.href = result.format();
        return result;
      }
      if (!srcPath.length) {
        result.pathname = null;
        if (result.search) {
          result.path = "/" + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last == ".") {
          srcPath.splice(i, 1);
        } else if (last === "..") {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift("..");
        }
      }
      if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
        srcPath.unshift("");
      }
      if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
        srcPath.push("");
      }
      var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      mustEndAbs = mustEndAbs || result.host && srcPath.length;
      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift("");
      }
      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join("/");
      }
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };
    Url.prototype.parseHost = function() {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host)
        this.hostname = host;
    };
    function isString(arg) {
      return typeof arg === "string";
    }
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNullOrUndefined(arg) {
      return arg == null;
    }
  }
});

// node_modules/aws-sdk/lib/realclock/browserClock.js
var require_browserClock = __commonJS({
  "node_modules/aws-sdk/lib/realclock/browserClock.js"(exports, module) {
    module.exports = {
      //provide realtime clock for performance measurement
      now: function now() {
        if (typeof performance !== "undefined" && typeof performance.now === "function") {
          return performance.now();
        }
        return Date.now();
      }
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/event-message-chunker.js
var require_event_message_chunker = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/event-message-chunker.js"(exports, module) {
    function eventMessageChunker(buffer) {
      var messages = [];
      var offset = 0;
      while (offset < buffer.length) {
        var totalLength = buffer.readInt32BE(offset);
        var message = buffer.slice(offset, totalLength + offset);
        offset += totalLength;
        messages.push(message);
      }
      return messages;
    }
    module.exports = {
      eventMessageChunker
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/int64.js
var require_int64 = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/int64.js"(exports, module) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    function Int64(bytes) {
      if (bytes.length !== 8) {
        throw new Error("Int64 buffers must be exactly 8 bytes");
      }
      if (!util.Buffer.isBuffer(bytes))
        bytes = toBuffer(bytes);
      this.bytes = bytes;
    }
    Int64.fromNumber = function(number) {
      if (number > 9223372036854776e3 || number < -9223372036854776e3) {
        throw new Error(
          number + " is too large (or, if negative, too small) to represent as an Int64"
        );
      }
      var bytes = new Uint8Array(8);
      for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
        bytes[i] = remaining;
      }
      if (number < 0) {
        negate(bytes);
      }
      return new Int64(bytes);
    };
    Int64.prototype.valueOf = function() {
      var bytes = this.bytes.slice(0);
      var negative = bytes[0] & 128;
      if (negative) {
        negate(bytes);
      }
      return parseInt(bytes.toString("hex"), 16) * (negative ? -1 : 1);
    };
    Int64.prototype.toString = function() {
      return String(this.valueOf());
    };
    function negate(bytes) {
      for (var i = 0; i < 8; i++) {
        bytes[i] ^= 255;
      }
      for (var i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0) {
          break;
        }
      }
    }
    module.exports = {
      Int64
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/split-message.js
var require_split_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/split-message.js"(exports, module) {
    var util = require_core().util;
    var toBuffer = util.buffer.toBuffer;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage(message) {
      if (!util.Buffer.isBuffer(message))
        message = toBuffer(message);
      if (message.length < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
      }
      if (message.length !== message.readUInt32BE(0)) {
        throw new Error("Reported message length does not match received message length");
      }
      var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);
      if (expectedPreludeChecksum !== util.crypto.crc32(
        message.slice(0, PRELUDE_LENGTH)
      )) {
        throw new Error(
          "The prelude checksum specified in the message (" + expectedPreludeChecksum + ") does not match the calculated CRC32 checksum."
        );
      }
      var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);
      if (expectedMessageChecksum !== util.crypto.crc32(
        message.slice(0, message.length - CHECKSUM_LENGTH)
      )) {
        throw new Error(
          "The message checksum did not match the expected value of " + expectedMessageChecksum
        );
      }
      var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
      var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
      return {
        headers: message.slice(headersStart, headersEnd),
        body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)
      };
    }
    module.exports = {
      splitMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-message.js
var require_parse_message = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-message.js"(exports, module) {
    var Int64 = require_int64().Int64;
    var splitMessage = require_split_message().splitMessage;
    var BOOLEAN_TAG = "boolean";
    var BYTE_TAG = "byte";
    var SHORT_TAG = "short";
    var INT_TAG = "integer";
    var LONG_TAG = "long";
    var BINARY_TAG = "binary";
    var STRING_TAG = "string";
    var TIMESTAMP_TAG = "timestamp";
    var UUID_TAG = "uuid";
    function parseHeaders(headers) {
      var out = {};
      var position = 0;
      while (position < headers.length) {
        var nameLength = headers.readUInt8(position++);
        var name = headers.slice(position, position + nameLength).toString();
        position += nameLength;
        switch (headers.readUInt8(position++)) {
          case 0:
            out[name] = {
              type: BOOLEAN_TAG,
              value: true
            };
            break;
          case 1:
            out[name] = {
              type: BOOLEAN_TAG,
              value: false
            };
            break;
          case 2:
            out[name] = {
              type: BYTE_TAG,
              value: headers.readInt8(position++)
            };
            break;
          case 3:
            out[name] = {
              type: SHORT_TAG,
              value: headers.readInt16BE(position)
            };
            position += 2;
            break;
          case 4:
            out[name] = {
              type: INT_TAG,
              value: headers.readInt32BE(position)
            };
            position += 4;
            break;
          case 5:
            out[name] = {
              type: LONG_TAG,
              value: new Int64(headers.slice(position, position + 8))
            };
            position += 8;
            break;
          case 6:
            var binaryLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: BINARY_TAG,
              value: headers.slice(position, position + binaryLength)
            };
            position += binaryLength;
            break;
          case 7:
            var stringLength = headers.readUInt16BE(position);
            position += 2;
            out[name] = {
              type: STRING_TAG,
              value: headers.slice(
                position,
                position + stringLength
              ).toString()
            };
            position += stringLength;
            break;
          case 8:
            out[name] = {
              type: TIMESTAMP_TAG,
              value: new Date(
                new Int64(headers.slice(position, position + 8)).valueOf()
              )
            };
            position += 8;
            break;
          case 9:
            var uuidChars = headers.slice(position, position + 16).toString("hex");
            position += 16;
            out[name] = {
              type: UUID_TAG,
              value: uuidChars.substr(0, 8) + "-" + uuidChars.substr(8, 4) + "-" + uuidChars.substr(12, 4) + "-" + uuidChars.substr(16, 4) + "-" + uuidChars.substr(20)
            };
            break;
          default:
            throw new Error("Unrecognized header type tag");
        }
      }
      return out;
    }
    function parseMessage(message) {
      var parsed = splitMessage(message);
      return { headers: parseHeaders(parsed.headers), body: parsed.body };
    }
    module.exports = {
      parseMessage
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/parse-event.js
var require_parse_event = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/parse-event.js"(exports, module) {
    var parseMessage = require_parse_message().parseMessage;
    function parseEvent(parser, message, shape) {
      var parsedMessage = parseMessage(message);
      var messageType = parsedMessage.headers[":message-type"];
      if (messageType) {
        if (messageType.value === "error") {
          throw parseError(parsedMessage);
        } else if (messageType.value !== "event") {
          return;
        }
      }
      var eventType = parsedMessage.headers[":event-type"];
      var eventModel = shape.members[eventType.value];
      if (!eventModel) {
        return;
      }
      var result = {};
      var eventPayloadMemberName = eventModel.eventPayloadMemberName;
      if (eventPayloadMemberName) {
        var payloadShape = eventModel.members[eventPayloadMemberName];
        if (payloadShape.type === "binary") {
          result[eventPayloadMemberName] = parsedMessage.body;
        } else {
          result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
        }
      }
      var eventHeaderNames = eventModel.eventHeaderMemberNames;
      for (var i = 0; i < eventHeaderNames.length; i++) {
        var name = eventHeaderNames[i];
        if (parsedMessage.headers[name]) {
          result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
        }
      }
      var output = {};
      output[eventType.value] = result;
      return output;
    }
    function parseError(message) {
      var errorCode = message.headers[":error-code"];
      var errorMessage = message.headers[":error-message"];
      var error = new Error(errorMessage.value || errorMessage);
      error.code = error.name = errorCode.value || errorCode;
      return error;
    }
    module.exports = {
      parseEvent
    };
  }
});

// node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js
var require_buffered_create_event_stream = __commonJS({
  "node_modules/aws-sdk/lib/event-stream/buffered-create-event-stream.js"(exports, module) {
    var eventMessageChunker = require_event_message_chunker().eventMessageChunker;
    var parseEvent = require_parse_event().parseEvent;
    function createEventStream(body, parser, model) {
      var eventMessages = eventMessageChunker(body);
      var events = [];
      for (var i = 0; i < eventMessages.length; i++) {
        events.push(parseEvent(parser, eventMessages[i], model));
      }
      return events;
    }
    module.exports = {
      createEventStream
    };
  }
});

// node_modules/aws-sdk/lib/config_regional_endpoint.js
var require_config_regional_endpoint = __commonJS({
  "node_modules/aws-sdk/lib/config_regional_endpoint.js"(exports, module) {
    var AWS2 = require_core();
    function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
      if (typeof configValue !== "string")
        return void 0;
      else if (["legacy", "regional"].indexOf(configValue.toLowerCase()) >= 0) {
        return configValue.toLowerCase();
      } else {
        throw AWS2.util.error(new Error(), errorOptions);
      }
    }
    function resolveRegionalEndpointsFlag(originalConfig, options) {
      originalConfig = originalConfig || {};
      var resolved;
      if (originalConfig[options.clientConfig]) {
        resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
          code: "InvalidConfiguration",
          message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy"  or "regional". Got "' + originalConfig[options.clientConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      if (!AWS2.util.isNode())
        return resolved;
      if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
        var envFlag = process.env[options.env];
        resolved = validateRegionalEndpointsFlagValue(envFlag, {
          code: "InvalidEnvironmentalVariable",
          message: "invalid " + options.env + ' environmental variable. Expect "legacy"  or "regional". Got "' + process.env[options.env] + '".'
        });
        if (resolved)
          return resolved;
      }
      var profile = {};
      try {
        var profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
        profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
      } catch (e) {
      }
      ;
      if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
        var fileFlag = profile[options.sharedConfig];
        resolved = validateRegionalEndpointsFlagValue(fileFlag, {
          code: "InvalidConfiguration",
          message: "invalid " + options.sharedConfig + ' profile config. Expect "legacy"  or "regional". Got "' + profile[options.sharedConfig] + '".'
        });
        if (resolved)
          return resolved;
      }
      return resolved;
    }
    module.exports = resolveRegionalEndpointsFlag;
  }
});

// node_modules/aws-sdk/lib/services/sts.js
var require_sts = __commonJS({
  "node_modules/aws-sdk/lib/services/sts.js"() {
    var AWS2 = require_core();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var ENV_REGIONAL_ENDPOINT_ENABLED = "AWS_STS_REGIONAL_ENDPOINTS";
    var CONFIG_REGIONAL_ENDPOINT_ENABLED = "sts_regional_endpoints";
    AWS2.util.update(AWS2.STS.prototype, {
      /**
       * @overload credentialsFrom(data, credentials = null)
       *   Creates a credentials object from STS response data containing
       *   credentials information. Useful for quickly setting AWS credentials.
       *
       *   @note This is a low-level utility function. If you want to load temporary
       *     credentials into your process for subsequent requests to AWS resources,
       *     you should use {AWS.TemporaryCredentials} instead.
       *   @param data [map] data retrieved from a call to {getFederatedToken},
       *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
       *   @param credentials [AWS.Credentials] an optional credentials object to
       *     fill instead of creating a new object. Useful when modifying an
       *     existing credentials object from a refresh call.
       *   @return [AWS.TemporaryCredentials] the set of temporary credentials
       *     loaded from a raw STS operation response.
       *   @example Using credentialsFrom to load global AWS credentials
       *     var sts = new AWS.STS();
       *     sts.getSessionToken(function (err, data) {
       *       if (err) console.log("Error getting credentials");
       *       else {
       *         AWS.config.credentials = sts.credentialsFrom(data);
       *       }
       *     });
       *   @see AWS.TemporaryCredentials
       */
      credentialsFrom: function credentialsFrom(data, credentials) {
        if (!data)
          return null;
        if (!credentials)
          credentials = new AWS2.TemporaryCredentials();
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretAccessKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
        return credentials;
      },
      assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity", params, callback);
      },
      assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
        return this.makeUnauthenticatedRequest("assumeRoleWithSAML", params, callback);
      },
      /**
       * @api private
       */
      setupRequestListeners: function setupRequestListeners(request) {
        request.addListener("validate", this.optInRegionalEndpoint, true);
      },
      /**
       * @api private
       */
      optInRegionalEndpoint: function optInRegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: ENV_REGIONAL_ENDPOINT_ENABLED,
          sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
          clientConfig: "stsRegionalEndpoints"
        });
        if (config.stsRegionalEndpoints === "regional" && service.isGlobalEndpoint) {
          if (!config.region) {
            throw AWS2.util.error(
              new Error(),
              { code: "ConfigError", message: "Missing region in config" }
            );
          }
          var insertPoint = config.endpoint.indexOf(".amazonaws.com");
          var regionalEndpoint = config.endpoint.substring(0, insertPoint) + "." + config.region + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
          req.httpRequest.region = config.region;
        }
      }
    });
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.min.json
var require_sts_2011_06_15_min = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.min.json"(exports, module) {
    module.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2011-06-15",
        endpointPrefix: "sts",
        globalEndpoint: "sts.amazonaws.com",
        protocol: "query",
        serviceAbbreviation: "AWS STS",
        serviceFullName: "AWS Security Token Service",
        serviceId: "STS",
        signatureVersion: "v4",
        uid: "sts-2011-06-15",
        xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/"
      },
      operations: {
        AssumeRole: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              },
              TransitiveTagKeys: {
                type: "list",
                member: {}
              },
              ExternalId: {},
              SerialNumber: {},
              TokenCode: {},
              SourceIdentity: {},
              ProvidedContexts: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    ProviderArn: {},
                    ContextAssertion: {}
                  }
                }
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Sl"
              },
              AssumedRoleUser: {
                shape: "Sq"
              },
              PackedPolicySize: {
                type: "integer"
              },
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithSAML: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "PrincipalArn",
              "SAMLAssertion"
            ],
            members: {
              RoleArn: {},
              PrincipalArn: {},
              SAMLAssertion: {
                type: "string",
                sensitive: true
              },
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithSAMLResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Sl"
              },
              AssumedRoleUser: {
                shape: "Sq"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Subject: {},
              SubjectType: {},
              Issuer: {},
              Audience: {},
              NameQualifier: {},
              SourceIdentity: {}
            }
          }
        },
        AssumeRoleWithWebIdentity: {
          input: {
            type: "structure",
            required: [
              "RoleArn",
              "RoleSessionName",
              "WebIdentityToken"
            ],
            members: {
              RoleArn: {},
              RoleSessionName: {},
              WebIdentityToken: {
                type: "string",
                sensitive: true
              },
              ProviderId: {},
              PolicyArns: {
                shape: "S4"
              },
              Policy: {},
              DurationSeconds: {
                type: "integer"
              }
            }
          },
          output: {
            resultWrapper: "AssumeRoleWithWebIdentityResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Sl"
              },
              SubjectFromWebIdentityToken: {},
              AssumedRoleUser: {
                shape: "Sq"
              },
              PackedPolicySize: {
                type: "integer"
              },
              Provider: {},
              Audience: {},
              SourceIdentity: {}
            }
          }
        },
        DecodeAuthorizationMessage: {
          input: {
            type: "structure",
            required: [
              "EncodedMessage"
            ],
            members: {
              EncodedMessage: {}
            }
          },
          output: {
            resultWrapper: "DecodeAuthorizationMessageResult",
            type: "structure",
            members: {
              DecodedMessage: {}
            }
          }
        },
        GetAccessKeyInfo: {
          input: {
            type: "structure",
            required: [
              "AccessKeyId"
            ],
            members: {
              AccessKeyId: {}
            }
          },
          output: {
            resultWrapper: "GetAccessKeyInfoResult",
            type: "structure",
            members: {
              Account: {}
            }
          }
        },
        GetCallerIdentity: {
          input: {
            type: "structure",
            members: {}
          },
          output: {
            resultWrapper: "GetCallerIdentityResult",
            type: "structure",
            members: {
              UserId: {},
              Account: {},
              Arn: {}
            }
          }
        },
        GetFederationToken: {
          input: {
            type: "structure",
            required: [
              "Name"
            ],
            members: {
              Name: {},
              Policy: {},
              PolicyArns: {
                shape: "S4"
              },
              DurationSeconds: {
                type: "integer"
              },
              Tags: {
                shape: "S8"
              }
            }
          },
          output: {
            resultWrapper: "GetFederationTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Sl"
              },
              FederatedUser: {
                type: "structure",
                required: [
                  "FederatedUserId",
                  "Arn"
                ],
                members: {
                  FederatedUserId: {},
                  Arn: {}
                }
              },
              PackedPolicySize: {
                type: "integer"
              }
            }
          }
        },
        GetSessionToken: {
          input: {
            type: "structure",
            members: {
              DurationSeconds: {
                type: "integer"
              },
              SerialNumber: {},
              TokenCode: {}
            }
          },
          output: {
            resultWrapper: "GetSessionTokenResult",
            type: "structure",
            members: {
              Credentials: {
                shape: "Sl"
              }
            }
          }
        }
      },
      shapes: {
        S4: {
          type: "list",
          member: {
            type: "structure",
            members: {
              arn: {}
            }
          }
        },
        S8: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Key",
              "Value"
            ],
            members: {
              Key: {},
              Value: {}
            }
          }
        },
        Sl: {
          type: "structure",
          required: [
            "AccessKeyId",
            "SecretAccessKey",
            "SessionToken",
            "Expiration"
          ],
          members: {
            AccessKeyId: {},
            SecretAccessKey: {
              type: "string",
              sensitive: true
            },
            SessionToken: {},
            Expiration: {
              type: "timestamp"
            }
          }
        },
        Sq: {
          type: "structure",
          required: [
            "AssumedRoleId",
            "Arn"
          ],
          members: {
            AssumedRoleId: {},
            Arn: {}
          }
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json
var require_sts_2011_06_15_paginators = __commonJS({
  "node_modules/aws-sdk/apis/sts-2011-06-15.paginators.json"(exports, module) {
    module.exports = {
      pagination: {}
    };
  }
});

// node_modules/aws-sdk/clients/sts.js
var require_sts2 = __commonJS({
  "node_modules/aws-sdk/clients/sts.js"(exports, module) {
    require_browser_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["sts"] = {};
    AWS2.STS = Service.defineService("sts", ["2011-06-15"]);
    require_sts();
    Object.defineProperty(apiLoader.services["sts"], "2011-06-15", {
      get: function get() {
        var model = require_sts_2011_06_15_min();
        model.paginators = require_sts_2011_06_15_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS2.STS;
  }
});

// node_modules/aws-sdk/lib/credentials/temporary_credentials.js
var require_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/temporary_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.TemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * Creates a new temporary credentials object.
       *
       * @note In order to create temporary credentials, you first need to have
       *   "master" credentials configured in {AWS.Config.credentials}. These
       *   master credentials are necessary to retrieve the temporary credentials,
       *   as well as refresh the credentials when they expire.
       * @param params [map] a map of options that are passed to the
       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
       *   If a `RoleArn` parameter is passed in, credentials will be based on the
       *   IAM role.
       * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
       *  used to get and refresh temporary credentials from AWS STS.
       * @example Creating a new credentials object for generic temporary credentials
       *   AWS.config.credentials = new AWS.TemporaryCredentials();
       * @example Creating a new credentials object for an IAM role
       *   AWS.config.credentials = new AWS.TemporaryCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
       *   });
       * @see AWS.STS.assumeRole
       * @see AWS.STS.getSessionToken
       */
      constructor: function TemporaryCredentials(params, masterCredentials) {
        AWS2.Credentials.call(this);
        this.loadMasterCredentials(masterCredentials);
        this.expired = true;
        this.params = params || {};
        if (this.params.RoleArn) {
          this.params.RoleSessionName = this.params.RoleSessionName || "temporary-credentials";
        }
      },
      /**
       * Refreshes credentials using {AWS.STS.assumeRole} or
       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
       * to the credentials {constructor}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.masterCredentials.get(function() {
          self.service.config.credentials = self.masterCredentials;
          var operation = self.params.RoleArn ? self.service.assumeRole : self.service.getSessionToken;
          operation.call(self.service, function(err, data) {
            if (!err) {
              self.service.credentialsFrom(data, self);
            }
            callback(err);
          });
        });
      },
      /**
       * @api private
       */
      loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
        this.masterCredentials = masterCredentials || AWS2.config.credentials;
        while (this.masterCredentials.masterCredentials) {
          this.masterCredentials = this.masterCredentials.masterCredentials;
        }
        if (typeof this.masterCredentials.get !== "function") {
          this.masterCredentials = new AWS2.Credentials(this.masterCredentials);
        }
      },
      /**
       * @api private
       */
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js
var require_chainable_temporary_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/chainable_temporary_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.ChainableTemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * Creates a new temporary credentials object.
       *
       * @param options [map] a set of options
       * @option options params [map] ({}) a map of options that are passed to the
       *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
       *   If a `RoleArn` parameter is passed in, credentials will be based on the
       *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
       *   also be passed in or an error will be thrown.
       * @option options masterCredentials [AWS.Credentials] the master credentials
       *   used to get and refresh temporary credentials from AWS STS. By default,
       *   AWS.config.credentials or AWS.config.credentialProvider will be used.
       * @option options tokenCodeFn [Function] (null) Function to provide
       *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
       *   is called with value of `SerialNumber` and `callback`, and should provide
       *   the `TokenCode` or an error to the callback in the format
       *   `callback(err, token)`.
       * @example Creating a new credentials object for generic temporary credentials
       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
       * @example Creating a new credentials object for an IAM role
       *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
       *     params: {
       *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
       *     }
       *   });
       * @see AWS.STS.assumeRole
       * @see AWS.STS.getSessionToken
       */
      constructor: function ChainableTemporaryCredentials(options) {
        AWS2.Credentials.call(this);
        options = options || {};
        this.errorCode = "ChainableTemporaryCredentialsProviderFailure";
        this.expired = true;
        this.tokenCodeFn = null;
        var params = AWS2.util.copy(options.params) || {};
        if (params.RoleArn) {
          params.RoleSessionName = params.RoleSessionName || "temporary-credentials";
        }
        if (params.SerialNumber) {
          if (!options.tokenCodeFn || typeof options.tokenCodeFn !== "function") {
            throw new AWS2.util.error(
              new Error("tokenCodeFn must be a function when params.SerialNumber is given"),
              { code: this.errorCode }
            );
          } else {
            this.tokenCodeFn = options.tokenCodeFn;
          }
        }
        var config = AWS2.util.merge(
          {
            params,
            credentials: options.masterCredentials || AWS2.config.credentials
          },
          options.stsConfig || {}
        );
        this.service = new STS(config);
      },
      /**
       * Refreshes credentials using {AWS.STS.assumeRole} or
       * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
       * to the credentials {constructor}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see AWS.Credentials.get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        var self = this;
        var operation = self.service.config.params.RoleArn ? "assumeRole" : "getSessionToken";
        this.getTokenCode(function(err, tokenCode) {
          var params = {};
          if (err) {
            callback(err);
            return;
          }
          if (tokenCode) {
            params.TokenCode = tokenCode;
          }
          self.service[operation](params, function(err2, data) {
            if (!err2) {
              self.service.credentialsFrom(data, self);
            }
            callback(err2);
          });
        });
      },
      /**
       * @api private
       */
      getTokenCode: function getTokenCode(callback) {
        var self = this;
        if (this.tokenCodeFn) {
          this.tokenCodeFn(this.service.config.params.SerialNumber, function(err, token) {
            if (err) {
              var message = err;
              if (err instanceof Error) {
                message = err.message;
              }
              callback(
                AWS2.util.error(
                  new Error("Error fetching MFA token: " + message),
                  { code: self.errorCode }
                )
              );
              return;
            }
            callback(null, token);
          });
        } else {
          callback(null);
        }
      }
    });
  }
});

// node_modules/aws-sdk/lib/credentials/web_identity_credentials.js
var require_web_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/web_identity_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.WebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * Creates a new credentials object.
       * @param (see AWS.STS.assumeRoleWithWebIdentity)
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.WebIdentityCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
       *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
       *     RoleSessionName: 'web' // optional name, defaults to web-identity
       *   }, {
       *     // optionally provide configuration to apply to the underlying AWS.STS service client
       *     // if configuration is not provided, then configuration will be pulled from AWS.config
       *
       *     // specify timeout options
       *     httpOptions: {
       *       timeout: 100
       *     }
       *   });
       * @see AWS.STS.assumeRoleWithWebIdentity
       * @see AWS.Config
       */
      constructor: function WebIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.params.RoleSessionName = this.params.RoleSessionName || "web-identity";
        this.data = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
      },
      /**
       * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithWebIdentity(function(err, data) {
          self.data = null;
          if (!err) {
            self.data = data;
            self.service.credentialsFrom(data, self);
          }
          callback(err);
        });
      },
      /**
       * @api private
       */
      createClients: function() {
        if (!this.service) {
          var stsConfig = AWS2.util.merge({}, this._clientConfig);
          stsConfig.params = this.params;
          this.service = new STS(stsConfig);
        }
      }
    });
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json
var require_cognito_identity_2014_06_30_min = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.min.json"(exports, module) {
    module.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2014-06-30",
        endpointPrefix: "cognito-identity",
        jsonVersion: "1.1",
        protocol: "json",
        serviceFullName: "Amazon Cognito Identity",
        serviceId: "Cognito Identity",
        signatureVersion: "v4",
        targetPrefix: "AWSCognitoIdentityService",
        uid: "cognito-identity-2014-06-30"
      },
      operations: {
        CreateIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolName",
              "AllowUnauthenticatedIdentities"
            ],
            members: {
              IdentityPoolName: {},
              AllowUnauthenticatedIdentities: {
                type: "boolean"
              },
              AllowClassicFlow: {
                type: "boolean"
              },
              SupportedLoginProviders: {
                shape: "S5"
              },
              DeveloperProviderName: {},
              OpenIdConnectProviderARNs: {
                shape: "S9"
              },
              CognitoIdentityProviders: {
                shape: "Sb"
              },
              SamlProviderARNs: {
                shape: "Sg"
              },
              IdentityPoolTags: {
                shape: "Sh"
              }
            }
          },
          output: {
            shape: "Sk"
          }
        },
        DeleteIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityIdsToDelete"
            ],
            members: {
              IdentityIdsToDelete: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {
              UnprocessedIdentityIds: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityId: {},
                    ErrorCode: {}
                  }
                }
              }
            }
          }
        },
        DeleteIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          }
        },
        DescribeIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {}
            }
          },
          output: {
            shape: "Sv"
          }
        },
        DescribeIdentityPool: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            shape: "Sk"
          }
        },
        GetCredentialsForIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              CustomRoleArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Credentials: {
                type: "structure",
                members: {
                  AccessKeyId: {},
                  SecretKey: {},
                  SessionToken: {},
                  Expiration: {
                    type: "timestamp"
                  }
                }
              }
            }
          },
          authtype: "none"
        },
        GetId: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              AccountId: {},
              IdentityPoolId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          },
          authtype: "none"
        },
        GetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        GetOpenIdToken: {
          input: {
            type: "structure",
            required: [
              "IdentityId"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          },
          authtype: "none"
        },
        GetOpenIdTokenForDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Logins"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              PrincipalTags: {
                shape: "S1s"
              },
              TokenDuration: {
                type: "long"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              Token: {}
            }
          }
        },
        GetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        ListIdentities: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "MaxResults"
            ],
            members: {
              IdentityPoolId: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {},
              HideDisabled: {
                type: "boolean"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              Identities: {
                type: "list",
                member: {
                  shape: "Sv"
                }
              },
              NextToken: {}
            }
          }
        },
        ListIdentityPools: {
          input: {
            type: "structure",
            required: [
              "MaxResults"
            ],
            members: {
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPools: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    IdentityPoolId: {},
                    IdentityPoolName: {}
                  }
                }
              },
              NextToken: {}
            }
          }
        },
        ListTagsForResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn"
            ],
            members: {
              ResourceArn: {}
            }
          },
          output: {
            type: "structure",
            members: {
              Tags: {
                shape: "Sh"
              }
            }
          }
        },
        LookupDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId"
            ],
            members: {
              IdentityPoolId: {},
              IdentityId: {},
              DeveloperUserIdentifier: {},
              MaxResults: {
                type: "integer"
              },
              NextToken: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {},
              DeveloperUserIdentifierList: {
                type: "list",
                member: {}
              },
              NextToken: {}
            }
          }
        },
        MergeDeveloperIdentities: {
          input: {
            type: "structure",
            required: [
              "SourceUserIdentifier",
              "DestinationUserIdentifier",
              "DeveloperProviderName",
              "IdentityPoolId"
            ],
            members: {
              SourceUserIdentifier: {},
              DestinationUserIdentifier: {},
              DeveloperProviderName: {},
              IdentityPoolId: {}
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityId: {}
            }
          }
        },
        SetIdentityPoolRoles: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "Roles"
            ],
            members: {
              IdentityPoolId: {},
              Roles: {
                shape: "S1c"
              },
              RoleMappings: {
                shape: "S1e"
              }
            }
          }
        },
        SetPrincipalTagAttributeMap: {
          input: {
            type: "structure",
            required: [
              "IdentityPoolId",
              "IdentityProviderName"
            ],
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IdentityPoolId: {},
              IdentityProviderName: {},
              UseDefaults: {
                type: "boolean"
              },
              PrincipalTags: {
                shape: "S1s"
              }
            }
          }
        },
        TagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "Tags"
            ],
            members: {
              ResourceArn: {},
              Tags: {
                shape: "Sh"
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UnlinkDeveloperIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "IdentityPoolId",
              "DeveloperProviderName",
              "DeveloperUserIdentifier"
            ],
            members: {
              IdentityId: {},
              IdentityPoolId: {},
              DeveloperProviderName: {},
              DeveloperUserIdentifier: {}
            }
          }
        },
        UnlinkIdentity: {
          input: {
            type: "structure",
            required: [
              "IdentityId",
              "Logins",
              "LoginsToRemove"
            ],
            members: {
              IdentityId: {},
              Logins: {
                shape: "S10"
              },
              LoginsToRemove: {
                shape: "Sw"
              }
            }
          },
          authtype: "none"
        },
        UntagResource: {
          input: {
            type: "structure",
            required: [
              "ResourceArn",
              "TagKeys"
            ],
            members: {
              ResourceArn: {},
              TagKeys: {
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {}
          }
        },
        UpdateIdentityPool: {
          input: {
            shape: "Sk"
          },
          output: {
            shape: "Sk"
          }
        }
      },
      shapes: {
        S5: {
          type: "map",
          key: {},
          value: {}
        },
        S9: {
          type: "list",
          member: {}
        },
        Sb: {
          type: "list",
          member: {
            type: "structure",
            members: {
              ProviderName: {},
              ClientId: {},
              ServerSideTokenCheck: {
                type: "boolean"
              }
            }
          }
        },
        Sg: {
          type: "list",
          member: {}
        },
        Sh: {
          type: "map",
          key: {},
          value: {}
        },
        Sk: {
          type: "structure",
          required: [
            "IdentityPoolId",
            "IdentityPoolName",
            "AllowUnauthenticatedIdentities"
          ],
          members: {
            IdentityPoolId: {},
            IdentityPoolName: {},
            AllowUnauthenticatedIdentities: {
              type: "boolean"
            },
            AllowClassicFlow: {
              type: "boolean"
            },
            SupportedLoginProviders: {
              shape: "S5"
            },
            DeveloperProviderName: {},
            OpenIdConnectProviderARNs: {
              shape: "S9"
            },
            CognitoIdentityProviders: {
              shape: "Sb"
            },
            SamlProviderARNs: {
              shape: "Sg"
            },
            IdentityPoolTags: {
              shape: "Sh"
            }
          }
        },
        Sv: {
          type: "structure",
          members: {
            IdentityId: {},
            Logins: {
              shape: "Sw"
            },
            CreationDate: {
              type: "timestamp"
            },
            LastModifiedDate: {
              type: "timestamp"
            }
          }
        },
        Sw: {
          type: "list",
          member: {}
        },
        S10: {
          type: "map",
          key: {},
          value: {}
        },
        S1c: {
          type: "map",
          key: {},
          value: {}
        },
        S1e: {
          type: "map",
          key: {},
          value: {
            type: "structure",
            required: [
              "Type"
            ],
            members: {
              Type: {},
              AmbiguousRoleResolution: {},
              RulesConfiguration: {
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    type: "list",
                    member: {
                      type: "structure",
                      required: [
                        "Claim",
                        "MatchType",
                        "Value",
                        "RoleARN"
                      ],
                      members: {
                        Claim: {},
                        MatchType: {},
                        Value: {},
                        RoleARN: {}
                      }
                    }
                  }
                }
              }
            }
          }
        },
        S1s: {
          type: "map",
          key: {},
          value: {}
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json
var require_cognito_identity_2014_06_30_paginators = __commonJS({
  "node_modules/aws-sdk/apis/cognito-identity-2014-06-30.paginators.json"(exports, module) {
    module.exports = {
      pagination: {
        ListIdentityPools: {
          input_token: "NextToken",
          limit_key: "MaxResults",
          output_token: "NextToken",
          result_key: "IdentityPools"
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/cognitoidentity.js
var require_cognitoidentity = __commonJS({
  "node_modules/aws-sdk/clients/cognitoidentity.js"(exports, module) {
    require_browser_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["cognitoidentity"] = {};
    AWS2.CognitoIdentity = Service.defineService("cognitoidentity", ["2014-06-30"]);
    Object.defineProperty(apiLoader.services["cognitoidentity"], "2014-06-30", {
      get: function get() {
        var model = require_cognito_identity_2014_06_30_min();
        model.paginators = require_cognito_identity_2014_06_30_paginators().pagination;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS2.CognitoIdentity;
  }
});

// node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js
var require_cognito_identity_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/cognito_identity_credentials.js"() {
    var AWS2 = require_core();
    var CognitoIdentity = require_cognitoidentity();
    var STS = require_sts2();
    AWS2.CognitoIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * @api private
       */
      localStorageKey: {
        id: "aws.cognito.identity-id.",
        providers: "aws.cognito.identity-providers."
      },
      /**
       * Creates a new credentials object.
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
       *
       *     // either IdentityPoolId or IdentityId is required
       *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
       *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
       *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
       *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
       *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
       *
       *     // optional, only necessary when the identity pool is not configured
       *     // to use IAM roles in the Amazon Cognito Console
       *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
       *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
       *
       *     // optional tokens, used for authenticated login
       *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
       *     Logins: {
       *       'graph.facebook.com': 'FBTOKEN',
       *       'www.amazon.com': 'AMAZONTOKEN',
       *       'accounts.google.com': 'GOOGLETOKEN',
       *       'api.twitter.com': 'TWITTERTOKEN',
       *       'www.digits.com': 'DIGITSTOKEN'
       *     },
       *
       *     // optional name, defaults to web-identity
       *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
       *     RoleSessionName: 'web',
       *
       *     // optional, only necessary when application runs in a browser
       *     // and multiple users are signed in at once, used for caching
       *     LoginId: 'example@gmail.com'
       *
       *   }, {
       *      // optionally provide configuration to apply to the underlying service clients
       *      // if configuration is not provided, then configuration will be pulled from AWS.config
       *
       *      // region should match the region your identity pool is located in
       *      region: 'us-east-1',
       *
       *      // specify timeout options
       *      httpOptions: {
       *        timeout: 100
       *      }
       *   });
       * @see AWS.CognitoIdentity.getId
       * @see AWS.CognitoIdentity.getCredentialsForIdentity
       * @see AWS.STS.assumeRoleWithWebIdentity
       * @see AWS.CognitoIdentity.getOpenIdToken
       * @see AWS.Config
       * @note If a region is not provided in the global AWS.config, or
       *   specified in the `clientConfig` to the CognitoIdentityCredentials
       *   constructor, you may encounter a 'Missing credentials in config' error
       *   when calling making a service call.
       */
      constructor: function CognitoIdentityCredentials(params, clientConfig) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
        this.data = null;
        this._identityId = null;
        this._clientConfig = AWS2.util.copy(clientConfig || {});
        this.loadCachedId();
        var self = this;
        Object.defineProperty(this, "identityId", {
          get: function() {
            self.loadCachedId();
            return self._identityId || self.params.IdentityId;
          },
          set: function(identityId) {
            self._identityId = identityId;
          }
        });
      },
      /**
       * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
       * or {AWS.STS.assumeRoleWithWebIdentity}.
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see AWS.Credentials.get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      /**
       * @api private
       * @param callback
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.data = null;
        self._identityId = null;
        self.getId(function(err) {
          if (!err) {
            if (!self.params.RoleArn) {
              self.getCredentialsForIdentity(callback);
            } else {
              self.getCredentialsFromSTS(callback);
            }
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      /**
       * Clears the cached Cognito ID associated with the currently configured
       * identity pool ID. Use this to manually invalidate your cache if
       * the identity pool ID was deleted.
       */
      clearCachedId: function clearCache() {
        this._identityId = null;
        delete this.params.IdentityId;
        var poolId = this.params.IdentityPoolId;
        var loginId = this.params.LoginId || "";
        delete this.storage[this.localStorageKey.id + poolId + loginId];
        delete this.storage[this.localStorageKey.providers + poolId + loginId];
      },
      /**
       * @api private
       */
      clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
        var self = this;
        if (err.code == "NotAuthorizedException") {
          self.clearCachedId();
        }
      },
      /**
       * Retrieves a Cognito ID, loading from cache if it was already retrieved
       * on this device.
       *
       * @callback callback function(err, identityId)
       *   @param err [Error, null] an error object if the call failed or null if
       *     it succeeded.
       *   @param identityId [String, null] if successful, the callback will return
       *     the Cognito ID.
       * @note If not loaded explicitly, the Cognito ID is loaded and stored in
       *   localStorage in the browser environment of a device.
       * @api private
       */
      getId: function getId(callback) {
        var self = this;
        if (typeof self.params.IdentityId === "string") {
          return callback(null, self.params.IdentityId);
        }
        self.cognito.getId(function(err, data) {
          if (!err && data.IdentityId) {
            self.params.IdentityId = data.IdentityId;
            callback(null, data.IdentityId);
          } else {
            callback(err);
          }
        });
      },
      /**
       * @api private
       */
      loadCredentials: function loadCredentials(data, credentials) {
        if (!data || !credentials)
          return;
        credentials.expired = false;
        credentials.accessKeyId = data.Credentials.AccessKeyId;
        credentials.secretAccessKey = data.Credentials.SecretKey;
        credentials.sessionToken = data.Credentials.SessionToken;
        credentials.expireTime = data.Credentials.Expiration;
      },
      /**
       * @api private
       */
      getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
        var self = this;
        self.cognito.getCredentialsForIdentity(function(err, data) {
          if (!err) {
            self.cacheId(data);
            self.data = data;
            self.loadCredentials(self.data, self);
          } else {
            self.clearIdOnNotAuthorized(err);
          }
          callback(err);
        });
      },
      /**
       * @api private
       */
      getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
        var self = this;
        self.cognito.getOpenIdToken(function(err, data) {
          if (!err) {
            self.cacheId(data);
            self.params.WebIdentityToken = data.Token;
            self.webIdentityCredentials.refresh(function(webErr) {
              if (!webErr) {
                self.data = self.webIdentityCredentials.data;
                self.sts.credentialsFrom(self.data, self);
              }
              callback(webErr);
            });
          } else {
            self.clearIdOnNotAuthorized(err);
            callback(err);
          }
        });
      },
      /**
       * @api private
       */
      loadCachedId: function loadCachedId() {
        var self = this;
        if (AWS2.util.isBrowser() && !self.params.IdentityId) {
          var id = self.getStorage("id");
          if (id && self.params.Logins) {
            var actualProviders = Object.keys(self.params.Logins);
            var cachedProviders = (self.getStorage("providers") || "").split(",");
            var intersect = cachedProviders.filter(function(n) {
              return actualProviders.indexOf(n) !== -1;
            });
            if (intersect.length !== 0) {
              self.params.IdentityId = id;
            }
          } else if (id) {
            self.params.IdentityId = id;
          }
        }
      },
      /**
       * @api private
       */
      createClients: function() {
        var clientConfig = this._clientConfig;
        this.webIdentityCredentials = this.webIdentityCredentials || new AWS2.WebIdentityCredentials(this.params, clientConfig);
        if (!this.cognito) {
          var cognitoConfig = AWS2.util.merge({}, clientConfig);
          cognitoConfig.params = this.params;
          this.cognito = new CognitoIdentity(cognitoConfig);
        }
        this.sts = this.sts || new STS(clientConfig);
      },
      /**
       * @api private
       */
      cacheId: function cacheId(data) {
        this._identityId = data.IdentityId;
        this.params.IdentityId = this._identityId;
        if (AWS2.util.isBrowser()) {
          this.setStorage("id", data.IdentityId);
          if (this.params.Logins) {
            this.setStorage("providers", Object.keys(this.params.Logins).join(","));
          }
        }
      },
      /**
       * @api private
       */
      getStorage: function getStorage(key) {
        return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")];
      },
      /**
       * @api private
       */
      setStorage: function setStorage(key, val) {
        try {
          this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")] = val;
        } catch (_) {
        }
      },
      /**
       * @api private
       */
      storage: function() {
        try {
          var storage = AWS2.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === "object" ? window.localStorage : {};
          storage["aws.test-storage"] = "foobar";
          delete storage["aws.test-storage"];
          return storage;
        } catch (_) {
          return {};
        }
      }()
    });
  }
});

// node_modules/aws-sdk/lib/credentials/saml_credentials.js
var require_saml_credentials = __commonJS({
  "node_modules/aws-sdk/lib/credentials/saml_credentials.js"() {
    var AWS2 = require_core();
    var STS = require_sts2();
    AWS2.SAMLCredentials = AWS2.util.inherit(AWS2.Credentials, {
      /**
       * Creates a new credentials object.
       * @param (see AWS.STS.assumeRoleWithSAML)
       * @example Creating a new credentials object
       *   AWS.config.credentials = new AWS.SAMLCredentials({
       *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
       *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
       *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
       *   });
       * @see AWS.STS.assumeRoleWithSAML
       */
      constructor: function SAMLCredentials(params) {
        AWS2.Credentials.call(this);
        this.expired = true;
        this.params = params;
      },
      /**
       * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
       *
       * @callback callback function(err)
       *   Called when the STS service responds (or fails). When
       *   this callback is called with no error, it means that the credentials
       *   information has been loaded into the object (as the `accessKeyId`,
       *   `secretAccessKey`, and `sessionToken` properties).
       *   @param err [Error] if an error occurred, this value will be filled
       * @see get
       */
      refresh: function refresh(callback) {
        this.coalesceRefresh(callback || AWS2.util.fn.callback);
      },
      /**
       * @api private
       */
      load: function load(callback) {
        var self = this;
        self.createClients();
        self.service.assumeRoleWithSAML(function(err, data) {
          if (!err) {
            self.service.credentialsFrom(data, self);
          }
          callback(err);
        });
      },
      /**
       * @api private
       */
      createClients: function() {
        this.service = this.service || new STS({ params: this.params });
      }
    });
  }
});

// node_modules/aws-sdk/lib/xml/browser_parser.js
var require_browser_parser = __commonJS({
  "node_modules/aws-sdk/lib/xml/browser_parser.js"(exports, module) {
    var util = require_util2();
    var Shape = require_shape();
    function DomXmlParser() {
    }
    DomXmlParser.prototype.parse = function(xml, shape) {
      if (xml.replace(/^\s+/, "") === "")
        return {};
      var result, error;
      try {
        if (window.DOMParser) {
          try {
            var parser = new DOMParser();
            result = parser.parseFromString(xml, "text/xml");
          } catch (syntaxError) {
            throw util.error(
              new Error("Parse error in document"),
              {
                originalError: syntaxError,
                code: "XMLParserError",
                retryable: true
              }
            );
          }
          if (result.documentElement === null) {
            throw util.error(
              new Error("Cannot parse empty document."),
              {
                code: "XMLParserError",
                retryable: true
              }
            );
          }
          var isError = result.getElementsByTagName("parsererror")[0];
          if (isError && (isError.parentNode === result || isError.parentNode.nodeName === "body" || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === "body")) {
            var errorElement = isError.getElementsByTagName("div")[0] || isError;
            throw util.error(
              new Error(errorElement.textContent || "Parser error in document"),
              {
                code: "XMLParserError",
                retryable: true
              }
            );
          }
        } else if (window.ActiveXObject) {
          result = new window.ActiveXObject("Microsoft.XMLDOM");
          result.async = false;
          if (!result.loadXML(xml)) {
            throw util.error(
              new Error("Parse error in document"),
              {
                code: "XMLParserError",
                retryable: true
              }
            );
          }
        } else {
          throw new Error("Cannot load XML parser");
        }
      } catch (e) {
        error = e;
      }
      if (result && result.documentElement && !error) {
        var data = parseXml(result.documentElement, shape);
        var metadata = getElementByTagName(result.documentElement, "ResponseMetadata");
        if (metadata) {
          data.ResponseMetadata = parseXml(metadata, {});
        }
        return data;
      } else if (error) {
        throw util.error(error || new Error(), { code: "XMLParserError", retryable: true });
      } else {
        return {};
      }
    };
    function getElementByTagName(xml, tag) {
      var elements = xml.getElementsByTagName(tag);
      for (var i = 0, iLen = elements.length; i < iLen; i++) {
        if (elements[i].parentNode === xml) {
          return elements[i];
        }
      }
    }
    function parseXml(xml, shape) {
      if (!shape)
        shape = {};
      switch (shape.type) {
        case "structure":
          return parseStructure(xml, shape);
        case "map":
          return parseMap(xml, shape);
        case "list":
          return parseList(xml, shape);
        case void 0:
        case null:
          return parseUnknown(xml);
        default:
          return parseScalar(xml, shape);
      }
    }
    function parseStructure(xml, shape) {
      var data = {};
      if (xml === null)
        return data;
      util.each(shape.members, function(memberName, memberShape) {
        if (memberShape.isXmlAttribute) {
          if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
            var value = xml.attributes[memberShape.name].value;
            data[memberName] = parseXml({ textContent: value }, memberShape);
          }
        } else {
          var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);
          if (xmlChild) {
            data[memberName] = parseXml(xmlChild, memberShape);
          } else if (!memberShape.flattened && memberShape.type === "list" && !shape.api.xmlNoDefaultLists) {
            data[memberName] = memberShape.defaultValue;
          }
        }
      });
      return data;
    }
    function parseMap(xml, shape) {
      var data = {};
      var xmlKey = shape.key.name || "key";
      var xmlValue = shape.value.name || "value";
      var tagName = shape.flattened ? shape.name : "entry";
      var child = xml.firstElementChild;
      while (child) {
        if (child.nodeName === tagName) {
          var key = getElementByTagName(child, xmlKey).textContent;
          var value = getElementByTagName(child, xmlValue);
          data[key] = parseXml(value, shape.value);
        }
        child = child.nextElementSibling;
      }
      return data;
    }
    function parseList(xml, shape) {
      var data = [];
      var tagName = shape.flattened ? shape.name : shape.member.name || "member";
      var child = xml.firstElementChild;
      while (child) {
        if (child.nodeName === tagName) {
          data.push(parseXml(child, shape.member));
        }
        child = child.nextElementSibling;
      }
      return data;
    }
    function parseScalar(xml, shape) {
      if (xml.getAttribute) {
        var encoding = xml.getAttribute("encoding");
        if (encoding === "base64") {
          shape = new Shape.create({ type: encoding });
        }
      }
      var text = xml.textContent;
      if (text === "")
        text = null;
      if (typeof shape.toType === "function") {
        return shape.toType(text);
      } else {
        return text;
      }
    }
    function parseUnknown(xml) {
      if (xml === void 0 || xml === null)
        return "";
      if (!xml.firstElementChild) {
        if (xml.parentNode.parentNode === null)
          return {};
        if (xml.childNodes.length === 0)
          return "";
        else
          return xml.textContent;
      }
      var shape = { type: "structure", members: {} };
      var child = xml.firstElementChild;
      while (child) {
        var tag = child.nodeName;
        if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
          shape.members[tag].type = "list";
        } else {
          shape.members[tag] = { name: tag };
        }
        child = child.nextElementSibling;
      }
      return parseStructure(xml, shape);
    }
    module.exports = DomXmlParser;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || void 0;
    }
    module.exports = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError("n must be a positive number");
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
      if (!this._events)
        this._events = {};
      if (type === "error") {
        if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
        }
      }
      handler = this._events[type];
      if (isUndefined(handler))
        return false;
      if (isFunction(handler)) {
        switch (arguments.length) {
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
      return true;
    };
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
      if (!isFunction(listener))
        throw TypeError("listener must be a function");
      if (!this._events)
        this._events = {};
      if (this._events.newListener)
        this.emit(
          "newListener",
          type,
          isFunction(listener.listener) ? listener.listener : listener
        );
      if (!this._events[type])
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        this._events[type].push(listener);
      else
        this._events[type] = [this._events[type], listener];
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error(
            "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
            this._events[type].length
          );
          if (typeof console.trace === "function") {
            console.trace();
          }
        }
      }
      return this;
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError("listener must be a function");
      var fired = false;
      function g() {
        this.removeListener(type, g);
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
      g.listener = listener;
      this.on(type, g);
      return this;
    };
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
      if (!isFunction(listener))
        throw TypeError("listener must be a function");
      if (!this._events || !this._events[type])
        return this;
      list = this._events[type];
      length = list.length;
      position = -1;
      if (list === listener || isFunction(list.listener) && list.listener === listener) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit("removeListener", type, listener);
      } else if (isObject(list)) {
        for (i = length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
        if (this._events.removeListener)
          this.emit("removeListener", type, listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
      if (!this._events)
        return this;
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = {};
        return this;
      }
      listeners = this._events[type];
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
      return this;
    };
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
        if (isFunction(evlistener))
          return 1;
        else if (evlistener)
          return evlistener.length;
      }
      return 0;
    };
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function isNumber(arg) {
      return typeof arg === "number";
    }
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
  }
});

// node_modules/aws-sdk/lib/http/xhr.js
var require_xhr = __commonJS({
  "node_modules/aws-sdk/lib/http/xhr.js"() {
    var AWS2 = require_core();
    var EventEmitter = require_events().EventEmitter;
    require_http();
    AWS2.XHRClient = AWS2.util.inherit({
      handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
        var self = this;
        var endpoint = httpRequest.endpoint;
        var emitter = new EventEmitter();
        var href = endpoint.protocol + "//" + endpoint.hostname;
        if (endpoint.port !== 80 && endpoint.port !== 443) {
          href += ":" + endpoint.port;
        }
        href += httpRequest.path;
        var xhr = new XMLHttpRequest(), headersEmitted = false;
        httpRequest.stream = xhr;
        xhr.addEventListener("readystatechange", function() {
          try {
            if (xhr.status === 0)
              return;
          } catch (e) {
            return;
          }
          if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
            emitter.statusCode = xhr.status;
            emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());
            emitter.emit(
              "headers",
              emitter.statusCode,
              emitter.headers,
              xhr.statusText
            );
            headersEmitted = true;
          }
          if (this.readyState === this.DONE) {
            self.finishRequest(xhr, emitter);
          }
        }, false);
        xhr.upload.addEventListener("progress", function(evt) {
          emitter.emit("sendProgress", evt);
        });
        xhr.addEventListener("progress", function(evt) {
          emitter.emit("receiveProgress", evt);
        }, false);
        xhr.addEventListener("timeout", function() {
          errCallback(AWS2.util.error(new Error("Timeout"), { code: "TimeoutError" }));
        }, false);
        xhr.addEventListener("error", function() {
          errCallback(AWS2.util.error(new Error("Network Failure"), {
            code: "NetworkingError"
          }));
        }, false);
        xhr.addEventListener("abort", function() {
          errCallback(AWS2.util.error(new Error("Request aborted"), {
            code: "RequestAbortedError"
          }));
        }, false);
        callback(emitter);
        xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
        AWS2.util.each(httpRequest.headers, function(key, value) {
          if (key !== "Content-Length" && key !== "User-Agent" && key !== "Host") {
            xhr.setRequestHeader(key, value);
          }
        });
        if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
          xhr.timeout = httpOptions.timeout;
        }
        if (httpOptions.xhrWithCredentials) {
          xhr.withCredentials = true;
        }
        try {
          xhr.responseType = "arraybuffer";
        } catch (e) {
        }
        try {
          if (httpRequest.body) {
            xhr.send(httpRequest.body);
          } else {
            xhr.send();
          }
        } catch (err) {
          if (httpRequest.body && typeof httpRequest.body.buffer === "object") {
            xhr.send(httpRequest.body.buffer);
          } else {
            throw err;
          }
        }
        return emitter;
      },
      parseHeaders: function parseHeaders(rawHeaders) {
        var headers = {};
        AWS2.util.arrayEach(rawHeaders.split(/\r?\n/), function(line) {
          var key = line.split(":", 1)[0];
          var value = line.substring(key.length + 2);
          if (key.length > 0)
            headers[key.toLowerCase()] = value;
        });
        return headers;
      },
      finishRequest: function finishRequest(xhr, emitter) {
        var buffer;
        if (xhr.responseType === "arraybuffer" && xhr.response) {
          var ab = xhr.response;
          buffer = new AWS2.util.Buffer(ab.byteLength);
          var view = new Uint8Array(ab);
          for (var i = 0; i < buffer.length; ++i) {
            buffer[i] = view[i];
          }
        }
        try {
          if (!buffer && typeof xhr.responseText === "string") {
            buffer = new AWS2.util.Buffer(xhr.responseText);
          }
        } catch (e) {
        }
        if (buffer)
          emitter.emit("data", buffer);
        emitter.emit("end");
      }
    });
    AWS2.HttpClient.prototype = AWS2.XHRClient.prototype;
    AWS2.HttpClient.streamsApiVersion = 1;
  }
});

// node_modules/aws-sdk/lib/browser_loader.js
var require_browser_loader = __commonJS({
  "node_modules/aws-sdk/lib/browser_loader.js"(exports, module) {
    var util = require_util2();
    util.crypto.lib = require_browserCryptoLib();
    util.Buffer = require_buffer().Buffer;
    util.url = require_url();
    util.querystring = require_querystring();
    util.realClock = require_browserClock();
    util.environment = "js";
    util.createEventStream = require_buffered_create_event_stream().createEventStream;
    util.isBrowser = function() {
      return true;
    };
    util.isNode = function() {
      return false;
    };
    var AWS2 = require_core();
    module.exports = AWS2;
    require_credentials();
    require_credential_provider_chain();
    require_temporary_credentials();
    require_chainable_temporary_credentials();
    require_web_identity_credentials();
    require_cognito_identity_credentials();
    require_saml_credentials();
    AWS2.XML.Parser = require_browser_parser();
    require_xhr();
    if (typeof process2 === "undefined") {
      process2 = {
        browser: true
      };
    }
    var process2;
  }
});

// node_modules/aws-sdk/lib/services/s3util.js
var require_s3util = __commonJS({
  "node_modules/aws-sdk/lib/services/s3util.js"(exports, module) {
    var AWS2 = require_core();
    var regionUtil = require_region_config();
    var s3util = {
      /**
       * @api private
       */
      isArnInParam: function isArnInParam(req, paramName) {
        var inputShape = (req.service.api.operations[req.operation] || {}).input || {};
        var inputMembers = inputShape.members || {};
        if (!req.params[paramName] || !inputMembers[paramName])
          return false;
        return AWS2.util.ARN.validate(req.params[paramName]);
      },
      /**
       * Validate service component from ARN supplied in Bucket parameter
       */
      validateArnService: function validateArnService(req) {
        var parsedArn = req._parsedArn;
        if (parsedArn.service !== "s3" && parsedArn.service !== "s3-outposts" && parsedArn.service !== "s3-object-lambda") {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component"
          });
        }
      },
      /**
       * Validate account ID from ARN supplied in Bucket parameter is a valid account
       */
      validateArnAccount: function validateArnAccount(req) {
        var parsedArn = req._parsedArn;
        if (!/[0-9]{12}/.exec(parsedArn.accountId)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: 'ARN accountID does not match regex "[0-9]{12}"'
          });
        }
      },
      /**
       * Validate ARN supplied in Bucket parameter is a valid access point ARN
       */
      validateS3AccessPointArn: function validateS3AccessPointArn(req) {
        var parsedArn = req._parsedArn;
        var delimiter = parsedArn.resource["accesspoint".length];
        if (parsedArn.resource.split(delimiter).length !== 2) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access Point ARN should have one resource accesspoint/{accesspointName}"
          });
        }
        var accessPoint = parsedArn.resource.split(delimiter)[1];
        var accessPointPrefix = accessPoint + "-" + parsedArn.accountId;
        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access point resource in ARN is not DNS compatible. Got " + accessPoint
          });
        }
        req._parsedArn.accessPoint = accessPoint;
      },
      /**
       * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
       */
      validateOutpostsArn: function validateOutpostsArn(req) {
        var parsedArn = req._parsedArn;
        if (parsedArn.resource.indexOf("outpost:") !== 0 && parsedArn.resource.indexOf("outpost/") !== 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "ARN resource should begin with 'outpost/'"
          });
        }
        var delimiter = parsedArn.resource["outpost".length];
        var outpostId = parsedArn.resource.split(delimiter)[1];
        var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
        if (!dnsHostRegex.test(outpostId)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Outpost resource in ARN is not DNS compatible. Got " + outpostId
          });
        }
        req._parsedArn.outpostId = outpostId;
      },
      /**
       * Validate Outposts ARN supplied in Bucket parameter is a valid outposts ARN
       */
      validateOutpostsAccessPointArn: function validateOutpostsAccessPointArn(req) {
        var parsedArn = req._parsedArn;
        var delimiter = parsedArn.resource["outpost".length];
        if (parsedArn.resource.split(delimiter).length !== 4) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Outposts ARN should have two resources outpost/{outpostId}/accesspoint/{accesspointName}"
          });
        }
        var accessPoint = parsedArn.resource.split(delimiter)[3];
        var accessPointPrefix = accessPoint + "-" + parsedArn.accountId;
        if (!s3util.dnsCompatibleBucketName(accessPointPrefix) || accessPointPrefix.match(/\./)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "Access point resource in ARN is not DNS compatible. Got " + accessPoint
          });
        }
        req._parsedArn.accessPoint = accessPoint;
      },
      /**
       * Validate region field in ARN supplied in Bucket parameter is a valid region
       */
      validateArnRegion: function validateArnRegion(req, options) {
        if (options === void 0) {
          options = {};
        }
        var useArnRegion = s3util.loadUseArnRegionConfig(req);
        var regionFromArn = req._parsedArn.region;
        var clientRegion = req.service.config.region;
        var useFipsEndpoint = req.service.config.useFipsEndpoint;
        var allowFipsEndpoint = options.allowFipsEndpoint || false;
        if (!regionFromArn) {
          var message = "ARN region is empty";
          if (req._parsedArn.service === "s3") {
            message = message + "\nYou may want to use multi-regional ARN. The feature is not supported in current SDK. You should consider switching to V3(https://github.com/aws/aws-sdk-js-v3).";
          }
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message
          });
        }
        if (useFipsEndpoint && !allowFipsEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "ARN endpoint is not compatible with FIPS region"
          });
        }
        if (regionFromArn.indexOf("fips") >= 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "FIPS region not allowed in ARN"
          });
        }
        if (!useArnRegion && regionFromArn !== clientRegion) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Configured region conflicts with access point region"
          });
        } else if (useArnRegion && regionUtil.getEndpointSuffix(regionFromArn) !== regionUtil.getEndpointSuffix(clientRegion)) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Configured region and access point region not in same partition"
          });
        }
        if (req.service.config.useAccelerateEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "useAccelerateEndpoint config is not supported with access point ARN"
          });
        }
        if (req._parsedArn.service === "s3-outposts" && req.service.config.useDualstackEndpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Dualstack is not supported with outposts access point ARN"
          });
        }
      },
      loadUseArnRegionConfig: function loadUseArnRegionConfig(req) {
        var envName = "AWS_S3_USE_ARN_REGION";
        var configName = "s3_use_arn_region";
        var useArnRegion = true;
        var originalConfig = req.service._originalConfig || {};
        if (req.service.config.s3UseArnRegion !== void 0) {
          return req.service.config.s3UseArnRegion;
        } else if (originalConfig.s3UseArnRegion !== void 0) {
          useArnRegion = originalConfig.s3UseArnRegion === true;
        } else if (AWS2.util.isNode()) {
          if (process.env[envName]) {
            var value = process.env[envName].trim().toLowerCase();
            if (["false", "true"].indexOf(value) < 0) {
              throw AWS2.util.error(new Error(), {
                code: "InvalidConfiguration",
                message: envName + " only accepts true or false. Got " + process.env[envName],
                retryable: false
              });
            }
            useArnRegion = value === "true";
          } else {
            var profiles = {};
            var profile = {};
            try {
              profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
              profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
            } catch (e) {
            }
            if (profile[configName]) {
              if (["false", "true"].indexOf(profile[configName].trim().toLowerCase()) < 0) {
                throw AWS2.util.error(new Error(), {
                  code: "InvalidConfiguration",
                  message: configName + " only accepts true or false. Got " + profile[configName],
                  retryable: false
                });
              }
              useArnRegion = profile[configName].trim().toLowerCase() === "true";
            }
          }
        }
        req.service.config.s3UseArnRegion = useArnRegion;
        return useArnRegion;
      },
      /**
       * Validations before URI can be populated
       */
      validatePopulateUriFromArn: function validatePopulateUriFromArn(req) {
        if (req.service._originalConfig && req.service._originalConfig.endpoint) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Custom endpoint is not compatible with access point ARN"
          });
        }
        if (req.service.config.s3ForcePathStyle) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidConfiguration",
            message: "Cannot construct path-style endpoint with access point"
          });
        }
      },
      /**
       * Returns true if the bucket name is DNS compatible.  Buckets created
       * outside of the classic region MUST be DNS compatible.
       *
       * @api private
       */
      dnsCompatibleBucketName: function dnsCompatibleBucketName(bucketName) {
        var b = bucketName;
        var domain = new RegExp(/^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/);
        var ipAddress = new RegExp(/(\d+\.){3}\d+/);
        var dots = new RegExp(/\.\./);
        return b.match(domain) && !b.match(ipAddress) && !b.match(dots) ? true : false;
      }
    };
    module.exports = s3util;
  }
});

// node_modules/aws-sdk/lib/s3/managed_upload.js
var require_managed_upload = __commonJS({
  "node_modules/aws-sdk/lib/s3/managed_upload.js"(exports, module) {
    var AWS2 = require_core();
    var byteLength = AWS2.util.string.byteLength;
    var Buffer = AWS2.util.Buffer;
    AWS2.S3.ManagedUpload = AWS2.util.inherit({
      /**
       * Creates a managed upload object with a set of configuration options.
       *
       * @note A "Body" parameter is required to be set prior to calling {send}.
       * @note In Node.js, sending "Body" as {https://nodejs.org/dist/latest/docs/api/stream.html#stream_object_mode object-mode stream}
       *   may result in upload hangs. Using buffer stream is preferable.
       * @option options params [map] a map of parameters to pass to the upload
       *   requests. The "Body" parameter is required to be specified either on
       *   the service or in the params option.
       * @note ContentMD5 should not be provided when using the managed upload object.
       *   Instead, setting "computeChecksums" to true will enable automatic ContentMD5 generation
       *   by the managed upload object.
       * @option options queueSize [Number] (4) the size of the concurrent queue
       *   manager to upload parts in parallel. Set to 1 for synchronous uploading
       *   of parts. Note that the uploader will buffer at most queueSize * partSize
       *   bytes into memory at any given time.
       * @option options partSize [Number] (5mb) the size in bytes for each
       *   individual part to be uploaded. Adjust the part size to ensure the number
       *   of parts does not exceed {maxTotalParts}. See {minPartSize} for the
       *   minimum allowed part size.
       * @option options leavePartsOnError [Boolean] (false) whether to abort the
       *   multipart upload if an error occurs. Set to true if you want to handle
       *   failures manually.
       * @option options service [AWS.S3] an optional S3 service object to use for
       *   requests. This object might have bound parameters used by the uploader.
       * @option options tags [Array<map>] The tags to apply to the uploaded object.
       *   Each tag should have a `Key` and `Value` keys.
       * @example Creating a default uploader for a stream object
       *   var upload = new AWS.S3.ManagedUpload({
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
       *   });
       * @example Creating an uploader with concurrency of 1 and partSize of 10mb
       *   var upload = new AWS.S3.ManagedUpload({
       *     partSize: 10 * 1024 * 1024, queueSize: 1,
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream}
       *   });
       * @example Creating an uploader with tags
       *   var upload = new AWS.S3.ManagedUpload({
       *     params: {Bucket: 'bucket', Key: 'key', Body: stream},
       *     tags: [{Key: 'tag1', Value: 'value1'}, {Key: 'tag2', Value: 'value2'}]
       *   });
       * @see send
       */
      constructor: function ManagedUpload(options) {
        var self = this;
        AWS2.SequentialExecutor.call(self);
        self.body = null;
        self.sliceFn = null;
        self.callback = null;
        self.parts = {};
        self.completeInfo = [];
        self.fillQueue = function() {
          self.callback(new Error("Unsupported body payload " + typeof self.body));
        };
        self.configure(options);
      },
      /**
       * @api private
       */
      configure: function configure(options) {
        options = options || {};
        this.partSize = this.minPartSize;
        if (options.queueSize)
          this.queueSize = options.queueSize;
        if (options.partSize)
          this.partSize = options.partSize;
        if (options.leavePartsOnError)
          this.leavePartsOnError = true;
        if (options.tags) {
          if (!Array.isArray(options.tags)) {
            throw new Error("Tags must be specified as an array; " + typeof options.tags + " provided.");
          }
          this.tags = options.tags;
        }
        if (this.partSize < this.minPartSize) {
          throw new Error("partSize must be greater than " + this.minPartSize);
        }
        this.service = options.service;
        this.bindServiceObject(options.params);
        this.validateBody();
        this.adjustTotalBytes();
      },
      /**
       * @api private
       */
      leavePartsOnError: false,
      /**
       * @api private
       */
      queueSize: 4,
      /**
       * @api private
       */
      partSize: null,
      /**
       * @readonly
       * @return [Number] the minimum number of bytes for an individual part
       *   upload.
       */
      minPartSize: 1024 * 1024 * 5,
      /**
       * @readonly
       * @return [Number] the maximum allowed number of parts in a multipart upload.
       */
      maxTotalParts: 1e4,
      /**
       * Initiates the managed upload for the payload.
       *
       * @callback callback function(err, data)
       *   @param err [Error] an error or null if no error occurred.
       *   @param data [map] The response data from the successful upload:
       *     * `Location` (String) the URL of the uploaded object
       *     * `ETag` (String) the ETag of the uploaded object
       *     * `Bucket` (String) the bucket to which the object was uploaded
       *     * `Key` (String) the key to which the object was uploaded
       * @example Sending a managed upload object
       *   var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *   var upload = new AWS.S3.ManagedUpload({params: params});
       *   upload.send(function(err, data) {
       *     console.log(err, data);
       *   });
       */
      send: function(callback) {
        var self = this;
        self.failed = false;
        self.callback = callback || function(err) {
          if (err)
            throw err;
        };
        var runFill = true;
        if (self.sliceFn) {
          self.fillQueue = self.fillBuffer;
        } else if (AWS2.util.isNode()) {
          var Stream = AWS2.util.stream.Stream;
          if (self.body instanceof Stream) {
            runFill = false;
            self.fillQueue = self.fillStream;
            self.partBuffers = [];
            self.body.on("error", function(err) {
              self.cleanup(err);
            }).on("readable", function() {
              self.fillQueue();
            }).on("end", function() {
              self.isDoneChunking = true;
              self.numParts = self.totalPartNumbers;
              self.fillQueue.call(self);
              if (self.isDoneChunking && self.totalPartNumbers >= 1 && self.doneParts === self.numParts) {
                self.finishMultiPart();
              }
            });
          }
        }
        if (runFill)
          self.fillQueue.call(self);
      },
      /**
       * @!method  promise()
       *   Returns a 'thenable' promise.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @callback fulfilledCallback function(data)
       *     Called if the promise is fulfilled.
       *     @param data [map] The response data from the successful upload:
       *       `Location` (String) the URL of the uploaded object
       *       `ETag` (String) the ETag of the uploaded object
       *       `Bucket` (String) the bucket to which the object was uploaded
       *       `Key` (String) the key to which the object was uploaded
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] an error or null if no error occurred.
       *   @return [Promise] A promise that represents the state of the upload request.
       *   @example Sending an upload request using promises.
       *     var upload = s3.upload({Bucket: 'bucket', Key: 'key', Body: stream});
       *     var promise = upload.promise();
       *     promise.then(function(data) { ... }, function(err) { ... });
       */
      /**
       * Aborts a managed upload, including all concurrent upload requests.
       * @note By default, calling this function will cleanup a multipart upload
       *   if one was created. To leave the multipart upload around after aborting
       *   a request, configure `leavePartsOnError` to `true` in the {constructor}.
       * @note Calling {abort} in the browser environment will not abort any requests
       *   that are already in flight. If a multipart upload was created, any parts
       *   not yet uploaded will not be sent, and the multipart upload will be cleaned up.
       * @example Aborting an upload
       *   var params = {
       *     Bucket: 'bucket', Key: 'key',
       *     Body: Buffer.alloc(1024 * 1024 * 25) // 25MB payload
       *   };
       *   var upload = s3.upload(params);
       *   upload.send(function (err, data) {
       *     if (err) console.log("Error:", err.code, err.message);
       *     else console.log(data);
       *   });
       *
       *   // abort request in 1 second
       *   setTimeout(upload.abort.bind(upload), 1000);
       */
      abort: function() {
        var self = this;
        if (self.isDoneChunking === true && self.totalPartNumbers === 1 && self.singlePart) {
          self.singlePart.abort();
        } else {
          self.cleanup(AWS2.util.error(new Error("Request aborted by user"), {
            code: "RequestAbortedError",
            retryable: false
          }));
        }
      },
      /**
       * @api private
       */
      validateBody: function validateBody() {
        var self = this;
        self.body = self.service.config.params.Body;
        if (typeof self.body === "string") {
          self.body = AWS2.util.buffer.toBuffer(self.body);
        } else if (!self.body) {
          throw new Error("params.Body is required");
        }
        self.sliceFn = AWS2.util.arraySliceFn(self.body);
      },
      /**
       * @api private
       */
      bindServiceObject: function bindServiceObject(params) {
        params = params || {};
        var self = this;
        if (!self.service) {
          self.service = new AWS2.S3({ params });
        } else {
          var service = self.service;
          var config = AWS2.util.copy(service.config);
          config.signatureVersion = service.getSignatureVersion();
          self.service = new service.constructor.__super__(config);
          self.service.config.params = AWS2.util.merge(self.service.config.params || {}, params);
          Object.defineProperty(self.service, "_originalConfig", {
            get: function() {
              return service._originalConfig;
            },
            enumerable: false,
            configurable: true
          });
        }
      },
      /**
       * @api private
       */
      adjustTotalBytes: function adjustTotalBytes() {
        var self = this;
        try {
          self.totalBytes = byteLength(self.body);
        } catch (e) {
        }
        if (self.totalBytes) {
          var newPartSize = Math.ceil(self.totalBytes / self.maxTotalParts);
          if (newPartSize > self.partSize)
            self.partSize = newPartSize;
        } else {
          self.totalBytes = void 0;
        }
      },
      /**
       * @api private
       */
      isDoneChunking: false,
      /**
       * @api private
       */
      partPos: 0,
      /**
       * @api private
       */
      totalChunkedBytes: 0,
      /**
       * @api private
       */
      totalUploadedBytes: 0,
      /**
       * @api private
       */
      totalBytes: void 0,
      /**
       * @api private
       */
      numParts: 0,
      /**
       * @api private
       */
      totalPartNumbers: 0,
      /**
       * @api private
       */
      activeParts: 0,
      /**
       * @api private
       */
      doneParts: 0,
      /**
       * @api private
       */
      parts: null,
      /**
       * @api private
       */
      completeInfo: null,
      /**
       * @api private
       */
      failed: false,
      /**
       * @api private
       */
      multipartReq: null,
      /**
       * @api private
       */
      partBuffers: null,
      /**
       * @api private
       */
      partBufferLength: 0,
      /**
       * @api private
       */
      fillBuffer: function fillBuffer() {
        var self = this;
        var bodyLen = byteLength(self.body);
        if (bodyLen === 0) {
          self.isDoneChunking = true;
          self.numParts = 1;
          self.nextChunk(self.body);
          return;
        }
        while (self.activeParts < self.queueSize && self.partPos < bodyLen) {
          var endPos = Math.min(self.partPos + self.partSize, bodyLen);
          var buf = self.sliceFn.call(self.body, self.partPos, endPos);
          self.partPos += self.partSize;
          if (byteLength(buf) < self.partSize || self.partPos === bodyLen) {
            self.isDoneChunking = true;
            self.numParts = self.totalPartNumbers + 1;
          }
          self.nextChunk(buf);
        }
      },
      /**
       * @api private
       */
      fillStream: function fillStream() {
        var self = this;
        if (self.activeParts >= self.queueSize)
          return;
        var buf = self.body.read(self.partSize - self.partBufferLength) || self.body.read();
        if (buf) {
          self.partBuffers.push(buf);
          self.partBufferLength += buf.length;
          self.totalChunkedBytes += buf.length;
        }
        if (self.partBufferLength >= self.partSize) {
          var pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);
          self.partBuffers = [];
          self.partBufferLength = 0;
          if (pbuf.length > self.partSize) {
            var rest = pbuf.slice(self.partSize);
            self.partBuffers.push(rest);
            self.partBufferLength += rest.length;
            pbuf = pbuf.slice(0, self.partSize);
          }
          self.nextChunk(pbuf);
        }
        if (self.isDoneChunking && !self.isDoneSending) {
          pbuf = self.partBuffers.length === 1 ? self.partBuffers[0] : Buffer.concat(self.partBuffers);
          self.partBuffers = [];
          self.partBufferLength = 0;
          self.totalBytes = self.totalChunkedBytes;
          self.isDoneSending = true;
          if (self.numParts === 0 || pbuf.length > 0) {
            self.numParts++;
            self.nextChunk(pbuf);
          }
        }
        self.body.read(0);
      },
      /**
       * @api private
       */
      nextChunk: function nextChunk(chunk) {
        var self = this;
        if (self.failed)
          return null;
        var partNumber = ++self.totalPartNumbers;
        if (self.isDoneChunking && partNumber === 1) {
          var params = { Body: chunk };
          if (this.tags) {
            params.Tagging = this.getTaggingHeader();
          }
          var req = self.service.putObject(params);
          req._managedUpload = self;
          req.on("httpUploadProgress", self.progress).send(self.finishSinglePart);
          self.singlePart = req;
          return null;
        } else if (self.service.config.params.ContentMD5) {
          var err = AWS2.util.error(new Error("The Content-MD5 you specified is invalid for multi-part uploads."), {
            code: "InvalidDigest",
            retryable: false
          });
          self.cleanup(err);
          return null;
        }
        if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null) {
          return null;
        }
        self.activeParts++;
        if (!self.service.config.params.UploadId) {
          if (!self.multipartReq) {
            self.multipartReq = self.service.createMultipartUpload();
            self.multipartReq.on("success", function(resp) {
              self.service.config.params.UploadId = resp.data.UploadId;
              self.multipartReq = null;
            });
            self.queueChunks(chunk, partNumber);
            self.multipartReq.on("error", function(err2) {
              self.cleanup(err2);
            });
            self.multipartReq.send();
          } else {
            self.queueChunks(chunk, partNumber);
          }
        } else {
          self.uploadPart(chunk, partNumber);
        }
      },
      /**
       * @api private
       */
      getTaggingHeader: function getTaggingHeader() {
        var kvPairStrings = [];
        for (var i = 0; i < this.tags.length; i++) {
          kvPairStrings.push(AWS2.util.uriEscape(this.tags[i].Key) + "=" + AWS2.util.uriEscape(this.tags[i].Value));
        }
        return kvPairStrings.join("&");
      },
      /**
       * @api private
       */
      uploadPart: function uploadPart(chunk, partNumber) {
        var self = this;
        var partParams = {
          Body: chunk,
          ContentLength: AWS2.util.string.byteLength(chunk),
          PartNumber: partNumber
        };
        var partInfo = { ETag: null, PartNumber: partNumber };
        self.completeInfo[partNumber] = partInfo;
        var req = self.service.uploadPart(partParams);
        self.parts[partNumber] = req;
        req._lastUploadedBytes = 0;
        req._managedUpload = self;
        req.on("httpUploadProgress", self.progress);
        req.send(function(err, data) {
          delete self.parts[partParams.PartNumber];
          self.activeParts--;
          if (!err && (!data || !data.ETag)) {
            var message = "No access to ETag property on response.";
            if (AWS2.util.isBrowser()) {
              message += " Check CORS configuration to expose ETag header.";
            }
            err = AWS2.util.error(new Error(message), {
              code: "ETagMissing",
              retryable: false
            });
          }
          if (err)
            return self.cleanup(err);
          if (self.completeInfo[partNumber] && self.completeInfo[partNumber].ETag !== null)
            return null;
          partInfo.ETag = data.ETag;
          self.doneParts++;
          if (self.isDoneChunking && self.doneParts === self.totalPartNumbers) {
            self.finishMultiPart();
          } else {
            self.fillQueue.call(self);
          }
        });
      },
      /**
       * @api private
       */
      queueChunks: function queueChunks(chunk, partNumber) {
        var self = this;
        self.multipartReq.on("success", function() {
          self.uploadPart(chunk, partNumber);
        });
      },
      /**
       * @api private
       */
      cleanup: function cleanup(err) {
        var self = this;
        if (self.failed)
          return;
        if (typeof self.body.removeAllListeners === "function" && typeof self.body.resume === "function") {
          self.body.removeAllListeners("readable");
          self.body.removeAllListeners("end");
          self.body.resume();
        }
        if (self.multipartReq) {
          self.multipartReq.removeAllListeners("success");
          self.multipartReq.removeAllListeners("error");
          self.multipartReq.removeAllListeners("complete");
          delete self.multipartReq;
        }
        if (self.service.config.params.UploadId && !self.leavePartsOnError) {
          self.service.abortMultipartUpload().send();
        } else if (self.leavePartsOnError) {
          self.isDoneChunking = false;
        }
        AWS2.util.each(self.parts, function(partNumber, part) {
          part.removeAllListeners("complete");
          part.abort();
        });
        self.activeParts = 0;
        self.partPos = 0;
        self.numParts = 0;
        self.totalPartNumbers = 0;
        self.parts = {};
        self.failed = true;
        self.callback(err);
      },
      /**
       * @api private
       */
      finishMultiPart: function finishMultiPart() {
        var self = this;
        var completeParams = { MultipartUpload: { Parts: self.completeInfo.slice(1) } };
        self.service.completeMultipartUpload(completeParams, function(err, data) {
          if (err) {
            return self.cleanup(err);
          }
          if (data && typeof data.Location === "string") {
            data.Location = data.Location.replace(/%2F/g, "/");
          }
          if (Array.isArray(self.tags)) {
            for (var i = 0; i < self.tags.length; i++) {
              self.tags[i].Value = String(self.tags[i].Value);
            }
            self.service.putObjectTagging(
              { Tagging: { TagSet: self.tags } },
              function(e, d) {
                if (e) {
                  self.callback(e);
                } else {
                  self.callback(e, data);
                }
              }
            );
          } else {
            self.callback(err, data);
          }
        });
      },
      /**
       * @api private
       */
      finishSinglePart: function finishSinglePart(err, data) {
        var upload = this.request._managedUpload;
        var httpReq = this.request.httpRequest;
        var endpoint = httpReq.endpoint;
        if (err)
          return upload.callback(err);
        data.Location = [endpoint.protocol, "//", endpoint.host, httpReq.path].join("");
        data.key = this.request.params.Key;
        data.Key = this.request.params.Key;
        data.Bucket = this.request.params.Bucket;
        upload.callback(err, data);
      },
      /**
       * @api private
       */
      progress: function progress(info) {
        var upload = this._managedUpload;
        if (this.operation === "putObject") {
          info.part = 1;
          info.key = this.params.Key;
        } else {
          upload.totalUploadedBytes += info.loaded - this._lastUploadedBytes;
          this._lastUploadedBytes = info.loaded;
          info = {
            loaded: upload.totalUploadedBytes,
            total: upload.totalBytes,
            part: this.params.PartNumber,
            key: this.params.Key
          };
        }
        upload.emit("httpUploadProgress", [info]);
      }
    });
    AWS2.util.mixin(AWS2.S3.ManagedUpload, AWS2.SequentialExecutor);
    AWS2.S3.ManagedUpload.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.promise = AWS2.util.promisifyMethod("send", PromiseDependency);
    };
    AWS2.S3.ManagedUpload.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.promise;
    };
    AWS2.util.addPromises(AWS2.S3.ManagedUpload);
    module.exports = AWS2.S3.ManagedUpload;
  }
});

// node_modules/aws-sdk/lib/services/s3.js
var require_s32 = __commonJS({
  "node_modules/aws-sdk/lib/services/s3.js"() {
    var AWS2 = require_core();
    var v4Credentials = require_v4_credentials();
    var resolveRegionalEndpointsFlag = require_config_regional_endpoint();
    var s3util = require_s3util();
    var regionUtil = require_region_config();
    require_managed_upload();
    var operationsWith200StatusCodeError = {
      "completeMultipartUpload": true,
      "copyObject": true,
      "uploadPartCopy": true
    };
    var regionRedirectErrorCodes = [
      "AuthorizationHeaderMalformed",
      // non-head operations on virtual-hosted global bucket endpoints
      "BadRequest",
      // head operations on virtual-hosted global bucket endpoints
      "PermanentRedirect",
      // non-head operations on path-style or regional endpoints
      301
      // head operations on path-style or regional endpoints
    ];
    var OBJECT_LAMBDA_SERVICE = "s3-object-lambda";
    AWS2.util.update(AWS2.S3.prototype, {
      /**
       * @api private
       */
      getSignatureVersion: function getSignatureVersion(request) {
        var defaultApiVersion = this.api.signatureVersion;
        var userDefinedVersion = this._originalConfig ? this._originalConfig.signatureVersion : null;
        var regionDefinedVersion = this.config.signatureVersion;
        var isPresigned = request ? request.isPresigned() : false;
        if (userDefinedVersion) {
          userDefinedVersion = userDefinedVersion === "v2" ? "s3" : userDefinedVersion;
          return userDefinedVersion;
        }
        if (isPresigned !== true) {
          defaultApiVersion = "v4";
        } else if (regionDefinedVersion) {
          defaultApiVersion = regionDefinedVersion;
        }
        return defaultApiVersion;
      },
      /**
       * @api private
       */
      getSigningName: function getSigningName(req) {
        if (req && req.operation === "writeGetObjectResponse") {
          return OBJECT_LAMBDA_SERVICE;
        }
        var _super = AWS2.Service.prototype.getSigningName;
        return req && req._parsedArn && req._parsedArn.service ? req._parsedArn.service : _super.call(this);
      },
      /**
       * @api private
       */
      getSignerClass: function getSignerClass(request) {
        var signatureVersion = this.getSignatureVersion(request);
        return AWS2.Signers.RequestSigner.getVersion(signatureVersion);
      },
      /**
       * @api private
       */
      validateService: function validateService() {
        var msg;
        var messages = [];
        if (!this.config.region)
          this.config.region = "us-east-1";
        if (!this.config.endpoint && this.config.s3BucketEndpoint) {
          messages.push("An endpoint must be provided when configuring `s3BucketEndpoint` to true.");
        }
        if (messages.length === 1) {
          msg = messages[0];
        } else if (messages.length > 1) {
          msg = "Multiple configuration errors:\n" + messages.join("\n");
        }
        if (msg) {
          throw AWS2.util.error(
            new Error(),
            { name: "InvalidEndpoint", message: msg }
          );
        }
      },
      /**
       * @api private
       */
      shouldDisableBodySigning: function shouldDisableBodySigning(request) {
        var signerClass = this.getSignerClass();
        if (this.config.s3DisableBodySigning === true && signerClass === AWS2.Signers.V4 && request.httpRequest.endpoint.protocol === "https:") {
          return true;
        }
        return false;
      },
      /**
       * @api private
       */
      setupRequestListeners: function setupRequestListeners(request) {
        request.addListener("validateResponse", this.setExpiresString);
        var prependListener = true;
        request.addListener("validate", this.validateScheme);
        request.addListener("validate", this.validateBucketName, prependListener);
        request.addListener("validate", this.optInUsEast1RegionalEndpoint, prependListener);
        request.removeListener(
          "validate",
          AWS2.EventListeners.Core.VALIDATE_REGION
        );
        request.addListener("build", this.addContentType);
        request.addListener("build", this.computeContentMd5);
        request.addListener("build", this.computeSseCustomerKeyMd5);
        request.addListener("build", this.populateURI);
        request.addListener("afterBuild", this.addExpect100Continue);
        request.addListener("extractError", this.extractError);
        request.addListener("extractData", AWS2.util.hoistPayloadMember);
        request.addListener("extractData", this.extractData);
        request.addListener("extractData", this.extractErrorFrom200Response);
        request.addListener("beforePresign", this.prepareSignedUrl);
        if (this.shouldDisableBodySigning(request)) {
          request.removeListener("afterBuild", AWS2.EventListeners.Core.COMPUTE_SHA256);
          request.addListener("afterBuild", this.disableBodySigning);
        }
        if (request.operation !== "createBucket" && s3util.isArnInParam(request, "Bucket")) {
          request._parsedArn = AWS2.util.ARN.parse(request.params.Bucket);
          request.removeListener("validate", this.validateBucketName);
          request.removeListener("build", this.populateURI);
          if (request._parsedArn.service === "s3") {
            request.addListener("validate", s3util.validateS3AccessPointArn);
            request.addListener("validate", this.validateArnResourceType);
            request.addListener("validate", this.validateArnRegion);
          } else if (request._parsedArn.service === "s3-outposts") {
            request.addListener("validate", s3util.validateOutpostsAccessPointArn);
            request.addListener("validate", s3util.validateOutpostsArn);
            request.addListener("validate", s3util.validateArnRegion);
          }
          request.addListener("validate", s3util.validateArnAccount);
          request.addListener("validate", s3util.validateArnService);
          request.addListener("build", this.populateUriFromAccessPointArn);
          request.addListener("build", s3util.validatePopulateUriFromArn);
          return;
        }
        request.addListener("validate", this.validateBucketEndpoint);
        request.addListener("validate", this.correctBucketRegionFromCache);
        request.onAsync("extractError", this.requestBucketRegion);
        if (AWS2.util.isBrowser()) {
          request.onAsync("retry", this.reqRegionForNetworkingError);
        }
      },
      /**
       * @api private
       */
      validateScheme: function(req) {
        var params = req.params, scheme = req.httpRequest.endpoint.protocol, sensitive = params.SSECustomerKey || params.CopySourceSSECustomerKey;
        if (sensitive && scheme !== "https:") {
          var msg = "Cannot send SSE keys over HTTP. Set 'sslEnabled'to 'true' in your configuration";
          throw AWS2.util.error(
            new Error(),
            { code: "ConfigError", message: msg }
          );
        }
      },
      /**
       * @api private
       */
      validateBucketEndpoint: function(req) {
        if (!req.params.Bucket && req.service.config.s3BucketEndpoint) {
          var msg = "Cannot send requests to root API with `s3BucketEndpoint` set.";
          throw AWS2.util.error(
            new Error(),
            { code: "ConfigError", message: msg }
          );
        }
      },
      /**
       * @api private
       */
      validateArnRegion: function validateArnRegion(req) {
        s3util.validateArnRegion(req, { allowFipsEndpoint: true });
      },
      /**
       * Validate resource-type supplied in S3 ARN
       */
      validateArnResourceType: function validateArnResourceType(req) {
        var resource = req._parsedArn.resource;
        if (resource.indexOf("accesspoint:") !== 0 && resource.indexOf("accesspoint/") !== 0) {
          throw AWS2.util.error(new Error(), {
            code: "InvalidARN",
            message: "ARN resource should begin with 'accesspoint/'"
          });
        }
      },
      /**
       * @api private
       */
      validateBucketName: function validateBucketName(req) {
        var service = req.service;
        var signatureVersion = service.getSignatureVersion(req);
        var bucket = req.params && req.params.Bucket;
        var key = req.params && req.params.Key;
        var slashIndex = bucket && bucket.indexOf("/");
        if (bucket && slashIndex >= 0) {
          if (typeof key === "string" && slashIndex > 0) {
            req.params = AWS2.util.copy(req.params);
            var prefix = bucket.substr(slashIndex + 1) || "";
            req.params.Key = prefix + "/" + key;
            req.params.Bucket = bucket.substr(0, slashIndex);
          } else if (signatureVersion === "v4") {
            var msg = "Bucket names cannot contain forward slashes. Bucket: " + bucket;
            throw AWS2.util.error(
              new Error(),
              { code: "InvalidBucket", message: msg }
            );
          }
        }
      },
      /**
       * @api private
       */
      isValidAccelerateOperation: function isValidAccelerateOperation(operation) {
        var invalidOperations = [
          "createBucket",
          "deleteBucket",
          "listBuckets"
        ];
        return invalidOperations.indexOf(operation) === -1;
      },
      /**
       * When us-east-1 region endpoint configuration is set, in stead of sending request to
       * global endpoint(e.g. 's3.amazonaws.com'), we will send request to
       * 's3.us-east-1.amazonaws.com'.
       * @api private
       */
      optInUsEast1RegionalEndpoint: function optInUsEast1RegionalEndpoint(req) {
        var service = req.service;
        var config = service.config;
        config.s3UsEast1RegionalEndpoint = resolveRegionalEndpointsFlag(service._originalConfig, {
          env: "AWS_S3_US_EAST_1_REGIONAL_ENDPOINT",
          sharedConfig: "s3_us_east_1_regional_endpoint",
          clientConfig: "s3UsEast1RegionalEndpoint"
        });
        if (!(service._originalConfig || {}).endpoint && req.httpRequest.region === "us-east-1" && config.s3UsEast1RegionalEndpoint === "regional" && req.httpRequest.endpoint.hostname.indexOf("s3.amazonaws.com") >= 0) {
          var insertPoint = config.endpoint.indexOf(".amazonaws.com");
          var regionalEndpoint = config.endpoint.substring(0, insertPoint) + ".us-east-1" + config.endpoint.substring(insertPoint);
          req.httpRequest.updateEndpoint(regionalEndpoint);
        }
      },
      /**
       * S3 prefers dns-compatible bucket names to be moved from the uri path
       * to the hostname as a sub-domain.  This is not possible, even for dns-compat
       * buckets when using SSL and the bucket name contains a dot ('.').  The
       * ssl wildcard certificate is only 1-level deep.
       *
       * @api private
       */
      populateURI: function populateURI(req) {
        var httpRequest = req.httpRequest;
        var b = req.params.Bucket;
        var service = req.service;
        var endpoint = httpRequest.endpoint;
        if (b) {
          if (!service.pathStyleBucketName(b)) {
            if (service.config.useAccelerateEndpoint && service.isValidAccelerateOperation(req.operation)) {
              if (service.config.useDualstackEndpoint) {
                endpoint.hostname = b + ".s3-accelerate.dualstack.amazonaws.com";
              } else {
                endpoint.hostname = b + ".s3-accelerate.amazonaws.com";
              }
            } else if (!service.config.s3BucketEndpoint) {
              endpoint.hostname = b + "." + endpoint.hostname;
            }
            var port = endpoint.port;
            if (port !== 80 && port !== 443) {
              endpoint.host = endpoint.hostname + ":" + endpoint.port;
            } else {
              endpoint.host = endpoint.hostname;
            }
            httpRequest.virtualHostedBucket = b;
            service.removeVirtualHostedBucketFromPath(req);
          }
        }
      },
      /**
       * Takes the bucket name out of the path if bucket is virtual-hosted
       *
       * @api private
       */
      removeVirtualHostedBucketFromPath: function removeVirtualHostedBucketFromPath(req) {
        var httpRequest = req.httpRequest;
        var bucket = httpRequest.virtualHostedBucket;
        if (bucket && httpRequest.path) {
          if (req.params && req.params.Key) {
            var encodedS3Key = "/" + AWS2.util.uriEscapePath(req.params.Key);
            if (httpRequest.path.indexOf(encodedS3Key) === 0 && (httpRequest.path.length === encodedS3Key.length || httpRequest.path[encodedS3Key.length] === "?")) {
              return;
            }
          }
          httpRequest.path = httpRequest.path.replace(new RegExp("/" + bucket), "");
          if (httpRequest.path[0] !== "/") {
            httpRequest.path = "/" + httpRequest.path;
          }
        }
      },
      /**
       * When user supply an access point ARN in the Bucket parameter, we need to
       * populate the URI according to the ARN.
       */
      populateUriFromAccessPointArn: function populateUriFromAccessPointArn(req) {
        var accessPointArn = req._parsedArn;
        var isOutpostArn = accessPointArn.service === "s3-outposts";
        var isObjectLambdaArn = accessPointArn.service === "s3-object-lambda";
        var outpostsSuffix = isOutpostArn ? "." + accessPointArn.outpostId : "";
        var serviceName = isOutpostArn ? "s3-outposts" : "s3-accesspoint";
        var fipsSuffix = !isOutpostArn && req.service.config.useFipsEndpoint ? "-fips" : "";
        var dualStackSuffix = !isOutpostArn && req.service.config.useDualstackEndpoint ? ".dualstack" : "";
        var endpoint = req.httpRequest.endpoint;
        var dnsSuffix = regionUtil.getEndpointSuffix(accessPointArn.region);
        var useArnRegion = req.service.config.s3UseArnRegion;
        endpoint.hostname = [
          accessPointArn.accessPoint + "-" + accessPointArn.accountId + outpostsSuffix,
          serviceName + fipsSuffix + dualStackSuffix,
          useArnRegion ? accessPointArn.region : req.service.config.region,
          dnsSuffix
        ].join(".");
        if (isObjectLambdaArn) {
          var serviceName = "s3-object-lambda";
          var accesspointName = accessPointArn.resource.split("/")[1];
          var fipsSuffix = req.service.config.useFipsEndpoint ? "-fips" : "";
          endpoint.hostname = [
            accesspointName + "-" + accessPointArn.accountId,
            serviceName + fipsSuffix,
            useArnRegion ? accessPointArn.region : req.service.config.region,
            dnsSuffix
          ].join(".");
        }
        endpoint.host = endpoint.hostname;
        var encodedArn = AWS2.util.uriEscape(req.params.Bucket);
        var path = req.httpRequest.path;
        req.httpRequest.path = path.replace(new RegExp("/" + encodedArn), "");
        if (req.httpRequest.path[0] !== "/") {
          req.httpRequest.path = "/" + req.httpRequest.path;
        }
        req.httpRequest.region = accessPointArn.region;
      },
      /**
       * Adds Expect: 100-continue header if payload is greater-or-equal 1MB
       * @api private
       */
      addExpect100Continue: function addExpect100Continue(req) {
        var len = req.httpRequest.headers["Content-Length"];
        if (AWS2.util.isNode() && (len >= 1024 * 1024 || req.params.Body instanceof AWS2.util.stream.Stream)) {
          req.httpRequest.headers["Expect"] = "100-continue";
        }
      },
      /**
       * Adds a default content type if none is supplied.
       *
       * @api private
       */
      addContentType: function addContentType(req) {
        var httpRequest = req.httpRequest;
        if (httpRequest.method === "GET" || httpRequest.method === "HEAD") {
          delete httpRequest.headers["Content-Type"];
          return;
        }
        if (!httpRequest.headers["Content-Type"]) {
          httpRequest.headers["Content-Type"] = "application/octet-stream";
        }
        var contentType = httpRequest.headers["Content-Type"];
        if (AWS2.util.isBrowser()) {
          if (typeof httpRequest.body === "string" && !contentType.match(/;\s*charset=/)) {
            var charset = "; charset=UTF-8";
            httpRequest.headers["Content-Type"] += charset;
          } else {
            var replaceFn = function(_, prefix, charsetName) {
              return prefix + charsetName.toUpperCase();
            };
            httpRequest.headers["Content-Type"] = contentType.replace(/(;\s*charset=)(.+)$/, replaceFn);
          }
        }
      },
      /**
       * Checks whether checksums should be computed for the request if it's not
       * already set by {AWS.EventListeners.Core.COMPUTE_CHECKSUM}. It depends on
       * whether {AWS.Config.computeChecksums} is set.
       *
       * @param req [AWS.Request] the request to check against
       * @return [Boolean] whether to compute checksums for a request.
       * @api private
       */
      willComputeChecksums: function willComputeChecksums(req) {
        var rules = req.service.api.operations[req.operation].input.members;
        var body = req.httpRequest.body;
        var needsContentMD5 = req.service.config.computeChecksums && rules.ContentMD5 && !req.params.ContentMD5 && body && (AWS2.util.Buffer.isBuffer(req.httpRequest.body) || typeof req.httpRequest.body === "string");
        if (needsContentMD5 && req.service.shouldDisableBodySigning(req) && !req.isPresigned()) {
          return true;
        }
        if (needsContentMD5 && this.getSignatureVersion(req) === "s3" && req.isPresigned()) {
          return true;
        }
        return false;
      },
      /**
       * A listener that computes the Content-MD5 and sets it in the header.
       * This listener is to support S3-specific features like
       * s3DisableBodySigning and SigV2 presign. Content MD5 logic for SigV4 is
       * handled in AWS.EventListeners.Core.COMPUTE_CHECKSUM
       *
       * @api private
       */
      computeContentMd5: function computeContentMd5(req) {
        if (req.service.willComputeChecksums(req)) {
          var md5 = AWS2.util.crypto.md5(req.httpRequest.body, "base64");
          req.httpRequest.headers["Content-MD5"] = md5;
        }
      },
      /**
       * @api private
       */
      computeSseCustomerKeyMd5: function computeSseCustomerKeyMd5(req) {
        var keys = {
          SSECustomerKey: "x-amz-server-side-encryption-customer-key-MD5",
          CopySourceSSECustomerKey: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
        };
        AWS2.util.each(keys, function(key, header) {
          if (req.params[key]) {
            var value = AWS2.util.crypto.md5(req.params[key], "base64");
            req.httpRequest.headers[header] = value;
          }
        });
      },
      /**
       * Returns true if the bucket name should be left in the URI path for
       * a request to S3.  This function takes into account the current
       * endpoint protocol (e.g. http or https).
       *
       * @api private
       */
      pathStyleBucketName: function pathStyleBucketName(bucketName) {
        if (this.config.s3ForcePathStyle)
          return true;
        if (this.config.s3BucketEndpoint)
          return false;
        if (s3util.dnsCompatibleBucketName(bucketName)) {
          return this.config.sslEnabled && bucketName.match(/\./) ? true : false;
        } else {
          return true;
        }
      },
      /**
       * For COPY operations, some can be error even with status code 200.
       * SDK treats the response as exception when response body indicates
       * an exception or body is empty.
       *
       * @api private
       */
      extractErrorFrom200Response: function extractErrorFrom200Response(resp) {
        if (!operationsWith200StatusCodeError[resp.request.operation])
          return;
        var httpResponse = resp.httpResponse;
        if (httpResponse.body && httpResponse.body.toString().match("<Error>")) {
          resp.data = null;
          var service = this.service ? this.service : this;
          service.extractError(resp);
          throw resp.error;
        } else if (!httpResponse.body || !httpResponse.body.toString().match(/<[\w_]/)) {
          resp.data = null;
          throw AWS2.util.error(new Error(), {
            code: "InternalError",
            message: "S3 aborted request"
          });
        }
      },
      /**
       * @return [Boolean] whether the error can be retried
       * @api private
       */
      retryableError: function retryableError(error, request) {
        if (operationsWith200StatusCodeError[request.operation] && error.statusCode === 200) {
          return true;
        } else if (request._requestRegionForBucket && request.service.bucketRegionCache[request._requestRegionForBucket]) {
          return false;
        } else if (error && error.code === "RequestTimeout") {
          return true;
        } else if (error && regionRedirectErrorCodes.indexOf(error.code) != -1 && error.region && error.region != request.httpRequest.region) {
          request.httpRequest.region = error.region;
          if (error.statusCode === 301) {
            request.service.updateReqBucketRegion(request);
          }
          return true;
        } else {
          var _super = AWS2.Service.prototype.retryableError;
          return _super.call(this, error, request);
        }
      },
      /**
       * Updates httpRequest with region. If region is not provided, then
       * the httpRequest will be updated based on httpRequest.region
       *
       * @api private
       */
      updateReqBucketRegion: function updateReqBucketRegion(request, region) {
        var httpRequest = request.httpRequest;
        if (typeof region === "string" && region.length) {
          httpRequest.region = region;
        }
        if (!httpRequest.endpoint.host.match(/s3(?!-accelerate).*\.amazonaws\.com$/)) {
          return;
        }
        var service = request.service;
        var s3Config = service.config;
        var s3BucketEndpoint = s3Config.s3BucketEndpoint;
        if (s3BucketEndpoint) {
          delete s3Config.s3BucketEndpoint;
        }
        var newConfig = AWS2.util.copy(s3Config);
        delete newConfig.endpoint;
        newConfig.region = httpRequest.region;
        httpRequest.endpoint = new AWS2.S3(newConfig).endpoint;
        service.populateURI(request);
        s3Config.s3BucketEndpoint = s3BucketEndpoint;
        httpRequest.headers.Host = httpRequest.endpoint.host;
        if (request._asm.currentState === "validate") {
          request.removeListener("build", service.populateURI);
          request.addListener("build", service.removeVirtualHostedBucketFromPath);
        }
      },
      /**
       * Provides a specialized parser for getBucketLocation -- all other
       * operations are parsed by the super class.
       *
       * @api private
       */
      extractData: function extractData(resp) {
        var req = resp.request;
        if (req.operation === "getBucketLocation") {
          var match = resp.httpResponse.body.toString().match(/>(.+)<\/Location/);
          delete resp.data["_"];
          if (match) {
            resp.data.LocationConstraint = match[1];
          } else {
            resp.data.LocationConstraint = "";
          }
        }
        var bucket = req.params.Bucket || null;
        if (req.operation === "deleteBucket" && typeof bucket === "string" && !resp.error) {
          req.service.clearBucketRegionCache(bucket);
        } else {
          var headers = resp.httpResponse.headers || {};
          var region = headers["x-amz-bucket-region"] || null;
          if (!region && req.operation === "createBucket" && !resp.error) {
            var createBucketConfiguration = req.params.CreateBucketConfiguration;
            if (!createBucketConfiguration) {
              region = "us-east-1";
            } else if (createBucketConfiguration.LocationConstraint === "EU") {
              region = "eu-west-1";
            } else {
              region = createBucketConfiguration.LocationConstraint;
            }
          }
          if (region) {
            if (bucket && region !== req.service.bucketRegionCache[bucket]) {
              req.service.bucketRegionCache[bucket] = region;
            }
          }
        }
        req.service.extractRequestIds(resp);
      },
      /**
       * Extracts an error object from the http response.
       *
       * @api private
       */
      extractError: function extractError(resp) {
        var codes = {
          304: "NotModified",
          403: "Forbidden",
          400: "BadRequest",
          404: "NotFound"
        };
        var req = resp.request;
        var code = resp.httpResponse.statusCode;
        var body = resp.httpResponse.body || "";
        var headers = resp.httpResponse.headers || {};
        var region = headers["x-amz-bucket-region"] || null;
        var bucket = req.params.Bucket || null;
        var bucketRegionCache = req.service.bucketRegionCache;
        if (region && bucket && region !== bucketRegionCache[bucket]) {
          bucketRegionCache[bucket] = region;
        }
        var cachedRegion;
        if (codes[code] && body.length === 0) {
          if (bucket && !region) {
            cachedRegion = bucketRegionCache[bucket] || null;
            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }
          resp.error = AWS2.util.error(new Error(), {
            code: codes[code],
            message: null,
            region
          });
        } else {
          var data = new AWS2.XML.Parser().parse(body.toString());
          if (data.Region && !region) {
            region = data.Region;
            if (bucket && region !== bucketRegionCache[bucket]) {
              bucketRegionCache[bucket] = region;
            }
          } else if (bucket && !region && !data.Region) {
            cachedRegion = bucketRegionCache[bucket] || null;
            if (cachedRegion !== req.httpRequest.region) {
              region = cachedRegion;
            }
          }
          resp.error = AWS2.util.error(new Error(), {
            code: data.Code || code,
            message: data.Message || null,
            region
          });
        }
        req.service.extractRequestIds(resp);
      },
      /**
       * If region was not obtained synchronously, then send async request
       * to get bucket region for errors resulting from wrong region.
       *
       * @api private
       */
      requestBucketRegion: function requestBucketRegion(resp, done) {
        var error = resp.error;
        var req = resp.request;
        var bucket = req.params.Bucket || null;
        if (!error || !bucket || error.region || req.operation === "listObjects" || AWS2.util.isNode() && req.operation === "headBucket" || error.statusCode === 400 && req.operation !== "headObject" || regionRedirectErrorCodes.indexOf(error.code) === -1) {
          return done();
        }
        var reqOperation = AWS2.util.isNode() ? "headBucket" : "listObjects";
        var reqParams = { Bucket: bucket };
        if (reqOperation === "listObjects")
          reqParams.MaxKeys = 0;
        var regionReq = req.service[reqOperation](reqParams);
        regionReq._requestRegionForBucket = bucket;
        regionReq.send(function() {
          var region = req.service.bucketRegionCache[bucket] || null;
          error.region = region;
          done();
        });
      },
      /**
      * For browser only. If NetworkingError received, will attempt to obtain
      * the bucket region.
      *
      * @api private
      */
      reqRegionForNetworkingError: function reqRegionForNetworkingError(resp, done) {
        if (!AWS2.util.isBrowser()) {
          return done();
        }
        var error = resp.error;
        var request = resp.request;
        var bucket = request.params.Bucket;
        if (!error || error.code !== "NetworkingError" || !bucket || request.httpRequest.region === "us-east-1") {
          return done();
        }
        var service = request.service;
        var bucketRegionCache = service.bucketRegionCache;
        var cachedRegion = bucketRegionCache[bucket] || null;
        if (cachedRegion && cachedRegion !== request.httpRequest.region) {
          service.updateReqBucketRegion(request, cachedRegion);
          done();
        } else if (!s3util.dnsCompatibleBucketName(bucket)) {
          service.updateReqBucketRegion(request, "us-east-1");
          if (bucketRegionCache[bucket] !== "us-east-1") {
            bucketRegionCache[bucket] = "us-east-1";
          }
          done();
        } else if (request.httpRequest.virtualHostedBucket) {
          var getRegionReq = service.listObjects({ Bucket: bucket, MaxKeys: 0 });
          service.updateReqBucketRegion(getRegionReq, "us-east-1");
          getRegionReq._requestRegionForBucket = bucket;
          getRegionReq.send(function() {
            var region = service.bucketRegionCache[bucket] || null;
            if (region && region !== request.httpRequest.region) {
              service.updateReqBucketRegion(request, region);
            }
            done();
          });
        } else {
          done();
        }
      },
      /**
       * Cache for bucket region.
       *
       * @api private
       */
      bucketRegionCache: {},
      /**
       * Clears bucket region cache.
       *
       * @api private
       */
      clearBucketRegionCache: function(buckets) {
        var bucketRegionCache = this.bucketRegionCache;
        if (!buckets) {
          buckets = Object.keys(bucketRegionCache);
        } else if (typeof buckets === "string") {
          buckets = [buckets];
        }
        for (var i = 0; i < buckets.length; i++) {
          delete bucketRegionCache[buckets[i]];
        }
        return bucketRegionCache;
      },
      /**
       * Corrects request region if bucket's cached region is different
       *
       * @api private
       */
      correctBucketRegionFromCache: function correctBucketRegionFromCache(req) {
        var bucket = req.params.Bucket || null;
        if (bucket) {
          var service = req.service;
          var requestRegion = req.httpRequest.region;
          var cachedRegion = service.bucketRegionCache[bucket];
          if (cachedRegion && cachedRegion !== requestRegion) {
            service.updateReqBucketRegion(req, cachedRegion);
          }
        }
      },
      /**
       * Extracts S3 specific request ids from the http response.
       *
       * @api private
       */
      extractRequestIds: function extractRequestIds(resp) {
        var extendedRequestId = resp.httpResponse.headers ? resp.httpResponse.headers["x-amz-id-2"] : null;
        var cfId = resp.httpResponse.headers ? resp.httpResponse.headers["x-amz-cf-id"] : null;
        resp.extendedRequestId = extendedRequestId;
        resp.cfId = cfId;
        if (resp.error) {
          resp.error.requestId = resp.requestId || null;
          resp.error.extendedRequestId = extendedRequestId;
          resp.error.cfId = cfId;
        }
      },
      /**
       * Get a pre-signed URL for a given operation name.
       *
       * @note You must ensure that you have static or previously resolved
       *   credentials if you call this method synchronously (with no callback),
       *   otherwise it may not properly sign the request. If you cannot guarantee
       *   this (you are using an asynchronous credential provider, i.e., EC2
       *   IAM roles), you should always call this method with an asynchronous
       *   callback.
       * @note Not all operation parameters are supported when using pre-signed
       *   URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
       *   `ContentLength`, or `Tagging` must be provided as headers when sending a
       *   request. If you are using pre-signed URLs to upload from a browser and
       *   need to use these fields, see {createPresignedPost}.
       * @note The default signer allows altering the request by adding corresponding
       *   headers to set some parameters (e.g. Range) and these added parameters
       *   won't be signed. You must use signatureVersion v4 to to include these
       *   parameters in the signed portion of the URL and enforce exact matching
       *   between headers and signed params in the URL.
       * @note This operation cannot be used with a promise. See note above regarding
       *   asynchronous credentials and use with a callback.
       * @param operation [String] the name of the operation to call
       * @param params [map] parameters to pass to the operation. See the given
       *   operation for the expected operation parameters. In addition, you can
       *   also pass the "Expires" parameter to inform S3 how long the URL should
       *   work for.
       * @option params Expires [Integer] (900) the number of seconds to expire
       *   the pre-signed URL operation in. Defaults to 15 minutes.
       * @param callback [Function] if a callback is provided, this function will
       *   pass the URL as the second parameter (after the error parameter) to
       *   the callback function.
       * @return [String] if called synchronously (with no callback), returns the
       *   signed URL.
       * @return [null] nothing is returned if a callback is provided.
       * @example Pre-signing a getObject operation (synchronously)
       *   var params = {Bucket: 'bucket', Key: 'key'};
       *   var url = s3.getSignedUrl('getObject', params);
       *   console.log('The URL is', url);
       * @example Pre-signing a putObject (asynchronously)
       *   var params = {Bucket: 'bucket', Key: 'key'};
       *   s3.getSignedUrl('putObject', params, function (err, url) {
       *     console.log('The URL is', url);
       *   });
       * @example Pre-signing a putObject operation with a specific payload
       *   var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
       *   var url = s3.getSignedUrl('putObject', params);
       *   console.log('The URL is', url);
       * @example Passing in a 1-minute expiry time for a pre-signed URL
       *   var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
       *   var url = s3.getSignedUrl('getObject', params);
       *   console.log('The URL is', url); // expires in 60 seconds
       */
      getSignedUrl: function getSignedUrl(operation, params, callback) {
        params = AWS2.util.copy(params || {});
        var expires = params.Expires || 900;
        if (typeof expires !== "number") {
          throw AWS2.util.error(
            new Error(),
            { code: "InvalidParameterException", message: "The expiration must be a number, received " + typeof expires }
          );
        }
        delete params.Expires;
        var request = this.makeRequest(operation, params);
        if (callback) {
          AWS2.util.defer(function() {
            request.presign(expires, callback);
          });
        } else {
          return request.presign(expires, callback);
        }
      },
      /**
       * @!method  getSignedUrlPromise()
       *   Returns a 'thenable' promise that will be resolved with a pre-signed URL
       *   for a given operation name.
       *
       *   Two callbacks can be provided to the `then` method on the returned promise.
       *   The first callback will be called if the promise is fulfilled, and the second
       *   callback will be called if the promise is rejected.
       *   @note Not all operation parameters are supported when using pre-signed
       *      URLs. Certain parameters, such as `SSECustomerKey`, `ACL`, `Expires`,
       *      `ContentLength`, or `Tagging` must be provided as headers when sending a
       *      request. If you are using pre-signed URLs to upload from a browser and
       *      need to use these fields, see {createPresignedPost}.
       *   @param operation [String] the name of the operation to call
       *   @param params [map] parameters to pass to the operation. See the given
       *      operation for the expected operation parameters. In addition, you can
       *      also pass the "Expires" parameter to inform S3 how long the URL should
       *      work for.
       *   @option params Expires [Integer] (900) the number of seconds to expire
       *      the pre-signed URL operation in. Defaults to 15 minutes.
       *   @callback fulfilledCallback function(url)
       *     Called if the promise is fulfilled.
       *     @param url [String] the signed url
       *   @callback rejectedCallback function(err)
       *     Called if the promise is rejected.
       *     @param err [Error] if an error occurred, this value will be filled
       *   @return [Promise] A promise that represents the state of the `refresh` call.
       *   @example Pre-signing a getObject operation
       *      var params = {Bucket: 'bucket', Key: 'key'};
       *      var promise = s3.getSignedUrlPromise('getObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       *   @example Pre-signing a putObject operation with a specific payload
       *      var params = {Bucket: 'bucket', Key: 'key', Body: 'body'};
       *      var promise = s3.getSignedUrlPromise('putObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       *   @example Passing in a 1-minute expiry time for a pre-signed URL
       *      var params = {Bucket: 'bucket', Key: 'key', Expires: 60};
       *      var promise = s3.getSignedUrlPromise('getObject', params);
       *      promise.then(function(url) {
       *        console.log('The URL is', url);
       *      }, function(err) { ... });
       */
      /**
       * Get a pre-signed POST policy to support uploading to S3 directly from an
       * HTML form.
       *
       * @param params [map]
       * @option params Bucket [String]     The bucket to which the post should be
       *                                    uploaded
       * @option params Expires [Integer]   (3600) The number of seconds for which
       *                                    the presigned policy should be valid.
       * @option params Conditions [Array]  An array of conditions that must be met
       *                                    for the presigned policy to allow the
       *                                    upload. This can include required tags,
       *                                    the accepted range for content lengths,
       *                                    etc.
       * @see http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-HTTPPOSTConstructPolicy.html
       * @option params Fields [map]        Fields to include in the form. All
       *                                    values passed in as fields will be
       *                                    signed as exact match conditions.
       * @param callback [Function]
       *
       * @note All fields passed in when creating presigned post data will be signed
       *   as exact match conditions. Any fields that will be interpolated by S3
       *   must be added to the fields hash after signing, and an appropriate
       *   condition for such fields must be explicitly added to the Conditions
       *   array passed to this function before signing.
       *
       * @example Presiging post data with a known key
       *   var params = {
       *     Bucket: 'bucket',
       *     Fields: {
       *       key: 'key'
       *     }
       *   };
       *   s3.createPresignedPost(params, function(err, data) {
       *     if (err) {
       *       console.error('Presigning post data encountered an error', err);
       *     } else {
       *       console.log('The post data is', data);
       *     }
       *   });
       *
       * @example Presigning post data with an interpolated key
       *   var params = {
       *     Bucket: 'bucket',
       *     Conditions: [
       *       ['starts-with', '$key', 'path/to/uploads/']
       *     ]
       *   };
       *   s3.createPresignedPost(params, function(err, data) {
       *     if (err) {
       *       console.error('Presigning post data encountered an error', err);
       *     } else {
       *       data.Fields.key = 'path/to/uploads/${filename}';
       *       console.log('The post data is', data);
       *     }
       *   });
       *
       * @note You must ensure that you have static or previously resolved
       *   credentials if you call this method synchronously (with no callback),
       *   otherwise it may not properly sign the request. If you cannot guarantee
       *   this (you are using an asynchronous credential provider, i.e., EC2
       *   IAM roles), you should always call this method with an asynchronous
       *   callback.
       *
       * @return [map]  If called synchronously (with no callback), returns a hash
       *                with the url to set as the form action and a hash of fields
       *                to include in the form.
       * @return [null] Nothing is returned if a callback is provided.
       *
       * @callback callback function (err, data)
       *  @param err [Error] the error object returned from the policy signer
       *  @param data [map] The data necessary to construct an HTML form
       *  @param data.url [String] The URL to use as the action of the form
       *  @param data.fields [map] A hash of fields that must be included in the
       *                           form for the upload to succeed. This hash will
       *                           include the signed POST policy, your access key
       *                           ID and security token (if present), etc. These
       *                           may be safely included as input elements of type
       *                           'hidden.'
       */
      createPresignedPost: function createPresignedPost(params, callback) {
        if (typeof params === "function" && callback === void 0) {
          callback = params;
          params = null;
        }
        params = AWS2.util.copy(params || {});
        var boundParams = this.config.params || {};
        var bucket = params.Bucket || boundParams.Bucket, self = this, config = this.config, endpoint = AWS2.util.copy(this.endpoint);
        if (!config.s3BucketEndpoint) {
          endpoint.pathname = "/" + bucket;
        }
        function finalizePost() {
          return {
            url: AWS2.util.urlFormat(endpoint),
            fields: self.preparePostFields(
              config.credentials,
              config.region,
              bucket,
              params.Fields,
              params.Conditions,
              params.Expires
            )
          };
        }
        if (callback) {
          config.getCredentials(function(err) {
            if (err) {
              callback(err);
            } else {
              try {
                callback(null, finalizePost());
              } catch (err2) {
                callback(err2);
              }
            }
          });
        } else {
          return finalizePost();
        }
      },
      /**
       * @api private
       */
      preparePostFields: function preparePostFields(credentials, region, bucket, fields, conditions, expiresInSeconds) {
        var now = this.getSkewCorrectedDate();
        if (!credentials || !region || !bucket) {
          throw new Error("Unable to create a POST object policy without a bucket, region, and credentials");
        }
        fields = AWS2.util.copy(fields || {});
        conditions = (conditions || []).slice(0);
        expiresInSeconds = expiresInSeconds || 3600;
        var signingDate = AWS2.util.date.iso8601(now).replace(/[:\-]|\.\d{3}/g, "");
        var shortDate = signingDate.substr(0, 8);
        var scope = v4Credentials.createScope(shortDate, region, "s3");
        var credential = credentials.accessKeyId + "/" + scope;
        fields["bucket"] = bucket;
        fields["X-Amz-Algorithm"] = "AWS4-HMAC-SHA256";
        fields["X-Amz-Credential"] = credential;
        fields["X-Amz-Date"] = signingDate;
        if (credentials.sessionToken) {
          fields["X-Amz-Security-Token"] = credentials.sessionToken;
        }
        for (var field in fields) {
          if (fields.hasOwnProperty(field)) {
            var condition = {};
            condition[field] = fields[field];
            conditions.push(condition);
          }
        }
        fields.Policy = this.preparePostPolicy(
          new Date(now.valueOf() + expiresInSeconds * 1e3),
          conditions
        );
        fields["X-Amz-Signature"] = AWS2.util.crypto.hmac(
          v4Credentials.getSigningKey(credentials, shortDate, region, "s3", true),
          fields.Policy,
          "hex"
        );
        return fields;
      },
      /**
       * @api private
       */
      preparePostPolicy: function preparePostPolicy(expiration, conditions) {
        return AWS2.util.base64.encode(JSON.stringify({
          expiration: AWS2.util.date.iso8601(expiration),
          conditions
        }));
      },
      /**
       * @api private
       */
      prepareSignedUrl: function prepareSignedUrl(request) {
        request.addListener("validate", request.service.noPresignedContentLength);
        request.removeListener("build", request.service.addContentType);
        if (!request.params.Body) {
          request.removeListener("build", request.service.computeContentMd5);
        } else {
          request.addListener("afterBuild", AWS2.EventListeners.Core.COMPUTE_SHA256);
        }
      },
      /**
       * @api private
       * @param request
       */
      disableBodySigning: function disableBodySigning(request) {
        var headers = request.httpRequest.headers;
        if (!Object.prototype.hasOwnProperty.call(headers, "presigned-expires")) {
          headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
        }
      },
      /**
       * @api private
       */
      noPresignedContentLength: function noPresignedContentLength(request) {
        if (request.params.ContentLength !== void 0) {
          throw AWS2.util.error(new Error(), {
            code: "UnexpectedParameter",
            message: "ContentLength is not supported in pre-signed URLs."
          });
        }
      },
      createBucket: function createBucket(params, callback) {
        if (typeof params === "function" || !params) {
          callback = callback || params;
          params = {};
        }
        var hostname = this.endpoint.hostname;
        var copiedParams = AWS2.util.copy(params);
        if (hostname !== this.api.globalEndpoint && !params.CreateBucketConfiguration) {
          copiedParams.CreateBucketConfiguration = { LocationConstraint: this.config.region };
        }
        return this.makeRequest("createBucket", copiedParams, callback);
      },
      writeGetObjectResponse: function writeGetObjectResponse(params, callback) {
        var request = this.makeRequest("writeGetObjectResponse", AWS2.util.copy(params), callback);
        var hostname = this.endpoint.hostname;
        if (hostname.indexOf(this.config.region) !== -1) {
          hostname = hostname.replace("s3.", OBJECT_LAMBDA_SERVICE + ".");
        } else {
          hostname = hostname.replace("s3.", OBJECT_LAMBDA_SERVICE + "." + this.config.region + ".");
        }
        request.httpRequest.endpoint = new AWS2.Endpoint(hostname, this.config);
        return request;
      },
      /**
       * @see AWS.S3.ManagedUpload
       * @overload upload(params = {}, [options], [callback])
       *   Uploads an arbitrarily sized buffer, blob, or stream, using intelligent
       *   concurrent handling of parts if the payload is large enough. You can
       *   configure the concurrent queue size by setting `options`. Note that this
       *   is the only operation for which the SDK can retry requests with stream
       *   bodies.
       *
       *   @param (see AWS.S3.putObject)
       *   @option (see AWS.S3.ManagedUpload.constructor)
       *   @return [AWS.S3.ManagedUpload] the managed upload object that can call
       *     `send()` or track progress.
       *   @example Uploading a stream object
       *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *     s3.upload(params, function(err, data) {
       *       console.log(err, data);
       *     });
       *   @example Uploading a stream with concurrency of 1 and partSize of 10mb
       *     var params = {Bucket: 'bucket', Key: 'key', Body: stream};
       *     var options = {partSize: 10 * 1024 * 1024, queueSize: 1};
       *     s3.upload(params, options, function(err, data) {
       *       console.log(err, data);
       *     });
       * @callback callback function(err, data)
       *   @param err [Error] an error or null if no error occurred.
       *   @param data [map] The response data from the successful upload:
       *   @param data.Location [String] the URL of the uploaded object
       *   @param data.ETag [String] the ETag of the uploaded object
       *   @param data.Bucket [String]  the bucket to which the object was uploaded
       *   @param data.Key [String] the key to which the object was uploaded
       */
      upload: function upload(params, options, callback) {
        if (typeof options === "function" && callback === void 0) {
          callback = options;
          options = null;
        }
        options = options || {};
        options = AWS2.util.merge(options || {}, { service: this, params });
        var uploader = new AWS2.S3.ManagedUpload(options);
        if (typeof callback === "function")
          uploader.send(callback);
        return uploader;
      },
      /**
       * @api private
       */
      setExpiresString: function setExpiresString(response) {
        if (response && response.httpResponse && response.httpResponse.headers) {
          if ("expires" in response.httpResponse.headers) {
            response.httpResponse.headers.expiresstring = response.httpResponse.headers.expires;
          }
        }
        try {
          if (response && response.httpResponse && response.httpResponse.headers) {
            if ("expires" in response.httpResponse.headers) {
              AWS2.util.date.parseTimestamp(response.httpResponse.headers.expires);
            }
          }
        } catch (e) {
          console.log("AWS SDK", "(warning)", e);
          delete response.httpResponse.headers.expires;
        }
      }
    });
    AWS2.S3.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
      this.prototype.getSignedUrlPromise = AWS2.util.promisifyMethod("getSignedUrl", PromiseDependency);
    };
    AWS2.S3.deletePromisesFromClass = function deletePromisesFromClass() {
      delete this.prototype.getSignedUrlPromise;
    };
    AWS2.util.addPromises(AWS2.S3);
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.min.json
var require_s3_2006_03_01_min = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.min.json"(exports, module) {
    module.exports = {
      version: "2.0",
      metadata: {
        apiVersion: "2006-03-01",
        checksumFormat: "md5",
        endpointPrefix: "s3",
        globalEndpoint: "s3.amazonaws.com",
        protocol: "rest-xml",
        serviceAbbreviation: "Amazon S3",
        serviceFullName: "Amazon Simple Storage Service",
        serviceId: "S3",
        signatureVersion: "s3",
        uid: "s3-2006-03-01"
      },
      operations: {
        AbortMultipartUpload: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        CompleteMultipartUpload: {
          http: {
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              MultipartUpload: {
                locationName: "CompleteMultipartUpload",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Parts: {
                    locationName: "Part",
                    type: "list",
                    member: {
                      type: "structure",
                      members: {
                        ETag: {},
                        ChecksumCRC32: {},
                        ChecksumCRC32C: {},
                        ChecksumSHA1: {},
                        ChecksumSHA256: {},
                        PartNumber: {
                          type: "integer"
                        }
                      }
                    },
                    flattened: true
                  }
                }
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              }
            },
            payload: "MultipartUpload"
          },
          output: {
            type: "structure",
            members: {
              Location: {},
              Bucket: {},
              Key: {},
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              ETag: {},
              ChecksumCRC32: {},
              ChecksumCRC32C: {},
              ChecksumSHA1: {},
              ChecksumSHA256: {},
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        CopyObject: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CopySource",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              CopySource: {
                location: "header",
                locationName: "x-amz-copy-source"
              },
              CopySourceIfMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-match"
              },
              CopySourceIfModifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-modified-since",
                type: "timestamp"
              },
              CopySourceIfNoneMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-none-match"
              },
              CopySourceIfUnmodifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-unmodified-since",
                type: "timestamp"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              MetadataDirective: {
                location: "header",
                locationName: "x-amz-metadata-directive"
              },
              TaggingDirective: {
                location: "header",
                locationName: "x-amz-tagging-directive"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              CopySourceSSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-algorithm"
              },
              CopySourceSSECustomerKey: {
                shape: "S1k",
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key"
              },
              CopySourceSSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ExpectedSourceBucketOwner: {
                location: "header",
                locationName: "x-amz-source-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CopyObjectResult: {
                type: "structure",
                members: {
                  ETag: {},
                  LastModified: {
                    type: "timestamp"
                  },
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              CopySourceVersionId: {
                location: "header",
                locationName: "x-amz-copy-source-version-id"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "CopyObjectResult"
          },
          alias: "PutObjectCopy",
          staticContextParams: {
            DisableS3ExpressSessionAuth: {
              value: true
            }
          }
        },
        CreateBucket: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CreateBucketConfiguration: {
                locationName: "CreateBucketConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  LocationConstraint: {},
                  Location: {
                    type: "structure",
                    members: {
                      Type: {},
                      Name: {}
                    }
                  },
                  Bucket: {
                    type: "structure",
                    members: {
                      DataRedundancy: {},
                      Type: {}
                    }
                  }
                }
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              ObjectLockEnabledForBucket: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-enabled",
                type: "boolean"
              },
              ObjectOwnership: {
                location: "header",
                locationName: "x-amz-object-ownership"
              }
            },
            payload: "CreateBucketConfiguration"
          },
          output: {
            type: "structure",
            members: {
              Location: {
                location: "header",
                locationName: "Location"
              }
            }
          },
          alias: "PutBucket",
          staticContextParams: {
            DisableAccessPoints: {
              value: true
            },
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        CreateMultipartUpload: {
          http: {
            requestUri: "/{Bucket}/{Key+}?uploads"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AbortDate: {
                location: "header",
                locationName: "x-amz-abort-date",
                type: "timestamp"
              },
              AbortRuleId: {
                location: "header",
                locationName: "x-amz-abort-rule-id"
              },
              Bucket: {
                locationName: "Bucket"
              },
              Key: {},
              UploadId: {},
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-checksum-algorithm"
              }
            }
          },
          alias: "InitiateMultipartUpload"
        },
        CreateSession: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?session"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              SessionMode: {
                location: "header",
                locationName: "x-amz-create-session-mode"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              }
            }
          },
          output: {
            type: "structure",
            required: [
              "Credentials"
            ],
            members: {
              Credentials: {
                locationName: "Credentials",
                type: "structure",
                required: [
                  "AccessKeyId",
                  "SecretAccessKey",
                  "SessionToken",
                  "Expiration"
                ],
                members: {
                  AccessKeyId: {
                    locationName: "AccessKeyId"
                  },
                  SecretAccessKey: {
                    shape: "S2h",
                    locationName: "SecretAccessKey"
                  },
                  SessionToken: {
                    shape: "S2h",
                    locationName: "SessionToken"
                  },
                  Expiration: {
                    locationName: "Expiration",
                    type: "timestamp"
                  }
                }
              }
            }
          },
          staticContextParams: {
            DisableS3ExpressSessionAuth: {
              value: true
            }
          }
        },
        DeleteBucket: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketAnalyticsConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?analytics",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketCors: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?cors",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketEncryption: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?encryption",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketIntelligentTieringConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?intelligent-tiering",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketInventoryConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?inventory",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketLifecycle: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?lifecycle",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketMetricsConfiguration: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?metrics",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketOwnershipControls: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?ownershipControls",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketPolicy: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?policy",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketReplication: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?replication",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketTagging: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?tagging",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteBucketWebsite: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?website",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        DeleteObject: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        DeleteObjectTagging: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}/{Key+}?tagging",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              }
            }
          }
        },
        DeleteObjects: {
          http: {
            requestUri: "/{Bucket}?delete"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Delete"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Delete: {
                locationName: "Delete",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Objects"
                ],
                members: {
                  Objects: {
                    locationName: "Object",
                    type: "list",
                    member: {
                      type: "structure",
                      required: [
                        "Key"
                      ],
                      members: {
                        Key: {},
                        VersionId: {}
                      }
                    },
                    flattened: true
                  },
                  Quiet: {
                    type: "boolean"
                  }
                }
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              }
            },
            payload: "Delete"
          },
          output: {
            type: "structure",
            members: {
              Deleted: {
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Key: {},
                    VersionId: {},
                    DeleteMarker: {
                      type: "boolean"
                    },
                    DeleteMarkerVersionId: {}
                  }
                },
                flattened: true
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              Errors: {
                locationName: "Error",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Key: {},
                    VersionId: {},
                    Code: {},
                    Message: {}
                  }
                },
                flattened: true
              }
            }
          },
          alias: "DeleteMultipleObjects",
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        DeletePublicAccessBlock: {
          http: {
            method: "DELETE",
            requestUri: "/{Bucket}?publicAccessBlock",
            responseCode: 204
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketAccelerateConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?accelerate"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Status: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketAcl: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Owner: {
                shape: "S3q"
              },
              Grants: {
                shape: "S3t",
                locationName: "AccessControlList"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketAnalyticsConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AnalyticsConfiguration: {
                shape: "S42"
              }
            },
            payload: "AnalyticsConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketCors: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?cors"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CORSRules: {
                shape: "S4h",
                locationName: "CORSRule"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketEncryption: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?encryption"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ServerSideEncryptionConfiguration: {
                shape: "S4u"
              }
            },
            payload: "ServerSideEncryptionConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketIntelligentTieringConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IntelligentTieringConfiguration: {
                shape: "S50"
              }
            },
            payload: "IntelligentTieringConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketInventoryConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              InventoryConfiguration: {
                shape: "S5a"
              }
            },
            payload: "InventoryConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketLifecycle: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Rules: {
                shape: "S5q",
                locationName: "Rule"
              }
            }
          },
          deprecated: true,
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketLifecycleConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Rules: {
                shape: "S66",
                locationName: "Rule"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketLocation: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?location"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LocationConstraint: {}
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketLogging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?logging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LoggingEnabled: {
                shape: "S6i"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketMetricsConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              MetricsConfiguration: {
                shape: "S6u"
              }
            },
            payload: "MetricsConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketNotification: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            shape: "S6y"
          },
          output: {
            shape: "S6z"
          },
          deprecated: true,
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketNotificationConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            shape: "S6y"
          },
          output: {
            shape: "S7a"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketOwnershipControls: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?ownershipControls"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              OwnershipControls: {
                shape: "S7r"
              }
            },
            payload: "OwnershipControls"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketPolicy: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?policy"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Policy: {}
            },
            payload: "Policy"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketPolicyStatus: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?policyStatus"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PolicyStatus: {
                type: "structure",
                members: {
                  IsPublic: {
                    locationName: "IsPublic",
                    type: "boolean"
                  }
                }
              }
            },
            payload: "PolicyStatus"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketReplication: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?replication"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ReplicationConfiguration: {
                shape: "S83"
              }
            },
            payload: "ReplicationConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketRequestPayment: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?requestPayment"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Payer: {}
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketTagging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            required: [
              "TagSet"
            ],
            members: {
              TagSet: {
                shape: "S48"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketVersioning: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?versioning"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Status: {},
              MFADelete: {
                locationName: "MfaDelete"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetBucketWebsite: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?website"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              RedirectAllRequestsTo: {
                shape: "S96"
              },
              IndexDocument: {
                shape: "S99"
              },
              ErrorDocument: {
                shape: "S9b"
              },
              RoutingRules: {
                shape: "S9c"
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        GetObject: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              IfMatch: {
                location: "header",
                locationName: "If-Match"
              },
              IfModifiedSince: {
                location: "header",
                locationName: "If-Modified-Since",
                type: "timestamp"
              },
              IfNoneMatch: {
                location: "header",
                locationName: "If-None-Match"
              },
              IfUnmodifiedSince: {
                location: "header",
                locationName: "If-Unmodified-Since",
                type: "timestamp"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              Range: {
                location: "header",
                locationName: "Range"
              },
              ResponseCacheControl: {
                location: "querystring",
                locationName: "response-cache-control"
              },
              ResponseContentDisposition: {
                location: "querystring",
                locationName: "response-content-disposition"
              },
              ResponseContentEncoding: {
                location: "querystring",
                locationName: "response-content-encoding"
              },
              ResponseContentLanguage: {
                location: "querystring",
                locationName: "response-content-language"
              },
              ResponseContentType: {
                location: "querystring",
                locationName: "response-content-type"
              },
              ResponseExpires: {
                location: "querystring",
                locationName: "response-expires",
                type: "timestamp",
                timestampFormat: "rfc822"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumMode: {
                location: "header",
                locationName: "x-amz-checksum-mode"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              AcceptRanges: {
                location: "header",
                locationName: "accept-ranges"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-restore"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-missing-meta",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentRange: {
                location: "header",
                locationName: "Content-Range"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                deprecated: true,
                type: "timestamp"
              },
              ExpiresString: {
                location: "header",
                locationName: "ExpiresString"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-replication-status"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-mp-parts-count",
                type: "integer"
              },
              TagCount: {
                location: "header",
                locationName: "x-amz-tagging-count",
                type: "integer"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              }
            },
            payload: "Body"
          },
          httpChecksum: {
            requestValidationModeMember: "ChecksumMode",
            responseAlgorithms: [
              "CRC32",
              "CRC32C",
              "SHA256",
              "SHA1"
            ]
          }
        },
        GetObjectAcl: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Owner: {
                shape: "S3q"
              },
              Grants: {
                shape: "S3t",
                locationName: "AccessControlList"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        GetObjectAttributes: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?attributes"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "ObjectAttributes"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              MaxParts: {
                location: "header",
                locationName: "x-amz-max-parts",
                type: "integer"
              },
              PartNumberMarker: {
                location: "header",
                locationName: "x-amz-part-number-marker",
                type: "integer"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ObjectAttributes: {
                location: "header",
                locationName: "x-amz-object-attributes",
                type: "list",
                member: {}
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ETag: {},
              Checksum: {
                type: "structure",
                members: {
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              ObjectParts: {
                type: "structure",
                members: {
                  TotalPartsCount: {
                    locationName: "PartsCount",
                    type: "integer"
                  },
                  PartNumberMarker: {
                    type: "integer"
                  },
                  NextPartNumberMarker: {
                    type: "integer"
                  },
                  MaxParts: {
                    type: "integer"
                  },
                  IsTruncated: {
                    type: "boolean"
                  },
                  Parts: {
                    locationName: "Part",
                    type: "list",
                    member: {
                      type: "structure",
                      members: {
                        PartNumber: {
                          type: "integer"
                        },
                        Size: {
                          type: "long"
                        },
                        ChecksumCRC32: {},
                        ChecksumCRC32C: {},
                        ChecksumSHA1: {},
                        ChecksumSHA256: {}
                      }
                    },
                    flattened: true
                  }
                }
              },
              StorageClass: {},
              ObjectSize: {
                type: "long"
              }
            }
          }
        },
        GetObjectLegalHold: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?legal-hold"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              LegalHold: {
                shape: "Sar",
                locationName: "LegalHold"
              }
            },
            payload: "LegalHold"
          }
        },
        GetObjectLockConfiguration: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?object-lock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ObjectLockConfiguration: {
                shape: "Sau"
              }
            },
            payload: "ObjectLockConfiguration"
          }
        },
        GetObjectRetention: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?retention"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Retention: {
                shape: "Sb2",
                locationName: "Retention"
              }
            },
            payload: "Retention"
          }
        },
        GetObjectTagging: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            }
          },
          output: {
            type: "structure",
            required: [
              "TagSet"
            ],
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              TagSet: {
                shape: "S48"
              }
            }
          }
        },
        GetObjectTorrent: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}?torrent"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "Body"
          }
        },
        GetPublicAccessBlock: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?publicAccessBlock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              PublicAccessBlockConfiguration: {
                shape: "Sb9"
              }
            },
            payload: "PublicAccessBlockConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        HeadBucket: {
          http: {
            method: "HEAD",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              BucketLocationType: {
                location: "header",
                locationName: "x-amz-bucket-location-type"
              },
              BucketLocationName: {
                location: "header",
                locationName: "x-amz-bucket-location-name"
              },
              BucketRegion: {
                location: "header",
                locationName: "x-amz-bucket-region"
              },
              AccessPointAlias: {
                location: "header",
                locationName: "x-amz-access-point-alias",
                type: "boolean"
              }
            }
          }
        },
        HeadObject: {
          http: {
            method: "HEAD",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              IfMatch: {
                location: "header",
                locationName: "If-Match"
              },
              IfModifiedSince: {
                location: "header",
                locationName: "If-Modified-Since",
                type: "timestamp"
              },
              IfNoneMatch: {
                location: "header",
                locationName: "If-None-Match"
              },
              IfUnmodifiedSince: {
                location: "header",
                locationName: "If-Unmodified-Since",
                type: "timestamp"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              Range: {
                location: "header",
                locationName: "Range"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumMode: {
                location: "header",
                locationName: "x-amz-checksum-mode"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-delete-marker",
                type: "boolean"
              },
              AcceptRanges: {
                location: "header",
                locationName: "accept-ranges"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-restore"
              },
              ArchiveStatus: {
                location: "header",
                locationName: "x-amz-archive-status"
              },
              LastModified: {
                location: "header",
                locationName: "Last-Modified",
                type: "timestamp"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-missing-meta",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                deprecated: true,
                type: "timestamp"
              },
              ExpiresString: {
                location: "header",
                locationName: "ExpiresString"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-replication-status"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-mp-parts-count",
                type: "integer"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              }
            }
          }
        },
        ListBucketAnalyticsConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              AnalyticsConfigurationList: {
                locationName: "AnalyticsConfiguration",
                type: "list",
                member: {
                  shape: "S42"
                },
                flattened: true
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        ListBucketIntelligentTieringConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              IntelligentTieringConfigurationList: {
                locationName: "IntelligentTieringConfiguration",
                type: "list",
                member: {
                  shape: "S50"
                },
                flattened: true
              }
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        ListBucketInventoryConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              ContinuationToken: {},
              InventoryConfigurationList: {
                locationName: "InventoryConfiguration",
                type: "list",
                member: {
                  shape: "S5a"
                },
                flattened: true
              },
              IsTruncated: {
                type: "boolean"
              },
              NextContinuationToken: {}
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        ListBucketMetricsConfigurations: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              MetricsConfigurationList: {
                locationName: "MetricsConfiguration",
                type: "list",
                member: {
                  shape: "S6u"
                },
                flattened: true
              }
            }
          }
        },
        ListBuckets: {
          http: {
            method: "GET"
          },
          output: {
            type: "structure",
            members: {
              Buckets: {
                shape: "Sby"
              },
              Owner: {
                shape: "S3q"
              }
            }
          },
          alias: "GetService"
        },
        ListDirectoryBuckets: {
          http: {
            method: "GET"
          },
          input: {
            type: "structure",
            members: {
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              MaxDirectoryBuckets: {
                location: "querystring",
                locationName: "max-directory-buckets",
                type: "integer"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Buckets: {
                shape: "Sby"
              },
              ContinuationToken: {}
            }
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        ListMultipartUploads: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?uploads"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              KeyMarker: {
                location: "querystring",
                locationName: "key-marker"
              },
              MaxUploads: {
                location: "querystring",
                locationName: "max-uploads",
                type: "integer"
              },
              Prefix: {
                contextParam: {
                  name: "Prefix"
                },
                location: "querystring",
                locationName: "prefix"
              },
              UploadIdMarker: {
                location: "querystring",
                locationName: "upload-id-marker"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Bucket: {},
              KeyMarker: {},
              UploadIdMarker: {},
              NextKeyMarker: {},
              Prefix: {},
              Delimiter: {},
              NextUploadIdMarker: {},
              MaxUploads: {
                type: "integer"
              },
              IsTruncated: {
                type: "boolean"
              },
              Uploads: {
                locationName: "Upload",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    UploadId: {},
                    Key: {},
                    Initiated: {
                      type: "timestamp"
                    },
                    StorageClass: {},
                    Owner: {
                      shape: "S3q"
                    },
                    Initiator: {
                      shape: "Sch"
                    },
                    ChecksumAlgorithm: {}
                  }
                },
                flattened: true
              },
              CommonPrefixes: {
                shape: "Sci"
              },
              EncodingType: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        ListObjectVersions: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?versions"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              KeyMarker: {
                location: "querystring",
                locationName: "key-marker"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                contextParam: {
                  name: "Prefix"
                },
                location: "querystring",
                locationName: "prefix"
              },
              VersionIdMarker: {
                location: "querystring",
                locationName: "version-id-marker"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              OptionalObjectAttributes: {
                shape: "Scn",
                location: "header",
                locationName: "x-amz-optional-object-attributes"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              KeyMarker: {},
              VersionIdMarker: {},
              NextKeyMarker: {},
              NextVersionIdMarker: {},
              Versions: {
                locationName: "Version",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    ETag: {},
                    ChecksumAlgorithm: {
                      shape: "Sct"
                    },
                    Size: {
                      type: "long"
                    },
                    StorageClass: {},
                    Key: {},
                    VersionId: {},
                    IsLatest: {
                      type: "boolean"
                    },
                    LastModified: {
                      type: "timestamp"
                    },
                    Owner: {
                      shape: "S3q"
                    },
                    RestoreStatus: {
                      shape: "Scw"
                    }
                  }
                },
                flattened: true
              },
              DeleteMarkers: {
                locationName: "DeleteMarker",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    Owner: {
                      shape: "S3q"
                    },
                    Key: {},
                    VersionId: {},
                    IsLatest: {
                      type: "boolean"
                    },
                    LastModified: {
                      type: "timestamp"
                    }
                  }
                },
                flattened: true
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sci"
              },
              EncodingType: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          alias: "GetBucketObjectVersions"
        },
        ListObjects: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              Marker: {
                location: "querystring",
                locationName: "marker"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                contextParam: {
                  name: "Prefix"
                },
                location: "querystring",
                locationName: "prefix"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              OptionalObjectAttributes: {
                shape: "Scn",
                location: "header",
                locationName: "x-amz-optional-object-attributes"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              Marker: {},
              NextMarker: {},
              Contents: {
                shape: "Sd5"
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sci"
              },
              EncodingType: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          alias: "GetBucket"
        },
        ListObjectsV2: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}?list-type=2"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Delimiter: {
                location: "querystring",
                locationName: "delimiter"
              },
              EncodingType: {
                location: "querystring",
                locationName: "encoding-type"
              },
              MaxKeys: {
                location: "querystring",
                locationName: "max-keys",
                type: "integer"
              },
              Prefix: {
                contextParam: {
                  name: "Prefix"
                },
                location: "querystring",
                locationName: "prefix"
              },
              ContinuationToken: {
                location: "querystring",
                locationName: "continuation-token"
              },
              FetchOwner: {
                location: "querystring",
                locationName: "fetch-owner",
                type: "boolean"
              },
              StartAfter: {
                location: "querystring",
                locationName: "start-after"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              OptionalObjectAttributes: {
                shape: "Scn",
                location: "header",
                locationName: "x-amz-optional-object-attributes"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              IsTruncated: {
                type: "boolean"
              },
              Contents: {
                shape: "Sd5"
              },
              Name: {},
              Prefix: {},
              Delimiter: {},
              MaxKeys: {
                type: "integer"
              },
              CommonPrefixes: {
                shape: "Sci"
              },
              EncodingType: {},
              KeyCount: {
                type: "integer"
              },
              ContinuationToken: {},
              NextContinuationToken: {},
              StartAfter: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          }
        },
        ListParts: {
          http: {
            method: "GET",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "UploadId"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              MaxParts: {
                location: "querystring",
                locationName: "max-parts",
                type: "integer"
              },
              PartNumberMarker: {
                location: "querystring",
                locationName: "part-number-marker",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              AbortDate: {
                location: "header",
                locationName: "x-amz-abort-date",
                type: "timestamp"
              },
              AbortRuleId: {
                location: "header",
                locationName: "x-amz-abort-rule-id"
              },
              Bucket: {},
              Key: {},
              UploadId: {},
              PartNumberMarker: {
                type: "integer"
              },
              NextPartNumberMarker: {
                type: "integer"
              },
              MaxParts: {
                type: "integer"
              },
              IsTruncated: {
                type: "boolean"
              },
              Parts: {
                locationName: "Part",
                type: "list",
                member: {
                  type: "structure",
                  members: {
                    PartNumber: {
                      type: "integer"
                    },
                    LastModified: {
                      type: "timestamp"
                    },
                    ETag: {},
                    Size: {
                      type: "long"
                    },
                    ChecksumCRC32: {},
                    ChecksumCRC32C: {},
                    ChecksumSHA1: {},
                    ChecksumSHA256: {}
                  }
                },
                flattened: true
              },
              Initiator: {
                shape: "Sch"
              },
              Owner: {
                shape: "S3q"
              },
              StorageClass: {},
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              ChecksumAlgorithm: {}
            }
          }
        },
        PutBucketAccelerateConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?accelerate"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "AccelerateConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              AccelerateConfiguration: {
                locationName: "AccelerateConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Status: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              }
            },
            payload: "AccelerateConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketAcl: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              AccessControlPolicy: {
                shape: "Sdk",
                locationName: "AccessControlPolicy",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AccessControlPolicy"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketAnalyticsConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?analytics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "AnalyticsConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              AnalyticsConfiguration: {
                shape: "S42",
                locationName: "AnalyticsConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AnalyticsConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketCors: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?cors"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CORSConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CORSConfiguration: {
                locationName: "CORSConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "CORSRules"
                ],
                members: {
                  CORSRules: {
                    shape: "S4h",
                    locationName: "CORSRule"
                  }
                }
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "CORSConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketEncryption: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?encryption"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "ServerSideEncryptionConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ServerSideEncryptionConfiguration: {
                shape: "S4u",
                locationName: "ServerSideEncryptionConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ServerSideEncryptionConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketIntelligentTieringConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?intelligent-tiering"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "IntelligentTieringConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              IntelligentTieringConfiguration: {
                shape: "S50",
                locationName: "IntelligentTieringConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              }
            },
            payload: "IntelligentTieringConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketInventoryConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?inventory"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "InventoryConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              InventoryConfiguration: {
                shape: "S5a",
                locationName: "InventoryConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "InventoryConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketLifecycle: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              LifecycleConfiguration: {
                locationName: "LifecycleConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    shape: "S5q",
                    locationName: "Rule"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LifecycleConfiguration"
          },
          deprecated: true,
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketLifecycleConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?lifecycle"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              LifecycleConfiguration: {
                locationName: "LifecycleConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Rules"
                ],
                members: {
                  Rules: {
                    shape: "S66",
                    locationName: "Rule"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LifecycleConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketLogging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?logging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "BucketLoggingStatus"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              BucketLoggingStatus: {
                locationName: "BucketLoggingStatus",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  LoggingEnabled: {
                    shape: "S6i"
                  }
                }
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "BucketLoggingStatus"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketMetricsConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?metrics"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Id",
              "MetricsConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Id: {
                location: "querystring",
                locationName: "id"
              },
              MetricsConfiguration: {
                shape: "S6u",
                locationName: "MetricsConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "MetricsConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketNotification: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "NotificationConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              NotificationConfiguration: {
                shape: "S6z",
                locationName: "NotificationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "NotificationConfiguration"
          },
          deprecated: true,
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketNotificationConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?notification"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "NotificationConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              NotificationConfiguration: {
                shape: "S7a",
                locationName: "NotificationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              SkipDestinationValidation: {
                location: "header",
                locationName: "x-amz-skip-destination-validation",
                type: "boolean"
              }
            },
            payload: "NotificationConfiguration"
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketOwnershipControls: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?ownershipControls"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "OwnershipControls"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              OwnershipControls: {
                shape: "S7r",
                locationName: "OwnershipControls",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              }
            },
            payload: "OwnershipControls"
          },
          httpChecksum: {
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketPolicy: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?policy"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Policy"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ConfirmRemoveSelfBucketAccess: {
                location: "header",
                locationName: "x-amz-confirm-remove-self-bucket-access",
                type: "boolean"
              },
              Policy: {},
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Policy"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketReplication: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?replication"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "ReplicationConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ReplicationConfiguration: {
                shape: "S83",
                locationName: "ReplicationConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Token: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-token"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ReplicationConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketRequestPayment: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?requestPayment"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "RequestPaymentConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              RequestPaymentConfiguration: {
                locationName: "RequestPaymentConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                required: [
                  "Payer"
                ],
                members: {
                  Payer: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "RequestPaymentConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketTagging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Tagging"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              Tagging: {
                shape: "Sea",
                locationName: "Tagging",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Tagging"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketVersioning: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?versioning"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "VersioningConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              MFA: {
                location: "header",
                locationName: "x-amz-mfa"
              },
              VersioningConfiguration: {
                locationName: "VersioningConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  MFADelete: {
                    locationName: "MfaDelete"
                  },
                  Status: {}
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "VersioningConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutBucketWebsite: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?website"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "WebsiteConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              WebsiteConfiguration: {
                locationName: "WebsiteConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  ErrorDocument: {
                    shape: "S9b"
                  },
                  IndexDocument: {
                    shape: "S99"
                  },
                  RedirectAllRequestsTo: {
                    shape: "S96"
                  },
                  RoutingRules: {
                    shape: "S9c"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "WebsiteConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        PutObject: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              Body: {
                streaming: true,
                type: "blob"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CacheControl: {
                location: "header",
                locationName: "Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "Content-Language"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ContentType: {
                location: "header",
                locationName: "Content-Type"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              Expires: {
                location: "header",
                locationName: "Expires",
                type: "timestamp"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-storage-class"
              },
              WebsiteRedirectLocation: {
                location: "header",
                locationName: "x-amz-website-redirect-location"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Tagging: {
                location: "header",
                locationName: "x-amz-tagging"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-object-lock-mode"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-object-lock-retain-until-date"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-object-lock-legal-hold"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Body"
          },
          output: {
            type: "structure",
            members: {
              Expiration: {
                location: "header",
                locationName: "x-amz-expiration"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSEKMSEncryptionContext: {
                shape: "S1i",
                location: "header",
                locationName: "x-amz-server-side-encryption-context"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        PutObjectAcl: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?acl"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              ACL: {
                location: "header",
                locationName: "x-amz-acl"
              },
              AccessControlPolicy: {
                shape: "Sdk",
                locationName: "AccessControlPolicy",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              GrantFullControl: {
                location: "header",
                locationName: "x-amz-grant-full-control"
              },
              GrantRead: {
                location: "header",
                locationName: "x-amz-grant-read"
              },
              GrantReadACP: {
                location: "header",
                locationName: "x-amz-grant-read-acp"
              },
              GrantWrite: {
                location: "header",
                locationName: "x-amz-grant-write"
              },
              GrantWriteACP: {
                location: "header",
                locationName: "x-amz-grant-write-acp"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "AccessControlPolicy"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectLegalHold: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?legal-hold"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              LegalHold: {
                shape: "Sar",
                locationName: "LegalHold",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "LegalHold"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectLockConfiguration: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?object-lock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ObjectLockConfiguration: {
                shape: "Sau",
                locationName: "ObjectLockConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              Token: {
                location: "header",
                locationName: "x-amz-bucket-object-lock-token"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "ObjectLockConfiguration"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectRetention: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?retention"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              Retention: {
                shape: "Sb2",
                locationName: "Retention",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              BypassGovernanceRetention: {
                location: "header",
                locationName: "x-amz-bypass-governance-retention",
                type: "boolean"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Retention"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutObjectTagging: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}?tagging"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "Tagging"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              Tagging: {
                shape: "Sea",
                locationName: "Tagging",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              }
            },
            payload: "Tagging"
          },
          output: {
            type: "structure",
            members: {
              VersionId: {
                location: "header",
                locationName: "x-amz-version-id"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          }
        },
        PutPublicAccessBlock: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}?publicAccessBlock"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "PublicAccessBlockConfiguration"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              PublicAccessBlockConfiguration: {
                shape: "Sb9",
                locationName: "PublicAccessBlockConfiguration",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "PublicAccessBlockConfiguration"
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: true
          },
          staticContextParams: {
            UseS3ExpressControlEndpoint: {
              value: true
            }
          }
        },
        RestoreObject: {
          http: {
            requestUri: "/{Bucket}/{Key+}?restore"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              VersionId: {
                location: "querystring",
                locationName: "versionId"
              },
              RestoreRequest: {
                locationName: "RestoreRequest",
                xmlNamespace: {
                  uri: "http://s3.amazonaws.com/doc/2006-03-01/"
                },
                type: "structure",
                members: {
                  Days: {
                    type: "integer"
                  },
                  GlacierJobParameters: {
                    type: "structure",
                    required: [
                      "Tier"
                    ],
                    members: {
                      Tier: {}
                    }
                  },
                  Type: {},
                  Tier: {},
                  Description: {},
                  SelectParameters: {
                    type: "structure",
                    required: [
                      "InputSerialization",
                      "ExpressionType",
                      "Expression",
                      "OutputSerialization"
                    ],
                    members: {
                      InputSerialization: {
                        shape: "Sf0"
                      },
                      ExpressionType: {},
                      Expression: {},
                      OutputSerialization: {
                        shape: "Sff"
                      }
                    }
                  },
                  OutputLocation: {
                    type: "structure",
                    members: {
                      S3: {
                        type: "structure",
                        required: [
                          "BucketName",
                          "Prefix"
                        ],
                        members: {
                          BucketName: {},
                          Prefix: {},
                          Encryption: {
                            type: "structure",
                            required: [
                              "EncryptionType"
                            ],
                            members: {
                              EncryptionType: {},
                              KMSKeyId: {
                                shape: "Sr"
                              },
                              KMSContext: {}
                            }
                          },
                          CannedACL: {},
                          AccessControlList: {
                            shape: "S3t"
                          },
                          Tagging: {
                            shape: "Sea"
                          },
                          UserMetadata: {
                            type: "list",
                            member: {
                              locationName: "MetadataEntry",
                              type: "structure",
                              members: {
                                Name: {},
                                Value: {}
                              }
                            }
                          },
                          StorageClass: {}
                        }
                      }
                    }
                  }
                }
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "RestoreRequest"
          },
          output: {
            type: "structure",
            members: {
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              },
              RestoreOutputPath: {
                location: "header",
                locationName: "x-amz-restore-output-path"
              }
            }
          },
          alias: "PostObjectRestore",
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        SelectObjectContent: {
          http: {
            requestUri: "/{Bucket}/{Key+}?select&select-type=2"
          },
          input: {
            locationName: "SelectObjectContentRequest",
            xmlNamespace: {
              uri: "http://s3.amazonaws.com/doc/2006-03-01/"
            },
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "Expression",
              "ExpressionType",
              "InputSerialization",
              "OutputSerialization"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              Expression: {},
              ExpressionType: {},
              RequestProgress: {
                type: "structure",
                members: {
                  Enabled: {
                    type: "boolean"
                  }
                }
              },
              InputSerialization: {
                shape: "Sf0"
              },
              OutputSerialization: {
                shape: "Sff"
              },
              ScanRange: {
                type: "structure",
                members: {
                  Start: {
                    type: "long"
                  },
                  End: {
                    type: "long"
                  }
                }
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              Payload: {
                type: "structure",
                members: {
                  Records: {
                    type: "structure",
                    members: {
                      Payload: {
                        eventpayload: true,
                        type: "blob"
                      }
                    },
                    event: true
                  },
                  Stats: {
                    type: "structure",
                    members: {
                      Details: {
                        eventpayload: true,
                        type: "structure",
                        members: {
                          BytesScanned: {
                            type: "long"
                          },
                          BytesProcessed: {
                            type: "long"
                          },
                          BytesReturned: {
                            type: "long"
                          }
                        }
                      }
                    },
                    event: true
                  },
                  Progress: {
                    type: "structure",
                    members: {
                      Details: {
                        eventpayload: true,
                        type: "structure",
                        members: {
                          BytesScanned: {
                            type: "long"
                          },
                          BytesProcessed: {
                            type: "long"
                          },
                          BytesReturned: {
                            type: "long"
                          }
                        }
                      }
                    },
                    event: true
                  },
                  Cont: {
                    type: "structure",
                    members: {},
                    event: true
                  },
                  End: {
                    type: "structure",
                    members: {},
                    event: true
                  }
                },
                eventstream: true
              }
            },
            payload: "Payload"
          }
        },
        UploadPart: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "Key",
              "PartNumber",
              "UploadId"
            ],
            members: {
              Body: {
                streaming: true,
                type: "blob"
              },
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentMD5: {
                location: "header",
                locationName: "Content-MD5"
              },
              ChecksumAlgorithm: {
                location: "header",
                locationName: "x-amz-sdk-checksum-algorithm"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              Key: {
                contextParam: {
                  name: "Key"
                },
                location: "uri",
                locationName: "Key"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              }
            },
            payload: "Body"
          },
          output: {
            type: "structure",
            members: {
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              ETag: {
                location: "header",
                locationName: "ETag"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-checksum-sha256"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            }
          },
          httpChecksum: {
            requestAlgorithmMember: "ChecksumAlgorithm",
            requestChecksumRequired: false
          }
        },
        UploadPartCopy: {
          http: {
            method: "PUT",
            requestUri: "/{Bucket}/{Key+}"
          },
          input: {
            type: "structure",
            required: [
              "Bucket",
              "CopySource",
              "Key",
              "PartNumber",
              "UploadId"
            ],
            members: {
              Bucket: {
                contextParam: {
                  name: "Bucket"
                },
                location: "uri",
                locationName: "Bucket"
              },
              CopySource: {
                location: "header",
                locationName: "x-amz-copy-source"
              },
              CopySourceIfMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-match"
              },
              CopySourceIfModifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-modified-since",
                type: "timestamp"
              },
              CopySourceIfNoneMatch: {
                location: "header",
                locationName: "x-amz-copy-source-if-none-match"
              },
              CopySourceIfUnmodifiedSince: {
                location: "header",
                locationName: "x-amz-copy-source-if-unmodified-since",
                type: "timestamp"
              },
              CopySourceRange: {
                location: "header",
                locationName: "x-amz-copy-source-range"
              },
              Key: {
                location: "uri",
                locationName: "Key"
              },
              PartNumber: {
                location: "querystring",
                locationName: "partNumber",
                type: "integer"
              },
              UploadId: {
                location: "querystring",
                locationName: "uploadId"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKey: {
                shape: "Sk",
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              CopySourceSSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-algorithm"
              },
              CopySourceSSECustomerKey: {
                shape: "S1k",
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key"
              },
              CopySourceSSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-copy-source-server-side-encryption-customer-key-MD5"
              },
              RequestPayer: {
                location: "header",
                locationName: "x-amz-request-payer"
              },
              ExpectedBucketOwner: {
                location: "header",
                locationName: "x-amz-expected-bucket-owner"
              },
              ExpectedSourceBucketOwner: {
                location: "header",
                locationName: "x-amz-source-expected-bucket-owner"
              }
            }
          },
          output: {
            type: "structure",
            members: {
              CopySourceVersionId: {
                location: "header",
                locationName: "x-amz-copy-source-version-id"
              },
              CopyPartResult: {
                type: "structure",
                members: {
                  ETag: {},
                  LastModified: {
                    type: "timestamp"
                  },
                  ChecksumCRC32: {},
                  ChecksumCRC32C: {},
                  ChecksumSHA1: {},
                  ChecksumSHA256: {}
                }
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-algorithm"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-server-side-encryption-customer-key-MD5"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-server-side-encryption-aws-kms-key-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-request-charged"
              }
            },
            payload: "CopyPartResult"
          },
          staticContextParams: {
            DisableS3ExpressSessionAuth: {
              value: true
            }
          }
        },
        WriteGetObjectResponse: {
          http: {
            requestUri: "/WriteGetObjectResponse"
          },
          input: {
            type: "structure",
            required: [
              "RequestRoute",
              "RequestToken"
            ],
            members: {
              RequestRoute: {
                hostLabel: true,
                location: "header",
                locationName: "x-amz-request-route"
              },
              RequestToken: {
                location: "header",
                locationName: "x-amz-request-token"
              },
              Body: {
                streaming: true,
                type: "blob"
              },
              StatusCode: {
                location: "header",
                locationName: "x-amz-fwd-status",
                type: "integer"
              },
              ErrorCode: {
                location: "header",
                locationName: "x-amz-fwd-error-code"
              },
              ErrorMessage: {
                location: "header",
                locationName: "x-amz-fwd-error-message"
              },
              AcceptRanges: {
                location: "header",
                locationName: "x-amz-fwd-header-accept-ranges"
              },
              CacheControl: {
                location: "header",
                locationName: "x-amz-fwd-header-Cache-Control"
              },
              ContentDisposition: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Disposition"
              },
              ContentEncoding: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Encoding"
              },
              ContentLanguage: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Language"
              },
              ContentLength: {
                location: "header",
                locationName: "Content-Length",
                type: "long"
              },
              ContentRange: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Range"
              },
              ContentType: {
                location: "header",
                locationName: "x-amz-fwd-header-Content-Type"
              },
              ChecksumCRC32: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-crc32"
              },
              ChecksumCRC32C: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-crc32c"
              },
              ChecksumSHA1: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-sha1"
              },
              ChecksumSHA256: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-checksum-sha256"
              },
              DeleteMarker: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-delete-marker",
                type: "boolean"
              },
              ETag: {
                location: "header",
                locationName: "x-amz-fwd-header-ETag"
              },
              Expires: {
                location: "header",
                locationName: "x-amz-fwd-header-Expires",
                type: "timestamp"
              },
              Expiration: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-expiration"
              },
              LastModified: {
                location: "header",
                locationName: "x-amz-fwd-header-Last-Modified",
                type: "timestamp"
              },
              MissingMeta: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-missing-meta",
                type: "integer"
              },
              Metadata: {
                shape: "S1b",
                location: "headers",
                locationName: "x-amz-meta-"
              },
              ObjectLockMode: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-mode"
              },
              ObjectLockLegalHoldStatus: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-legal-hold"
              },
              ObjectLockRetainUntilDate: {
                shape: "S1o",
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-object-lock-retain-until-date"
              },
              PartsCount: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-mp-parts-count",
                type: "integer"
              },
              ReplicationStatus: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-replication-status"
              },
              RequestCharged: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-request-charged"
              },
              Restore: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-restore"
              },
              ServerSideEncryption: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption"
              },
              SSECustomerAlgorithm: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm"
              },
              SSEKMSKeyId: {
                shape: "Sr",
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id"
              },
              SSECustomerKeyMD5: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5"
              },
              StorageClass: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-storage-class"
              },
              TagCount: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-tagging-count",
                type: "integer"
              },
              VersionId: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-version-id"
              },
              BucketKeyEnabled: {
                location: "header",
                locationName: "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled",
                type: "boolean"
              }
            },
            payload: "Body"
          },
          authtype: "v4-unsigned-body",
          endpoint: {
            hostPrefix: "{RequestRoute}."
          },
          staticContextParams: {
            UseObjectLambdaEndpoint: {
              value: true
            }
          }
        }
      },
      shapes: {
        Sk: {
          type: "blob",
          sensitive: true
        },
        Sr: {
          type: "string",
          sensitive: true
        },
        S1b: {
          type: "map",
          key: {},
          value: {}
        },
        S1i: {
          type: "string",
          sensitive: true
        },
        S1k: {
          type: "blob",
          sensitive: true
        },
        S1o: {
          type: "timestamp",
          timestampFormat: "iso8601"
        },
        S2h: {
          type: "string",
          sensitive: true
        },
        S3q: {
          type: "structure",
          members: {
            DisplayName: {},
            ID: {}
          }
        },
        S3t: {
          type: "list",
          member: {
            locationName: "Grant",
            type: "structure",
            members: {
              Grantee: {
                shape: "S3v"
              },
              Permission: {}
            }
          }
        },
        S3v: {
          type: "structure",
          required: [
            "Type"
          ],
          members: {
            DisplayName: {},
            EmailAddress: {},
            ID: {},
            Type: {
              locationName: "xsi:type",
              xmlAttribute: true
            },
            URI: {}
          },
          xmlNamespace: {
            prefix: "xsi",
            uri: "http://www.w3.org/2001/XMLSchema-instance"
          }
        },
        S42: {
          type: "structure",
          required: [
            "Id",
            "StorageClassAnalysis"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S45"
                },
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S48",
                      flattened: true,
                      locationName: "Tag"
                    }
                  }
                }
              }
            },
            StorageClassAnalysis: {
              type: "structure",
              members: {
                DataExport: {
                  type: "structure",
                  required: [
                    "OutputSchemaVersion",
                    "Destination"
                  ],
                  members: {
                    OutputSchemaVersion: {},
                    Destination: {
                      type: "structure",
                      required: [
                        "S3BucketDestination"
                      ],
                      members: {
                        S3BucketDestination: {
                          type: "structure",
                          required: [
                            "Format",
                            "Bucket"
                          ],
                          members: {
                            Format: {},
                            BucketAccountId: {},
                            Bucket: {},
                            Prefix: {}
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        S45: {
          type: "structure",
          required: [
            "Key",
            "Value"
          ],
          members: {
            Key: {},
            Value: {}
          }
        },
        S48: {
          type: "list",
          member: {
            shape: "S45",
            locationName: "Tag"
          }
        },
        S4h: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "AllowedMethods",
              "AllowedOrigins"
            ],
            members: {
              ID: {},
              AllowedHeaders: {
                locationName: "AllowedHeader",
                type: "list",
                member: {},
                flattened: true
              },
              AllowedMethods: {
                locationName: "AllowedMethod",
                type: "list",
                member: {},
                flattened: true
              },
              AllowedOrigins: {
                locationName: "AllowedOrigin",
                type: "list",
                member: {},
                flattened: true
              },
              ExposeHeaders: {
                locationName: "ExposeHeader",
                type: "list",
                member: {},
                flattened: true
              },
              MaxAgeSeconds: {
                type: "integer"
              }
            }
          },
          flattened: true
        },
        S4u: {
          type: "structure",
          required: [
            "Rules"
          ],
          members: {
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                members: {
                  ApplyServerSideEncryptionByDefault: {
                    type: "structure",
                    required: [
                      "SSEAlgorithm"
                    ],
                    members: {
                      SSEAlgorithm: {},
                      KMSMasterKeyID: {
                        shape: "Sr"
                      }
                    }
                  },
                  BucketKeyEnabled: {
                    type: "boolean"
                  }
                }
              },
              flattened: true
            }
          }
        },
        S50: {
          type: "structure",
          required: [
            "Id",
            "Status",
            "Tierings"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S45"
                },
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S48",
                      flattened: true,
                      locationName: "Tag"
                    }
                  }
                }
              }
            },
            Status: {},
            Tierings: {
              locationName: "Tiering",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "Days",
                  "AccessTier"
                ],
                members: {
                  Days: {
                    type: "integer"
                  },
                  AccessTier: {}
                }
              },
              flattened: true
            }
          }
        },
        S5a: {
          type: "structure",
          required: [
            "Destination",
            "IsEnabled",
            "Id",
            "IncludedObjectVersions",
            "Schedule"
          ],
          members: {
            Destination: {
              type: "structure",
              required: [
                "S3BucketDestination"
              ],
              members: {
                S3BucketDestination: {
                  type: "structure",
                  required: [
                    "Bucket",
                    "Format"
                  ],
                  members: {
                    AccountId: {},
                    Bucket: {},
                    Format: {},
                    Prefix: {},
                    Encryption: {
                      type: "structure",
                      members: {
                        SSES3: {
                          locationName: "SSE-S3",
                          type: "structure",
                          members: {}
                        },
                        SSEKMS: {
                          locationName: "SSE-KMS",
                          type: "structure",
                          required: [
                            "KeyId"
                          ],
                          members: {
                            KeyId: {
                              shape: "Sr"
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            },
            IsEnabled: {
              type: "boolean"
            },
            Filter: {
              type: "structure",
              required: [
                "Prefix"
              ],
              members: {
                Prefix: {}
              }
            },
            Id: {},
            IncludedObjectVersions: {},
            OptionalFields: {
              type: "list",
              member: {
                locationName: "Field"
              }
            },
            Schedule: {
              type: "structure",
              required: [
                "Frequency"
              ],
              members: {
                Frequency: {}
              }
            }
          }
        },
        S5q: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Prefix",
              "Status"
            ],
            members: {
              Expiration: {
                shape: "S5s"
              },
              ID: {},
              Prefix: {},
              Status: {},
              Transition: {
                shape: "S5x"
              },
              NoncurrentVersionTransition: {
                shape: "S5z"
              },
              NoncurrentVersionExpiration: {
                shape: "S61"
              },
              AbortIncompleteMultipartUpload: {
                shape: "S62"
              }
            }
          },
          flattened: true
        },
        S5s: {
          type: "structure",
          members: {
            Date: {
              shape: "S5t"
            },
            Days: {
              type: "integer"
            },
            ExpiredObjectDeleteMarker: {
              type: "boolean"
            }
          }
        },
        S5t: {
          type: "timestamp",
          timestampFormat: "iso8601"
        },
        S5x: {
          type: "structure",
          members: {
            Date: {
              shape: "S5t"
            },
            Days: {
              type: "integer"
            },
            StorageClass: {}
          }
        },
        S5z: {
          type: "structure",
          members: {
            NoncurrentDays: {
              type: "integer"
            },
            StorageClass: {},
            NewerNoncurrentVersions: {
              type: "integer"
            }
          }
        },
        S61: {
          type: "structure",
          members: {
            NoncurrentDays: {
              type: "integer"
            },
            NewerNoncurrentVersions: {
              type: "integer"
            }
          }
        },
        S62: {
          type: "structure",
          members: {
            DaysAfterInitiation: {
              type: "integer"
            }
          }
        },
        S66: {
          type: "list",
          member: {
            type: "structure",
            required: [
              "Status"
            ],
            members: {
              Expiration: {
                shape: "S5s"
              },
              ID: {},
              Prefix: {
                deprecated: true
              },
              Filter: {
                type: "structure",
                members: {
                  Prefix: {},
                  Tag: {
                    shape: "S45"
                  },
                  ObjectSizeGreaterThan: {
                    type: "long"
                  },
                  ObjectSizeLessThan: {
                    type: "long"
                  },
                  And: {
                    type: "structure",
                    members: {
                      Prefix: {},
                      Tags: {
                        shape: "S48",
                        flattened: true,
                        locationName: "Tag"
                      },
                      ObjectSizeGreaterThan: {
                        type: "long"
                      },
                      ObjectSizeLessThan: {
                        type: "long"
                      }
                    }
                  }
                }
              },
              Status: {},
              Transitions: {
                locationName: "Transition",
                type: "list",
                member: {
                  shape: "S5x"
                },
                flattened: true
              },
              NoncurrentVersionTransitions: {
                locationName: "NoncurrentVersionTransition",
                type: "list",
                member: {
                  shape: "S5z"
                },
                flattened: true
              },
              NoncurrentVersionExpiration: {
                shape: "S61"
              },
              AbortIncompleteMultipartUpload: {
                shape: "S62"
              }
            }
          },
          flattened: true
        },
        S6i: {
          type: "structure",
          required: [
            "TargetBucket",
            "TargetPrefix"
          ],
          members: {
            TargetBucket: {},
            TargetGrants: {
              type: "list",
              member: {
                locationName: "Grant",
                type: "structure",
                members: {
                  Grantee: {
                    shape: "S3v"
                  },
                  Permission: {}
                }
              }
            },
            TargetPrefix: {},
            TargetObjectKeyFormat: {
              type: "structure",
              members: {
                SimplePrefix: {
                  locationName: "SimplePrefix",
                  type: "structure",
                  members: {}
                },
                PartitionedPrefix: {
                  locationName: "PartitionedPrefix",
                  type: "structure",
                  members: {
                    PartitionDateSource: {}
                  }
                }
              }
            }
          }
        },
        S6u: {
          type: "structure",
          required: [
            "Id"
          ],
          members: {
            Id: {},
            Filter: {
              type: "structure",
              members: {
                Prefix: {},
                Tag: {
                  shape: "S45"
                },
                AccessPointArn: {},
                And: {
                  type: "structure",
                  members: {
                    Prefix: {},
                    Tags: {
                      shape: "S48",
                      flattened: true,
                      locationName: "Tag"
                    },
                    AccessPointArn: {}
                  }
                }
              }
            }
          }
        },
        S6y: {
          type: "structure",
          required: [
            "Bucket"
          ],
          members: {
            Bucket: {
              contextParam: {
                name: "Bucket"
              },
              location: "uri",
              locationName: "Bucket"
            },
            ExpectedBucketOwner: {
              location: "header",
              locationName: "x-amz-expected-bucket-owner"
            }
          }
        },
        S6z: {
          type: "structure",
          members: {
            TopicConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Events: {
                  shape: "S72",
                  locationName: "Event"
                },
                Event: {
                  deprecated: true
                },
                Topic: {}
              }
            },
            QueueConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Event: {
                  deprecated: true
                },
                Events: {
                  shape: "S72",
                  locationName: "Event"
                },
                Queue: {}
              }
            },
            CloudFunctionConfiguration: {
              type: "structure",
              members: {
                Id: {},
                Event: {
                  deprecated: true
                },
                Events: {
                  shape: "S72",
                  locationName: "Event"
                },
                CloudFunction: {},
                InvocationRole: {}
              }
            }
          }
        },
        S72: {
          type: "list",
          member: {},
          flattened: true
        },
        S7a: {
          type: "structure",
          members: {
            TopicConfigurations: {
              locationName: "TopicConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "TopicArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  TopicArn: {
                    locationName: "Topic"
                  },
                  Events: {
                    shape: "S72",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S7d"
                  }
                }
              },
              flattened: true
            },
            QueueConfigurations: {
              locationName: "QueueConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "QueueArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  QueueArn: {
                    locationName: "Queue"
                  },
                  Events: {
                    shape: "S72",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S7d"
                  }
                }
              },
              flattened: true
            },
            LambdaFunctionConfigurations: {
              locationName: "CloudFunctionConfiguration",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "LambdaFunctionArn",
                  "Events"
                ],
                members: {
                  Id: {},
                  LambdaFunctionArn: {
                    locationName: "CloudFunction"
                  },
                  Events: {
                    shape: "S72",
                    locationName: "Event"
                  },
                  Filter: {
                    shape: "S7d"
                  }
                }
              },
              flattened: true
            },
            EventBridgeConfiguration: {
              type: "structure",
              members: {}
            }
          }
        },
        S7d: {
          type: "structure",
          members: {
            Key: {
              locationName: "S3Key",
              type: "structure",
              members: {
                FilterRules: {
                  locationName: "FilterRule",
                  type: "list",
                  member: {
                    type: "structure",
                    members: {
                      Name: {},
                      Value: {}
                    }
                  },
                  flattened: true
                }
              }
            }
          }
        },
        S7r: {
          type: "structure",
          required: [
            "Rules"
          ],
          members: {
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "ObjectOwnership"
                ],
                members: {
                  ObjectOwnership: {}
                }
              },
              flattened: true
            }
          }
        },
        S83: {
          type: "structure",
          required: [
            "Role",
            "Rules"
          ],
          members: {
            Role: {},
            Rules: {
              locationName: "Rule",
              type: "list",
              member: {
                type: "structure",
                required: [
                  "Status",
                  "Destination"
                ],
                members: {
                  ID: {},
                  Priority: {
                    type: "integer"
                  },
                  Prefix: {
                    deprecated: true
                  },
                  Filter: {
                    type: "structure",
                    members: {
                      Prefix: {},
                      Tag: {
                        shape: "S45"
                      },
                      And: {
                        type: "structure",
                        members: {
                          Prefix: {},
                          Tags: {
                            shape: "S48",
                            flattened: true,
                            locationName: "Tag"
                          }
                        }
                      }
                    }
                  },
                  Status: {},
                  SourceSelectionCriteria: {
                    type: "structure",
                    members: {
                      SseKmsEncryptedObjects: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {}
                        }
                      },
                      ReplicaModifications: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {}
                        }
                      }
                    }
                  },
                  ExistingObjectReplication: {
                    type: "structure",
                    required: [
                      "Status"
                    ],
                    members: {
                      Status: {}
                    }
                  },
                  Destination: {
                    type: "structure",
                    required: [
                      "Bucket"
                    ],
                    members: {
                      Bucket: {},
                      Account: {},
                      StorageClass: {},
                      AccessControlTranslation: {
                        type: "structure",
                        required: [
                          "Owner"
                        ],
                        members: {
                          Owner: {}
                        }
                      },
                      EncryptionConfiguration: {
                        type: "structure",
                        members: {
                          ReplicaKmsKeyID: {}
                        }
                      },
                      ReplicationTime: {
                        type: "structure",
                        required: [
                          "Status",
                          "Time"
                        ],
                        members: {
                          Status: {},
                          Time: {
                            shape: "S8p"
                          }
                        }
                      },
                      Metrics: {
                        type: "structure",
                        required: [
                          "Status"
                        ],
                        members: {
                          Status: {},
                          EventThreshold: {
                            shape: "S8p"
                          }
                        }
                      }
                    }
                  },
                  DeleteMarkerReplication: {
                    type: "structure",
                    members: {
                      Status: {}
                    }
                  }
                }
              },
              flattened: true
            }
          }
        },
        S8p: {
          type: "structure",
          members: {
            Minutes: {
              type: "integer"
            }
          }
        },
        S96: {
          type: "structure",
          required: [
            "HostName"
          ],
          members: {
            HostName: {},
            Protocol: {}
          }
        },
        S99: {
          type: "structure",
          required: [
            "Suffix"
          ],
          members: {
            Suffix: {}
          }
        },
        S9b: {
          type: "structure",
          required: [
            "Key"
          ],
          members: {
            Key: {}
          }
        },
        S9c: {
          type: "list",
          member: {
            locationName: "RoutingRule",
            type: "structure",
            required: [
              "Redirect"
            ],
            members: {
              Condition: {
                type: "structure",
                members: {
                  HttpErrorCodeReturnedEquals: {},
                  KeyPrefixEquals: {}
                }
              },
              Redirect: {
                type: "structure",
                members: {
                  HostName: {},
                  HttpRedirectCode: {},
                  Protocol: {},
                  ReplaceKeyPrefixWith: {},
                  ReplaceKeyWith: {}
                }
              }
            }
          }
        },
        Sar: {
          type: "structure",
          members: {
            Status: {}
          }
        },
        Sau: {
          type: "structure",
          members: {
            ObjectLockEnabled: {},
            Rule: {
              type: "structure",
              members: {
                DefaultRetention: {
                  type: "structure",
                  members: {
                    Mode: {},
                    Days: {
                      type: "integer"
                    },
                    Years: {
                      type: "integer"
                    }
                  }
                }
              }
            }
          }
        },
        Sb2: {
          type: "structure",
          members: {
            Mode: {},
            RetainUntilDate: {
              shape: "S5t"
            }
          }
        },
        Sb9: {
          type: "structure",
          members: {
            BlockPublicAcls: {
              locationName: "BlockPublicAcls",
              type: "boolean"
            },
            IgnorePublicAcls: {
              locationName: "IgnorePublicAcls",
              type: "boolean"
            },
            BlockPublicPolicy: {
              locationName: "BlockPublicPolicy",
              type: "boolean"
            },
            RestrictPublicBuckets: {
              locationName: "RestrictPublicBuckets",
              type: "boolean"
            }
          }
        },
        Sby: {
          type: "list",
          member: {
            locationName: "Bucket",
            type: "structure",
            members: {
              Name: {},
              CreationDate: {
                type: "timestamp"
              }
            }
          }
        },
        Sch: {
          type: "structure",
          members: {
            ID: {},
            DisplayName: {}
          }
        },
        Sci: {
          type: "list",
          member: {
            type: "structure",
            members: {
              Prefix: {}
            }
          },
          flattened: true
        },
        Scn: {
          type: "list",
          member: {}
        },
        Sct: {
          type: "list",
          member: {},
          flattened: true
        },
        Scw: {
          type: "structure",
          members: {
            IsRestoreInProgress: {
              type: "boolean"
            },
            RestoreExpiryDate: {
              type: "timestamp"
            }
          }
        },
        Sd5: {
          type: "list",
          member: {
            type: "structure",
            members: {
              Key: {},
              LastModified: {
                type: "timestamp"
              },
              ETag: {},
              ChecksumAlgorithm: {
                shape: "Sct"
              },
              Size: {
                type: "long"
              },
              StorageClass: {},
              Owner: {
                shape: "S3q"
              },
              RestoreStatus: {
                shape: "Scw"
              }
            }
          },
          flattened: true
        },
        Sdk: {
          type: "structure",
          members: {
            Grants: {
              shape: "S3t",
              locationName: "AccessControlList"
            },
            Owner: {
              shape: "S3q"
            }
          }
        },
        Sea: {
          type: "structure",
          required: [
            "TagSet"
          ],
          members: {
            TagSet: {
              shape: "S48"
            }
          }
        },
        Sf0: {
          type: "structure",
          members: {
            CSV: {
              type: "structure",
              members: {
                FileHeaderInfo: {},
                Comments: {},
                QuoteEscapeCharacter: {},
                RecordDelimiter: {},
                FieldDelimiter: {},
                QuoteCharacter: {},
                AllowQuotedRecordDelimiter: {
                  type: "boolean"
                }
              }
            },
            CompressionType: {},
            JSON: {
              type: "structure",
              members: {
                Type: {}
              }
            },
            Parquet: {
              type: "structure",
              members: {}
            }
          }
        },
        Sff: {
          type: "structure",
          members: {
            CSV: {
              type: "structure",
              members: {
                QuoteFields: {},
                QuoteEscapeCharacter: {},
                RecordDelimiter: {},
                FieldDelimiter: {},
                QuoteCharacter: {}
              }
            },
            JSON: {
              type: "structure",
              members: {
                RecordDelimiter: {}
              }
            }
          }
        }
      },
      clientContextParams: {
        Accelerate: {
          documentation: "Enables this client to use S3 Transfer Acceleration endpoints.",
          type: "boolean"
        },
        DisableMultiRegionAccessPoints: {
          documentation: "Disables this client's usage of Multi-Region Access Points.",
          type: "boolean"
        },
        DisableS3ExpressSessionAuth: {
          documentation: "Disables this client's usage of Session Auth for S3Express\n      buckets and reverts to using conventional SigV4 for those.",
          type: "boolean"
        },
        ForcePathStyle: {
          documentation: "Forces this client to use path-style addressing for buckets.",
          type: "boolean"
        },
        UseArnRegion: {
          documentation: "Enables this client to use an ARN's region when constructing an endpoint instead of the client's configured region.",
          type: "boolean"
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json
var require_s3_2006_03_01_paginators = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.paginators.json"(exports, module) {
    module.exports = {
      pagination: {
        ListBuckets: {
          result_key: "Buckets"
        },
        ListDirectoryBuckets: {
          input_token: "ContinuationToken",
          limit_key: "MaxDirectoryBuckets",
          output_token: "ContinuationToken",
          result_key: "Buckets"
        },
        ListMultipartUploads: {
          input_token: [
            "KeyMarker",
            "UploadIdMarker"
          ],
          limit_key: "MaxUploads",
          more_results: "IsTruncated",
          output_token: [
            "NextKeyMarker",
            "NextUploadIdMarker"
          ],
          result_key: [
            "Uploads",
            "CommonPrefixes"
          ]
        },
        ListObjectVersions: {
          input_token: [
            "KeyMarker",
            "VersionIdMarker"
          ],
          limit_key: "MaxKeys",
          more_results: "IsTruncated",
          output_token: [
            "NextKeyMarker",
            "NextVersionIdMarker"
          ],
          result_key: [
            "Versions",
            "DeleteMarkers",
            "CommonPrefixes"
          ]
        },
        ListObjects: {
          input_token: "Marker",
          limit_key: "MaxKeys",
          more_results: "IsTruncated",
          output_token: "NextMarker || Contents[-1].Key",
          result_key: [
            "Contents",
            "CommonPrefixes"
          ]
        },
        ListObjectsV2: {
          input_token: "ContinuationToken",
          limit_key: "MaxKeys",
          output_token: "NextContinuationToken",
          result_key: [
            "Contents",
            "CommonPrefixes"
          ]
        },
        ListParts: {
          input_token: "PartNumberMarker",
          limit_key: "MaxParts",
          more_results: "IsTruncated",
          output_token: "NextPartNumberMarker",
          result_key: "Parts"
        }
      }
    };
  }
});

// node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json
var require_s3_2006_03_01_waiters2 = __commonJS({
  "node_modules/aws-sdk/apis/s3-2006-03-01.waiters2.json"(exports, module) {
    module.exports = {
      version: 2,
      waiters: {
        BucketExists: {
          delay: 5,
          operation: "HeadBucket",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 200,
              matcher: "status",
              state: "success"
            },
            {
              expected: 301,
              matcher: "status",
              state: "success"
            },
            {
              expected: 403,
              matcher: "status",
              state: "success"
            },
            {
              expected: 404,
              matcher: "status",
              state: "retry"
            }
          ]
        },
        BucketNotExists: {
          delay: 5,
          operation: "HeadBucket",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 404,
              matcher: "status",
              state: "success"
            }
          ]
        },
        ObjectExists: {
          delay: 5,
          operation: "HeadObject",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 200,
              matcher: "status",
              state: "success"
            },
            {
              expected: 404,
              matcher: "status",
              state: "retry"
            }
          ]
        },
        ObjectNotExists: {
          delay: 5,
          operation: "HeadObject",
          maxAttempts: 20,
          acceptors: [
            {
              expected: 404,
              matcher: "status",
              state: "success"
            }
          ]
        }
      }
    };
  }
});

// node_modules/aws-sdk/clients/s3.js
var require_s33 = __commonJS({
  "node_modules/aws-sdk/clients/s3.js"(exports, module) {
    require_browser_loader();
    var AWS2 = require_core();
    var Service = AWS2.Service;
    var apiLoader = AWS2.apiLoader;
    apiLoader.services["s3"] = {};
    AWS2.S3 = Service.defineService("s3", ["2006-03-01"]);
    require_s32();
    Object.defineProperty(apiLoader.services["s3"], "2006-03-01", {
      get: function get() {
        var model = require_s3_2006_03_01_min();
        model.paginators = require_s3_2006_03_01_paginators().pagination;
        model.waiters = require_s3_2006_03_01_waiters2().waiters;
        return model;
      },
      enumerable: true,
      configurable: true
    });
    module.exports = AWS2.S3;
  }
});

export {
  require_core,
  require_sts2 as require_sts,
  require_cognitoidentity,
  require_browser_loader,
  require_s33 as require_s3
};
/*! Bundled license information:

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <http://feross.org>
   * @license  MIT
   *)

punycode/punycode.js:
  (*! https://mths.be/punycode v1.3.2 by @mathias *)
*/
//# sourceMappingURL=chunk-CURH2JA3.js.map
